(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ "./node_modules/raw-loader/dist/cjs.js!./js/SRW Core/SRPG_core.js":
/*!************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./js/SRW Core/SRPG_core.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"//=============================================================================\\r\\n// SRPG_core.js -SRPGコンバータMV-\\r\\n// バージョン   : 1.22\\r\\n// 最終更新日   : 2019/8/23\\r\\n// 制作         : 神鏡学斗\\r\\n// 配布元       : http://www.lemon-slice.net/\\r\\n// バグ修正協力 : アンチョビ様　\\r\\n//                エビ様　http://www.zf.em-net.ne.jp/~ebi-games/\\r\\n//                Tsumio様\\r\\n// Copyright 2017 - 2019 Lemon slice all rights reserved.\\r\\n//-----------------------------------------------------------------------------\\r\\n// SRW Engine MV\\r\\n// Version   : 1.0\\r\\n// Copyright 2020 The Shadow Knight all rights reserved.\\r\\n//-----------------------------------------------------------------------------\\r\\n// Released under the MIT license.\\r\\n// http://opensource.org/licenses/mit-license.php\\r\\n//=============================================================================\\r\\n\\r\\n//global reference to the filesystem module to circumvent issues with webpacked sections(battle scene)\\r\\nconst FILESYSTEM = require(\\\"fs\\\");\\r\\n\\r\\n//disable touch support\\r\\n\\r\\nTouchInput.update = function() {}\\r\\n \\r\\n//Control variable ids \\r\\nvar _nextMapVariable = 6;\\r\\nvar _nextMapXVariable = 7;\\r\\nvar _nextMapYVariable = 8;\\r\\nvar _nextMapDeployVariable = 9;\\r\\nvar _SRCountVariable = 10;\\r\\nvar _lastStageIdVariable = 11;\\r\\nvar _turnCountVariable = 12;\\r\\n\\r\\nvar _currentActorId = 13;\\r\\nvar _currentEnemyId = 14;\\r\\n\\r\\nvar _actorsDestroyed = 15;\\r\\nvar _enemiesDestroyed = 16;\\r\\n\\r\\nvar _masteryConditionText = 17;\\r\\nvar _victoryConditionText = 18;\\r\\nvar _defeatConditionText = 19;\\r\\n\\r\\nvar _existShipVarId = 20;\\r\\n\\r\\nvar _lastActorAttackId = 61;\\r\\nvar _lastActorSupportAttackId = 62;\\r\\nvar _lastEnemyAttackId = 63;\\r\\nvar _lastEnemySupportAttackId = 64;\\r\\n\\r\\nif(typeof ENGINE_SETTINGS == \\\"undefined\\\"){\\r\\n\\tENGINE_SETTINGS = {};\\r\\n}\\r\\nObject.keys(ENGINE_SETTINGS_DEFAULT).forEach(function(key){\\r\\n\\tif(ENGINE_SETTINGS[key] == null){\\r\\n\\t\\tENGINE_SETTINGS[key] = ENGINE_SETTINGS_DEFAULT[key];\\r\\n\\t}\\r\\n});\\r\\n\\r\\nvar $SRWEditor = new SRWEditor();\\r\\n\\r\\nvar $SRWGameState = new GameStateManager();\\r\\n$SRWGameState.requestNewState(\\\"normal\\\");\\r\\n\\r\\nvar $SRWStageInfoManager = new SRWStageInfoManager();\\r\\nvar $SRWSaveManager = new SRWSaveManager();\\r\\nvar $statCalc = new StatCalc();\\r\\nvar $spiritManager = new SpiritManager(); \\r\\nvar $pilotAbilityManager = new PilotAbilityManager(); \\r\\nvar $mechAbilityManager = new MechAbilityManager(); \\r\\nvar $itemEffectManager = new ItemEffectManager(); \\r\\nvar $abilityCommandManger = new AbilityCommandManger();\\r\\nvar $weaponEffectManager = new WeaponEffectManager();\\r\\nvar $relationshipBonusManager = new RelationshipBonusManager();\\r\\nvar $battleCalc = new BattleCalc();\\r\\nvar $CSSUIManager = new CSSUIManager();\\r\\nvar $songManager = new SRWSongManager();\\r\\nvar $mapAttackManager = new MapAttackManager();\\r\\n\\r\\nvar $inventoryManager = new SRWInventoryManager();\\r\\n \\r\\nvar $battleSceneManager = new BattleSceneManager();\\r\\n\\r\\nvar parameters = PluginManager.parameters('SRPG_core');\\r\\nvar _srpgTroopID = Number(parameters['srpgTroopID'] || 1);\\r\\nvar _srpgBattleSwitchID = Number(parameters['srpgBattleSwitchID'] || 1);\\r\\nvar _endIntermissionSwitchID = 3;\\r\\nvar _inIntermissionSwitchID = 4;\\r\\nvar _existActorVarID = Number(parameters['existActorVarID'] || 1);\\r\\nvar _existEnemyVarID = Number(parameters['existEnemyVarID'] || 2);\\r\\n\\r\\nvar _turnVarID = Number(parameters['turnVarID'] || 3);\\r\\nvar _activeEventID = Number(parameters['activeEventID'] || 4);\\r\\nvar _targetEventID = Number(parameters['targetEventID'] || 5);\\r\\nvar _defaultMove = Number(parameters['defaultMove'] || 4);\\r\\nvar _srpgBattleExpRate = Number(parameters['srpgBattleExpRate'] || 0.4);\\r\\nvar _srpgBattleExpRateForActors = Number(parameters['srpgBattleExpRateForActors'] || 0.1);\\r\\nvar _enemyDefaultClass = parameters['enemyDefaultClass'] || 'エネミー';\\r\\nvar _textSrpgEquip = parameters['textSrpgEquip'] || '装備';\\r\\nvar _textSrpgMove = parameters['textSrpgMove'] || '移動力';\\r\\nvar _textSrpgRange = parameters['textSrpgRange'] || '射程';\\r\\nvar _textSrpgWait = parameters['textSrpgWait'] || '待機';\\r\\nvar _textSrpgTurnEnd = parameters['textSrpgTurnEnd'] || 'ターン終了';\\r\\nvar _textSrpgAutoBattle = parameters['textSrpgAutoBattle'] || 'オート戦闘';\\r\\nvar _srpgBattleQuickLaunch = parameters['srpgBattleQuickLaunch'] || 'true';\\r\\nvar _srpgActorCommandEquip = parameters['srpgActorCommandEquip'] || 'true';\\r\\nvar _srpgBattleEndAllHeal = parameters['srpgBattleEndAllHeal'] || 'true';\\r\\nvar _srpgStandUnitSkip = parameters['srpgStandUnitSkip'] || 'false';\\r\\nvar _srpgPredictionWindowMode = Number(parameters['srpgPredictionWindowMode'] || 1);\\r\\nvar _srpgAutoBattleStateId = Number(parameters['srpgAutoBattleStateId'] || 14);\\r\\nvar _srpgBestSearchRouteSize = Number(parameters['srpgBestSearchRouteSize'] || 20);\\r\\nvar _srpgDamageDirectionChange = parameters['srpgDamageDirectionChange'] || 'true';\\r\\nvar _defaultPlayerSpeed = parameters['defaultPlayerSpeed'] || 4;\\r\\n\\r\\n\\r\\n(function() {\\r\\n\\t//TODO: Proper pre-loading/load waiting\\r\\n\\r\\n\\t\\r\\n    \\r\\n\\t\\r\\n\\t\\r\\n\\t\\r\\n\\tInput._isEscapeCompatible = function(keyName) {\\r\\n\\t\\treturn keyName === 'cancel';\\r\\n\\t};\\r\\n\\t\\r\\n\\tInput._shouldPreventDefault = function(keyCode) {\\r\\n\\t\\tif($gameTemp.editMode){\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tswitch (keyCode) {\\r\\n\\t\\t\\t\\tcase 8:     // backspace\\r\\n\\t\\t\\t\\tcase 33:    // pageup\\r\\n\\t\\t\\t\\tcase 34:    // pagedown\\r\\n\\t\\t\\t\\tcase 37:    // left arrow\\r\\n\\t\\t\\t\\tcase 38:    // up arrow\\r\\n\\t\\t\\t\\tcase 39:    // right arrow\\r\\n\\t\\t\\t\\tcase 40:    // down arrow\\r\\n\\t\\t\\t\\t\\treturn true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\treturn false;\\r\\n\\t};\\r\\n\\t\\r\\n\\t/*Input._pollGamepads = function() {\\r\\n\\t\\tif (navigator.getGamepads) {\\r\\n\\t\\t\\tvar gamepads = navigator.getGamepads();\\r\\n\\t\\t\\tif (gamepads) {\\r\\n\\t\\t\\t\\tfor (var i = 0; i < gamepads.length; i++) {\\r\\n\\t\\t\\t\\t\\tvar gamepad = gamepads[i];\\r\\n\\t\\t\\t\\t\\tif (gamepad && gamepad.connected && gamepad.id == \\\"Xbox 360 Controller (XInput STANDARD GAMEPAD)\\\") {\\r\\n\\t\\t\\t\\t\\t\\tthis._updateGamepadState(gamepad);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t};*/\\r\\n\\t\\r\\n\\tTouchInput._onWheel = function(event) {\\r\\n\\t\\t\\r\\n\\t}\\r\\n\\t\\r\\n\\tGraphics._createAllElements = function() {\\r\\n\\t\\tthis._createErrorPrinter();\\r\\n\\t\\tthis._createCanvas();\\r\\n\\t\\tthis._createVideo();\\r\\n\\t\\tthis._createUpperCanvas();\\r\\n\\t\\tthis._createRenderer();\\r\\n\\t\\tthis._createFPSMeter();\\r\\n\\t\\tthis._createModeBox();\\r\\n\\t\\tthis._createGameFontLoader();\\r\\n\\t\\t\\r\\n\\t\\t$CSSUIManager.initAllWindows();\\t\\r\\n\\t\\t$battleSceneManager.initContainer();\\t\\t\\t\\r\\n\\t};\\r\\n\\t\\r\\n\\r\\n\\t\\r\\n\\tGraphics.render = function(stage) {\\r\\n\\t\\tif (this._skipCount <= 0) { //fix for rare freezes\\r\\n\\t\\t\\tvar startTime = Date.now();\\r\\n\\t\\t\\tif (stage) {\\r\\n\\t\\t\\t\\tthis._renderer.render(stage);\\r\\n\\t\\t\\t\\tif (this._renderer.gl && this._renderer.gl.flush) {\\r\\n\\t\\t\\t\\t\\tthis._renderer.gl.flush();\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tvar endTime = Date.now();\\r\\n\\t\\t\\tvar elapsed = endTime - startTime;\\r\\n\\t\\t\\tthis._skipCount = Math.min(Math.floor(elapsed / 15), this._maxSkip);\\r\\n\\t\\t\\tthis._rendered = true;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis._skipCount--;\\r\\n\\t\\t\\tthis._rendered = false;\\r\\n\\t\\t}\\r\\n\\t\\tthis.frameCount++;\\r\\n\\t};\\r\\n\\t\\r\\n\\r\\n\\tvar Graphics_updateCanvas = Graphics._updateCanvas;\\r\\n\\tGraphics._updateCanvas = function(windowId){\\r\\n\\t\\tGraphics_updateCanvas.call(this);\\r\\n\\t\\tif(!$gameTemp || !$gameTemp.editMode){\\r\\n\\t\\t\\tvar battleScenePIXILayer = document.querySelector(\\\"#battle_scene_pixi_layer\\\");\\r\\n\\t\\t\\tif(battleScenePIXILayer){\\r\\n\\t\\t\\t\\tbattleScenePIXILayer.width = this._width;\\r\\n\\t\\t\\t\\tbattleScenePIXILayer.height = this._height;\\r\\n\\t\\t\\t\\tthis._centerElement(battleScenePIXILayer);\\r\\n\\t\\t\\t}\\t\\r\\n\\t\\t\\tvar customUILayer = document.querySelector(\\\"#custom_UI_layer\\\");\\r\\n\\t\\t\\tif(customUILayer){\\r\\n\\t\\t\\t\\tcustomUILayer.width = this._width;\\r\\n\\t\\t\\t\\tcustomUILayer.height = this._height;\\r\\n\\t\\t\\t\\tthis._centerElement(customUILayer);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tvar battleSceneLayer = document.querySelector(\\\"#battle_scene_layer\\\");\\r\\n\\t\\t\\tif(battleSceneLayer){\\r\\n\\t\\t\\t\\tbattleSceneLayer.width = this._width;\\r\\n\\t\\t\\t\\tbattleSceneLayer.height = this._height;\\r\\n\\t\\t\\t\\tthis._centerElement(battleSceneLayer);\\r\\n\\t\\t\\t}\\t\\r\\n\\t\\t\\tvar battleSceneUILayer = document.querySelector(\\\"#battle_scene_ui_layer\\\");\\r\\n\\t\\t\\tif(battleSceneUILayer){\\r\\n\\t\\t\\t\\tbattleSceneUILayer.width = this._width;\\r\\n\\t\\t\\t\\tbattleSceneUILayer.height = this._height;\\r\\n\\t\\t\\t\\tthis._centerElement(battleSceneUILayer);\\r\\n\\t\\t\\t}\\t\\r\\n\\t\\t\\tvar fadeContainer = document.querySelector(\\\"#fade_container\\\");\\r\\n\\t\\t\\tif(fadeContainer){\\r\\n\\t\\t\\t\\tfadeContainer.width = this._width;\\r\\n\\t\\t\\t\\tfadeContainer.height = this._height;\\r\\n\\t\\t\\t\\tthis._centerElement(fadeContainer);\\r\\n\\t\\t\\t}\\t\\r\\n\\t\\t}\\t\\r\\n\\t\\t$CSSUIManager.updateScaledText(windowId);\\t\\t\\t\\t\\r\\n\\t}\\r\\n\\t\\r\\n\\tImageManager.getTranslationInfo = function(filename){\\t\\t\\r\\n\\t\\tif($gameSystem.faceAliases && $gameSystem.faceAliases[filename]){\\r\\n\\t\\t\\tfilename = $gameSystem.faceAliases[filename];\\r\\n\\t\\t}\\r\\n\\t\\tif(ENGINE_SETTINGS.variableUnitPortraits){\\r\\n\\t\\t\\tvar keyParts = filename.split(\\\"_\\\");\\r\\n\\t\\t\\tkeyParts.pop();\\r\\n\\t\\t\\tvar variablePortraitKey = keyParts.join(\\\"_\\\");\\r\\n\\t\\t\\tvar defs = ENGINE_SETTINGS.variableUnitPortraits[variablePortraitKey];\\r\\n\\t\\t\\tif(defs){\\r\\n\\t\\t\\t\\tvar translationFound = false;\\r\\n\\t\\t\\t\\tvar ctr = 0;\\r\\n\\t\\t\\t\\twhile(ctr < defs.length && !translationFound){\\r\\n\\t\\t\\t\\t\\tvar def = defs[ctr];\\r\\n\\t\\t\\t\\t\\tvar mechId = def.deployedId;\\r\\n\\t\\t\\t\\t\\tif($statCalc.isMechDeployed(mechId)){\\r\\n\\t\\t\\t\\t\\t\\ttranslationFound = true;\\r\\n\\t\\t\\t\\t\\t\\tfilename = def.filename;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tctr++;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\treturn filename;\\r\\n\\t}\\r\\n\\t\\r\\n\\tImageManager.loadFace = function(filename, hue) {\\r\\n\\t\\tfilename = this.getTranslationInfo(filename); \\r\\n\\t\\treturn this.loadBitmap('img/faces/', filename, hue, true);\\r\\n\\t};\\t\\r\\n\\t\\r\\n\\tImageManager.requestFace = function(filename, hue) {\\t\\t\\r\\n\\t\\tfilename = this.getTranslationInfo(filename); \\t\\t\\r\\n\\t\\treturn this.requestBitmap('img/faces/', filename, hue, true);\\r\\n\\t};\\r\\n\\t\\r\\n\\tImageManager.reserveFace = function(filename, hue, reservationId) {\\r\\n\\t\\tfilename = this.getTranslationInfo(filename); \\r\\n\\t\\treturn this.reserveBitmap('img/faces/', filename, hue, true, reservationId);\\r\\n\\t};\\r\\n\\r\\n\\t\\r\\n    var _Game_Interpreter_pluginCommand =\\r\\n            Game_Interpreter.prototype.pluginCommand;\\r\\n    Game_Interpreter.prototype.pluginCommand = function(command, args) {\\r\\n        _Game_Interpreter_pluginCommand.call(this, command, args);\\r\\n\\t\\t\\r\\n        if (command === 'SRPGBattle') {\\r\\n            switch (args[0]) {\\r\\n            case 'Start':\\r\\n                $gameSystem.startSRPG();\\r\\n                break;\\r\\n            case 'End':\\r\\n                $gameSystem.endSRPG();\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\t\\tif (command === 'Intermission') {\\r\\n            switch (args[0]) {\\r\\n            case 'Start':\\r\\n                $gameSystem.startIntermission();\\r\\n                break;\\r\\n            case 'End':\\r\\n\\t\\t\\t\\t$gameSystem.endIntermission();\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\t\\tif (command === 'UnlockUnit') {\\r\\n            $SRWSaveManager.setUnitUnlocked(args[0]);\\r\\n        }\\r\\n\\t\\tif (command === 'unlockUnit') {\\r\\n            $SRWSaveManager.setUnitUnlocked(args[0]);\\r\\n        }\\r\\n\\t\\tif (command === 'lockUnit') {\\r\\n            $SRWSaveManager.setUnitLocked(args[0]);\\r\\n        }\\r\\n\\t\\tif (command === 'SetLevel') {\\r\\n            $SRWSaveManager.setPilotLevel(args[0], args[1]);\\r\\n        }\\r\\n\\t\\tif (command === 'setLevel') {\\r\\n            $SRWSaveManager.setPilotLevel(args[0], args[1]);\\r\\n        }\\r\\n\\t\\tif (command === 'addKills') {\\r\\n            $SRWSaveManager.addKills(args[0], args[1]);\\r\\n        }\\t\\t\\r\\n\\t\\tif (command === 'addPP') {\\r\\n            $SRWSaveManager.addPP(args[0], args[1]);\\r\\n        }\\r\\n\\t\\tif (command === 'addExp') {\\r\\n            $SRWSaveManager.addExp(args[0], args[1]);\\r\\n        }\\r\\n\\t\\tif (command === 'setStageSong') {\\r\\n            $gameSystem.currentStageSong  = args[0];\\r\\n        }\\t\\r\\n\\t\\tif (command === 'setSpecialTheme') {\\r\\n            $songManager.setSpecialTheme(args[0]);\\r\\n        }\\t\\r\\n\\t\\tif (command === 'clearSpecialTheme') {\\r\\n            $songManager.clearSpecialTheme();\\r\\n        }\\t\\t\\t\\r\\n\\t\\tif (command === 'addItem') {\\r\\n            $inventoryManager.addItem(args[0]);\\r\\n        }\\t\\r\\n\\t\\tif (command === 'addAllItems') {            \\r\\n\\t\\t\\tfor(var i = 0; i < $itemEffectManager.getDefinitionCount(); i++){\\r\\n\\t\\t\\t\\t$inventoryManager.addItem(i);\\r\\n\\t\\t\\t}\\r\\n        }\\r\\n\\t\\tif (command === 'removeItem') {\\r\\n            $inventoryManager.removeItem(args[0]);\\r\\n        }\\t\\r\\n\\t\\tif (command === 'addItemToHolder') {\\r\\n            $inventoryManager.addItemHolder(args[0], args[1], args[2]);\\r\\n        }\\r\\n\\t\\tif (command === 'removeItemFromHolder') {\\r\\n            $inventoryManager.removeItemHolder(args[0], args[1]);\\r\\n        }\\r\\n\\t\\tif (command === 'focusActor') {\\r\\n\\t\\t\\tvar actorId = args[0];\\r\\n\\t\\t\\tvar parts = actorId.match(/\\\\<(.*)\\\\>/);\\t\\r\\n\\t\\t\\tif(parts && parts.length > 1){\\r\\n\\t\\t\\t\\tactorId = $gameVariables.value(parts[1]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tvar event = $statCalc.getReferenceEvent($gameActors.actor(actorId));\\r\\n\\t\\t\\tif(event && !event.isErased()){\\r\\n\\t\\t\\t\\t$gamePlayer.locate(event.posX(), event.posY());\\r\\n\\t\\t\\t}\\r\\n        }\\r\\n\\t\\tif (command === 'focusEvent') {\\r\\n\\t\\t\\tvar event = $gameMap.event(args[0]);\\r\\n\\t\\t\\tif(event && !event.isErased()){\\r\\n\\t\\t\\t\\t$gamePlayer.locate(event.posX(), event.posY());\\r\\n\\t\\t\\t}\\r\\n        }\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'clearDeployInfo') {\\r\\n\\t\\t\\tvar deployInfo = $gameSystem.getDeployInfo();\\r\\n\\t\\t\\tdeployInfo.count = 0;\\r\\n\\t\\t\\tdeployInfo.assigned = {};\\r\\n\\t\\t\\tdeployInfo.assignedSub = {};\\r\\n\\t\\t\\tdeployInfo.assignedShips = {};\\r\\n\\t\\t\\tdeployInfo.lockedSlots = {};\\r\\n\\t\\t\\tdeployInfo.lockedShipSlots = {};\\r\\n\\t\\t\\t$gameSystem.setDeployInfo(deployInfo);\\r\\n        }\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'populateDeployList') {\\r\\n\\t\\t\\t$gameSystem.constructDeployList();\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setDeployCount') {\\r\\n\\t\\t\\tvar deployInfo = $gameSystem.getDeployInfo();\\r\\n\\t\\t\\tdeployInfo.count = args[0];\\r\\n\\t\\t\\t$gameSystem.setDeployInfo(deployInfo);\\r\\n        }\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setShipDeployCount') {\\r\\n\\t\\t\\tvar deployInfo = $gameSystem.getDeployInfo();\\r\\n\\t\\t\\tdeployInfo.shipCount = args[0];\\r\\n\\t\\t\\t$gameSystem.setDeployInfo(deployInfo);\\r\\n        }\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'assignSlot') {\\r\\n\\t\\t\\t//args[0]: slot \\r\\n\\t\\t\\t//args[1]: actor id\\r\\n\\t\\t\\tvar deployInfo = $gameSystem.getDeployInfo();\\r\\n\\t\\t\\tvar actorId = args[1];\\r\\n\\t\\t\\tvar parts = actorId.match(/\\\\<(.*)\\\\>/);\\t\\r\\n\\t\\t\\tif(parts && parts.length > 1){\\r\\n\\t\\t\\t\\tactorId = $gameVariables.value(parts[1]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tdeployInfo.assigned[args[0]] = actorId;\\r\\n\\t\\t\\t$gameSystem.setDeployInfo(deployInfo);\\r\\n        }\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'assignSlotSub') {\\r\\n\\t\\t\\t//args[0]: slot \\r\\n\\t\\t\\t//args[1]: actor id\\r\\n\\t\\t\\tvar deployInfo = $gameSystem.getDeployInfo();\\r\\n\\t\\t\\tvar actorId = args[1];\\r\\n\\t\\t\\tvar parts = actorId.match(/\\\\<(.*)\\\\>/);\\t\\r\\n\\t\\t\\tif(parts && parts.length > 1){\\r\\n\\t\\t\\t\\tactorId = $gameVariables.value(parts[1]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tdeployInfo.assignedSub[args[0]] = actorId;\\r\\n\\t\\t\\t$gameSystem.setDeployInfo(deployInfo);\\r\\n        }\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'assignShipSlot') {\\r\\n\\t\\t\\t//args[0]: slot \\r\\n\\t\\t\\t//args[1]: actor id\\r\\n\\t\\t\\tvar deployInfo = $gameSystem.getDeployInfo();\\r\\n\\t\\t\\tdeployInfo.assignedShips[args[0]] = args[1];\\r\\n\\t\\t\\t$gameSystem.setDeployInfo(deployInfo);\\r\\n        }\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'lockDeploySlot') {\\r\\n\\t\\t\\t//prevents a slot from being changed by the player in the menu, assignSlot can still override\\r\\n\\t\\t\\tvar deployInfo = $gameSystem.getDeployInfo();\\r\\n\\t\\t\\tdeployInfo.lockedSlots[args[0]] = true;\\r\\n\\t\\t\\t$gameSystem.setDeployInfo(deployInfo);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'unlockDeploySlot') {\\r\\n\\t\\t\\tvar deployInfo = $gameSystem.getDeployInfo();\\r\\n\\t\\t\\tdeployInfo.lockedSlots[args[0]] = false;\\r\\n\\t\\t\\t$gameSystem.setDeployInfo(deployInfo);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'lockShipDeploySlot') {\\r\\n\\t\\t\\t//prevents a slot from being changed by the player in the menu, assignSlot can still override\\r\\n\\t\\t\\tvar deployInfo = $gameSystem.getDeployInfo();\\r\\n\\t\\t\\tdeployInfo.lockedShipSlots[args[0]] = true;\\r\\n\\t\\t\\t$gameSystem.setDeployInfo(deployInfo);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'unlockShipDeploySlot') {\\r\\n\\t\\t\\tvar deployInfo = $gameSystem.getDeployInfo();\\r\\n\\t\\t\\tdeployInfo.lockedShipSlots[args[0]] = false;\\r\\n\\t\\t\\t$gameSystem.setDeployInfo(deployInfo);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setSRWBattleBg') {\\r\\n\\t\\t\\t$gameSystem.battleBg = args[0];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setSRWBattleParallax1') {\\r\\n\\t\\t\\t$gameSystem.battleParallax1 = args[0];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setSRWBattleParallax2') {\\r\\n\\t\\t\\t$gameSystem.battleParallax2 = args[0];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setSRWBattleParallax3') {\\r\\n\\t\\t\\t$gameSystem.battleParallax3 = args[0];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setSRWBattleParallax3') {\\r\\n\\t\\t\\t$gameSystem.battleParallax3 = args[0];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setSRWBattleFloor') {\\r\\n\\t\\t\\t$gameSystem.battleFloor = args[0];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setSRWBattleSkybox') {\\r\\n\\t\\t\\t$gameSystem.battleSkyBox = args[0];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setSRWSkyBattleBg') {\\r\\n\\t\\t\\t$gameSystem.skyBattleBg = args[0];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setSRWSkyBattleParallax1') {\\r\\n\\t\\t\\t$gameSystem.skyBattleParallax1 = args[0];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setSRWDefaultBattleEnv') {\\r\\n\\t\\t\\t$gameSystem.defaultBattleEnv = args[0];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setDefaultBattleEnv') {\\r\\n\\t\\t\\t$gameSystem.defaultBattleEnv = args[0];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setSkyBattleEnv') {\\r\\n\\t\\t\\t$gameSystem.skyBattleEnv = args[0];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setRegionBattleEnv') {\\r\\n\\t\\t\\t$gameSystem.regionBattleEnv[args[0]] = args[1];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setRegionSkyBattleEnv') {\\r\\n\\t\\t\\t$gameSystem.regionSkyBattleEnv[args[0]] = args[1];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'resetRegionAttributes') {\\t\\t\\t\\r\\n\\t\\t\\tif(!$gameSystem.regionAttributes){\\r\\n\\t\\t\\t\\t$gameSystem.regionAttributes = {};\\r\\n\\t\\t\\t}\\t\\r\\n\\t\\t\\tdelete $gameSystem.regionAttributes[args[0] * 1];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'addRegionAttributes') {\\r\\n\\t\\t\\tif(!$gameSystem.regionAttributes){\\r\\n\\t\\t\\t\\t$gameSystem.regionAttributes = {};\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$gameSystem.regionAttributes[args[0] * 1] = {\\r\\n\\t\\t\\t\\tdefense: args[1] * 1,\\r\\n\\t\\t\\t\\tevasion: args[2] * 1,\\r\\n\\t\\t\\t\\thp_regen: args[3] * 1, \\r\\n\\t\\t\\t\\ten_regen: args[4] * 1\\r\\n\\t\\t\\t};\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'addMapHighlight') {\\r\\n\\t\\t\\tif(!$gameSystem.highlightedTiles){\\r\\n\\t\\t\\t\\t$gameSystem.highlightedTiles = [];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$gameSystem.highlightedTiles.push({x: args[0], y: args[1], color: args[2] || \\\"white\\\"});\\r\\n\\t\\t\\t$gameSystem.highlightsRefreshed = true;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'removeMapHighlight') {\\r\\n\\t\\t\\tif($gameSystem.highlightedTiles){\\r\\n\\t\\t\\t\\tvar x = args[0];\\r\\n\\t\\t\\t\\tvar y = args[1];\\r\\n\\t\\t\\t\\tvar tmp = [];\\r\\n\\t\\t\\t\\tfor(var i = 0; i < $gameSystem.highlightedTiles.length; i++){\\r\\n\\t\\t\\t\\t\\tif($gameSystem.highlightedTiles[i].x != x || $gameSystem.highlightedTiles[i].y != y){\\r\\n\\t\\t\\t\\t\\t\\ttmp.push($gameSystem.highlightedTiles);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t$gameSystem.highlightedTiles = tmp;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$gameSystem.highlightsRefreshed = true;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'addMapRegionHighlight') {\\r\\n\\t\\t\\tif(!$gameSystem.regionHighlights){\\r\\n\\t\\t\\t\\t$gameSystem.regionHighlights = {};\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$gameSystem.regionHighlights[args[0]] = args[1] || \\\"white\\\";\\r\\n\\t\\t\\t$gameSystem.highlightsRefreshed = true;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'removeMapRegionHighlight') {\\r\\n\\t\\t\\tdelete $gameSystem.regionHighlights[args[0]];\\r\\n\\t\\t\\t$gameSystem.highlightsRefreshed = true;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setEnemyUpgradeLevel') {\\r\\n\\t\\t\\t$gameSystem.enemyUpgradeLevel = args[0];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setMechUpgradeLevel') {\\r\\n\\t\\t\\tvar mechId = args[0]*1;\\r\\n\\t\\t\\tvar targetLevel = args[1]*1;\\r\\n\\t\\t\\tvar force = args[2]*1;\\r\\n\\t\\t\\tvar mechData = $statCalc.getMechData($dataClasses[mechId], true);\\r\\n\\t\\t\\tif(mechData && mechData.id != -1){\\r\\n\\t\\t\\t\\tvar upgradeLevels = mechData.stats.upgradeLevels;\\r\\n\\t\\t\\t\\tvar targetUpgrades = [\\\"maxHP\\\",\\\"maxEN\\\",\\\"armor\\\",\\\"mobility\\\",\\\"accuracy\\\",\\\"weapons\\\"];\\r\\n\\t\\t\\t\\ttargetUpgrades.forEach(function(upgrade){\\r\\n\\t\\t\\t\\t\\tif(upgradeLevels[upgrade] < targetLevel || force){\\r\\n\\t\\t\\t\\t\\t\\tupgradeLevels[upgrade] = targetLevel;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t});\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$statCalc.storeMechData(mechData);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setPilotRelationship') {\\r\\n\\t\\t\\tvar actorId = parseInt(args[0]);\\r\\n\\t\\t\\tvar otherActorId = parseInt(args[1]);\\r\\n\\t\\t\\tvar effectId = parseInt(args[2]);\\r\\n\\t\\t\\tvar level = parseInt( args[3]);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tvar actor = $gameActors.actor(actorId);\\r\\n\\t\\t\\tif(!actor.SRWStats.pilot.relationships){\\r\\n\\t\\t\\t\\tactor.SRWStats.pilot.relationships = {};\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tactor.SRWStats.pilot.relationships[otherActorId] = {\\r\\n\\t\\t\\t\\tactor: otherActorId,\\r\\n\\t\\t\\t\\teffectId: effectId,\\r\\n\\t\\t\\t\\tlevel: level\\r\\n\\t\\t\\t};\\r\\n\\t\\t\\t$statCalc.storeActorData(actor);\\t\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'addPersuadeOption') {\\r\\n\\t\\t\\t//args[0] = actorId\\r\\n\\t\\t\\t//args[1] = eventId\\r\\n\\t\\t\\t//args[2] = varId\\r\\n\\t\\t\\tif(!$gameSystem.persuadeOptions[args[0]]){\\r\\n\\t\\t\\t\\t$gameSystem.persuadeOptions[args[0]] = {};\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$gameSystem.persuadeOptions[args[0]][args[1]] = args[2];\\r\\n\\t\\t}\\t\\r\\n\\r\\n\\t\\tif (command === 'removePersuadeOption') {\\r\\n\\t\\t\\t//args[0] = actorId\\r\\n\\t\\t\\t//args[1] = eventId\\r\\n\\t\\t\\tif($gameSystem.persuadeOptions[args[0]]){\\r\\n\\t\\t\\t\\tdelete $gameSystem.persuadeOptions[args[0]][args[1]];\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\t\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'deployShips') {\\r\\n\\t\\t\\tvar deployInfo = $gameSystem.getDeployInfo();\\r\\n\\t\\t\\tvar deployList = $gameSystem.getShipDeployList();\\t\\t\\t\\r\\n\\t\\t\\tvar activeDeployList = [];\\r\\n\\t\\t\\tfor(var i = 0; i < deployInfo.shipCount; i++){\\r\\n\\t\\t\\t\\tactiveDeployList.push(deployList[i]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$gameSystem.setActiveShipDeployList(activeDeployList);\\r\\n\\t\\t\\t$gameSystem.deployShips(args[0]);\\t\\t\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'deployAll') {\\r\\n\\t\\t\\tvar deployInfo = $gameSystem.getDeployInfo();\\r\\n\\t\\t\\tvar deployList = $gameSystem.getDeployList();\\r\\n\\t\\t\\tvar activeDeployList = [];\\r\\n\\t\\t\\tfor(var i = 0; i < deployInfo.count; i++){\\r\\n\\t\\t\\t\\tactiveDeployList.push(deployList[i]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$gameSystem.setActiveDeployList(activeDeployList);\\r\\n\\t\\t\\t$gameSystem.deployActors(args[0], \\\"all\\\");\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'deployAllLocked') {\\r\\n\\t\\t\\t$gameSystem.deployActors(args[0], \\\"locked\\\");\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'deployAllUnLocked') {\\r\\n\\t\\t\\t$gameSystem.deployActors(args[0], \\\"unlocked\\\");\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'deployActor') {\\r\\n\\t\\t\\tvar actor_unit = $gameActors.actor(args[0]);\\r\\n\\t\\t\\tvar event = $gameMap.event(args[1]);\\r\\n\\t\\t\\tif(actor_unit && event){\\r\\n\\t\\t\\t\\tvar type;\\r\\n\\t\\t\\t\\tif(event.event().meta.type){\\r\\n\\t\\t\\t\\t\\ttype = event.event().meta.type;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\ttype = \\\"actor\\\";\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tevent.setType(type);\\r\\n\\t\\t\\t\\t$gameSystem.deployActor(actor_unit, event, args[2] * 1, args[3]);\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'deploySlot') {\\r\\n\\t\\t\\tvar slot = args[0];\\r\\n\\t\\t\\tvar deployInfo = $gameSystem.getDeployInfo();\\r\\n\\t\\t\\tvar actor_id = deployInfo.assigned[slot];\\r\\n\\t\\t\\tvar actor_unit = $gameActors.actor(actor_id);\\r\\n\\t\\t\\tvar eventId = -1;\\r\\n\\t\\t\\tvar ctr = 0;\\r\\n\\t\\t\\tvar actorEventCtr = 0;\\r\\n\\t\\t\\tvar events = $gameMap.events();\\r\\n\\t\\t\\twhile(eventId == -1 && ctr < events.length){\\r\\n\\t\\t\\t\\tvar event = events[ctr];\\r\\n\\t\\t\\t\\tif (event.isType() === 'actor'){\\r\\n\\t\\t\\t\\t\\tif(actorEventCtr == slot){\\r\\n\\t\\t\\t\\t\\t\\teventId = event.eventId();\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tactorEventCtr++;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tctr++;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(actor_unit && eventId != -1){\\r\\n\\t\\t\\t\\t$gameSystem.deployActor(actor_unit, $gameMap.event(eventId), args[1], deployInfo.assignedSub[slot]);\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'redeployActor') {\\r\\n\\t\\t\\t$gameSystem.redeployActor(args[0], args[1] * 1);\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'moveEventToPoint') {\\r\\n\\t\\t\\t$gameMap._interpreter.setWaitMode(\\\"move_to_point\\\");\\r\\n\\t\\t\\t$gameSystem.setSrpgWaitMoving(true);\\r\\n\\t\\t\\tvar event = $gameMap.event(args[0]);\\r\\n\\t\\t\\tif(event){\\r\\n\\t\\t\\t\\tvar position = $statCalc.getAdjacentFreeSpace({x: args[1], y: args[2]}, null, null, {x: event.posX(), y: event.posY()});\\r\\n\\t\\t\\t\\tevent.srpgMoveToPoint(position, true, true);\\r\\n\\t\\t\\t\\tif(args[3] * 1){\\r\\n\\t\\t\\t\\t\\t$gamePlayer.locate(event.posX(), event.posY());\\r\\n\\t\\t\\t\\t\\t$gameTemp.followMove = true;\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'moveActorToPoint') {\\r\\n\\t\\t\\t$gameMap._interpreter.setWaitMode(\\\"move_to_point\\\");\\r\\n\\t\\t\\t$gameSystem.setSrpgWaitMoving(true);\\r\\n\\t\\t\\tvar event = $statCalc.getReferenceEvent($gameActors.actor(args[0]));\\r\\n\\t\\t\\tif(event){\\r\\n\\t\\t\\t\\tvar position = $statCalc.getAdjacentFreeSpace({x: args[1], y: args[2]}, null, null, {x: event.posX(), y: event.posY()});\\r\\n\\t\\t\\t\\tevent.srpgMoveToPoint(position, true, true);\\r\\n\\t\\t\\t\\tif(args[3] * 1){\\r\\n\\t\\t\\t\\t\\t$gamePlayer.locate(event.posX(), event.posY());\\r\\n\\t\\t\\t\\t\\t$gameTemp.followMove = true;\\r\\n\\t\\t\\t\\t}\\t\\r\\n\\t\\t\\t}\\t\\t\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'moveEventToEvent') {\\r\\n\\t\\t\\t$gameMap._interpreter.setWaitMode(\\\"move_to_point\\\");\\r\\n\\t\\t\\t$gameSystem.setSrpgWaitMoving(true);\\r\\n\\t\\t\\tvar targetEvent = $gameMap.event(args[1]);\\r\\n\\t\\t\\tvar event = $gameMap.event(args[0]);\\r\\n\\t\\t\\tif(event && targetEvent){\\r\\n\\t\\t\\t\\tvar position = $statCalc.getAdjacentFreeSpace({x: targetEvent.posX(), y: targetEvent.posY()}, null, null, {x: event.posX(), y: event.posY()});\\r\\n\\t\\t\\t\\tevent.srpgMoveToPoint(position, true, true);\\r\\n\\t\\t\\t\\tif(args[2] * 1){\\r\\n\\t\\t\\t\\t\\t$gamePlayer.locate(event.posX(), event.posY());\\r\\n\\t\\t\\t\\t\\t$gameTemp.followMove = true;\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'moveActorToEvent') {\\r\\n\\t\\t\\t$gameMap._interpreter.setWaitMode(\\\"move_to_point\\\");\\r\\n\\t\\t\\t$gameSystem.setSrpgWaitMoving(true);\\r\\n\\t\\t\\tvar targetEvent = $gameMap.event(args[1]);\\r\\n\\t\\t\\tvar event = $statCalc.getReferenceEvent($gameActors.actor(args[0]));\\r\\n\\t\\t\\tif(event && targetEvent){\\r\\n\\t\\t\\t\\tvar position = $statCalc.getAdjacentFreeSpace({x: targetEvent.posX(), y: targetEvent.posY()}, null, null, {x: event.posX(), y: event.posY()});\\r\\n\\t\\t\\t\\tevent.srpgMoveToPoint(position, true, true);\\r\\n\\t\\t\\t\\tif(args[2] * 1){\\r\\n\\t\\t\\t\\t\\t$gamePlayer.locate(event.posX(), event.posY());\\r\\n\\t\\t\\t\\t\\t$gameTemp.followMove = true;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'moveEventToActor') {\\r\\n\\t\\t\\t$gameMap._interpreter.setWaitMode(\\\"move_to_point\\\");\\r\\n\\t\\t\\t$gameSystem.setSrpgWaitMoving(true);\\r\\n\\t\\t\\tvar targetEvent = $statCalc.getReferenceEvent($gameActors.actor(args[1]));\\r\\n\\t\\t\\tvar event = $gameMap.event(args[0]);\\r\\n\\t\\t\\tif(event && targetEvent){\\r\\n\\t\\t\\t\\tvar position = $statCalc.getAdjacentFreeSpace({x: targetEvent.posX(), y: targetEvent.posY()}, null, null, {x: event.posX(), y: event.posY()});\\r\\n\\t\\t\\t\\tevent.srpgMoveToPoint(position, true, true);\\r\\n\\t\\t\\t\\tif(args[2] * 1){\\r\\n\\t\\t\\t\\t\\t$gamePlayer.locate(event.posX(), event.posY());\\r\\n\\t\\t\\t\\t\\t$gameTemp.followMove = true;\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'moveActorToActor') {\\r\\n\\t\\t\\t$gameMap._interpreter.setWaitMode(\\\"move_to_point\\\");\\r\\n\\t\\t\\t$gameSystem.setSrpgWaitMoving(true);\\r\\n\\t\\t\\tvar targetEvent = $statCalc.getReferenceEvent($gameActors.actor(args[1]));\\r\\n\\t\\t\\tvar event = $statCalc.getReferenceEvent($gameActors.actor(args[0]));\\r\\n\\t\\t\\tif(event && targetEvent){\\r\\n\\t\\t\\t\\tvar position = $statCalc.getAdjacentFreeSpace({x: targetEvent.posX(), y: targetEvent.posY()}, null, null, {x: event.posX(), y: event.posY()});\\r\\n\\t\\t\\t\\tevent.srpgMoveToPoint(position, true, true);\\r\\n\\t\\t\\t\\tif(args[2] * 1){\\r\\n\\t\\t\\t\\t\\t$gamePlayer.locate(event.posX(), event.posY());\\r\\n\\t\\t\\t\\t\\t$gameTemp.followMove = true;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setEventFlying') {\\r\\n\\t\\t\\tvar actor = $gameSystem.EventToUnit(args[0])[1];\\r\\n\\t\\t\\tif($statCalc.canFly(actor)){\\r\\n\\t\\t\\t\\t$statCalc.setFlying(actor, true);\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setEventLanded') {\\r\\n\\t\\t\\tvar actor = $gameSystem.EventToUnit(args[0])[1];\\t\\t\\r\\n\\t\\t\\t$statCalc.setFlying(actor, false);\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'enableFaction') {\\r\\n\\t\\t\\t$gameSystem.enableFaction(args[0]);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'disableFaction') {\\r\\n\\t\\t\\t$gameSystem.disableFaction(args[0]);\\r\\n\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setFactionAggro') {\\r\\n\\t\\t\\t$gameSystem.setFactionAggro(args[0], JSON.parse(args[1]));\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'clearFactionAggro') {\\r\\n\\t\\t\\t$gameSystem.clearFactionAggro(args[0]);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'transformEvent') {\\r\\n\\t\\t\\tvar actor = $gameSystem.EventToUnit(args[0])[1];\\r\\n\\t\\t\\t/*if(actor.isSubTwin){\\r\\n\\t\\t\\t\\tvar main = $statCalc.getMainTwin(actor);\\r\\n\\t\\t\\t\\t$statCalc.swap(main, true);\\r\\n\\t\\t\\t}*/\\r\\n\\t\\t\\t$statCalc.transform(actor, args[1], true);\\r\\n\\t\\t\\tvar se = {};\\r\\n\\t\\t\\tse.name = 'SRWTransform';\\r\\n\\t\\t\\tse.pan = 0;\\r\\n\\t\\t\\tse.pitch = 100;\\r\\n\\t\\t\\tse.volume = 80;\\r\\n\\t\\t\\tAudioManager.playSe(se);\\r\\n\\t\\t}\\t\\r\\n\\r\\n\\t\\tif (command === 'combineEvent') {\\r\\n\\t\\t\\tvar actor = $gameSystem.EventToUnit(args[0])[1];\\r\\n\\t\\t\\t$statCalc.combine(actor, true);\\r\\n\\t\\t\\tvar se = {};\\r\\n\\t\\t\\tse.name = 'SRWTransform';\\r\\n\\t\\t\\tse.pan = 0;\\r\\n\\t\\t\\tse.pitch = 100;\\r\\n\\t\\t\\tse.volume = 80;\\r\\n\\t\\t\\tAudioManager.playSe(se);\\r\\n\\t\\t}\\t\\r\\n\\r\\n\\t\\tif (command === 'splitEvent') {\\r\\n\\t\\t\\tvar actor = $gameSystem.EventToUnit(args[0])[1];\\r\\n\\t\\t\\t$statCalc.split(actor, true);\\r\\n\\t\\t\\tvar se = {};\\r\\n\\t\\t\\tse.name = 'SRWTransform';\\r\\n\\t\\t\\tse.pan = 0;\\r\\n\\t\\t\\tse.pitch = 100;\\r\\n\\t\\t\\tse.volume = 80;\\r\\n\\t\\t\\tAudioManager.playSe(se);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'transformActor') {\\r\\n\\t\\t\\tvar actor = $gameActors.actor(args[0]);\\r\\n\\t\\t\\t/*if(actor.isSubTwin){\\r\\n\\t\\t\\t\\tvar main = $statCalc.getMainTwin(actor);\\r\\n\\t\\t\\t\\t$statCalc.swap(main, true);\\r\\n\\t\\t\\t}*/\\r\\n\\t\\t\\t$statCalc.transform(actor, args[1], true, args[2]);\\r\\n\\t\\t\\tvar se = {};\\r\\n\\t\\t\\tse.name = 'SRWTransform';\\r\\n\\t\\t\\tse.pan = 0;\\r\\n\\t\\t\\tse.pitch = 100;\\r\\n\\t\\t\\tse.volume = 80;\\r\\n\\t\\t\\tAudioManager.playSe(se);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (command === 'transformActorDirect') {\\r\\n\\t\\t\\tvar actor = $gameActors.actor(args[0]);\\r\\n\\t\\t\\t/*if(actor.isSubTwin){\\r\\n\\t\\t\\t\\tvar main = $statCalc.getMainTwin(actor);\\r\\n\\t\\t\\t\\t$statCalc.swap(main, true);\\r\\n\\t\\t\\t}*/\\r\\n\\t\\t\\t$statCalc.transform(actor, 0, true, args[1]);\\r\\n\\t\\t\\tvar se = {};\\r\\n\\t\\t\\tse.name = 'SRWTransform';\\r\\n\\t\\t\\tse.pan = 0;\\r\\n\\t\\t\\tse.pitch = 100;\\r\\n\\t\\t\\tse.volume = 80;\\r\\n\\t\\t\\tAudioManager.playSe(se);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (command === 'combineActor') {\\r\\n\\t\\t\\tvar actor = $gameActors.actor(args[0]);\\r\\n\\t\\t\\t$statCalc.combine(actor, true);\\r\\n\\t\\t\\tvar se = {};\\r\\n\\t\\t\\tse.name = 'SRWTransform';\\r\\n\\t\\t\\tse.pan = 0;\\r\\n\\t\\t\\tse.pitch = 100;\\r\\n\\t\\t\\tse.volume = 80;\\r\\n\\t\\t\\tAudioManager.playSe(se);\\r\\n\\t\\t}\\t\\r\\n\\r\\n\\t\\tif (command === 'splitActor') {\\r\\n\\t\\t\\tvar actor = $gameActors.actor(args[0]);\\r\\n\\t\\t\\t$statCalc.split(actor, true);\\r\\n\\t\\t\\tvar se = {};\\r\\n\\t\\t\\tse.name = 'SRWTransform';\\r\\n\\t\\t\\tse.pan = 0;\\r\\n\\t\\t\\tse.pitch = 100;\\r\\n\\t\\t\\tse.volume = 80;\\r\\n\\t\\t\\tAudioManager.playSe(se);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'separateActor') {\\r\\n\\t\\t\\tvar actor = $gameActors.actor(args[0]);\\r\\n\\t\\t\\tif(actor.isSubTwin){\\r\\n\\t\\t\\t\\tactor = $statCalc.getMainTwin(actor);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(actor.subTwin || actor.isSubTwin){\\r\\n\\t\\t\\t\\t$statCalc.separate(actor, true);\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'makeActorMainTwin') {\\r\\n\\t\\t\\tvar actor = $gameActors.actor(args[0]);\\r\\n\\t\\t\\tif(actor.isSubTwin){\\r\\n\\t\\t\\t\\tactor = $statCalc.getMainTwin(actor);\\r\\n\\t\\t\\t\\t$statCalc.swap(actor, true);\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'preventActorDeathQuote') {\\r\\n\\t\\t\\tif(!$gameTemp.preventedDeathQuotes){\\r\\n\\t\\t\\t\\t$gameTemp.preventedDeathQuotes = {};\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$gameTemp.preventedDeathQuotes[args[0]] = true;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setSaveDisplayName') {\\t\\t\\t\\r\\n\\t\\t\\t$gameSystem.saveDisplayName = (args[0] || \\\"\\\").replace(/\\\\_/ig, \\\" \\\");\\r\\n\\t\\t}\\t\\r\\n\\r\\n\\t\\tif (command === 'setStageTextId') {\\t\\t\\t\\r\\n\\t\\t\\t$gameSystem.stageTextId = args[0];\\r\\n\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setEventWill') {\\t\\r\\n\\t\\t\\tvar actor = $gameSystem.EventToUnit(args[0])[1];\\r\\n\\t\\t\\t$statCalc.setWill(actor, args[1] * 1);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setActorWill') {\\t\\r\\n\\t\\t\\tvar actor = $gameActors.actor(args[0]);\\r\\n\\t\\t\\t$statCalc.setWill(actor, args[1] * 1);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'makeActorAI') {\\t\\r\\n\\t\\t\\tvar actor = $gameActors.actor(args[0]);\\r\\n\\t\\t\\t$statCalc.setIsAI(actor, true);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'makeActorControllable') {\\t\\r\\n\\t\\t\\tvar actor = $gameActors.actor(args[0]);\\r\\n\\t\\t\\t$statCalc.setIsAI(actor, false);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setActorEssential') {\\r\\n\\t\\t\\tvar actor = $gameActors.actor(args[0]);\\r\\n\\t\\t\\t$statCalc.setEssential(actor, true);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setActorNonEssential') {\\r\\n\\t\\t\\tvar actor = $gameActors.actor(args[0]);\\r\\n\\t\\t\\t$statCalc.setEssential(actor, false);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'unlockMechWeapon') {\\t\\t\\t\\r\\n\\t\\t\\t$statCalc.setWeaponUnlocked(args[0], args[1]);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'lockMechWeapon') {\\r\\n\\t\\t\\t$statCalc.setWeaponLocked(args[0], args[1]);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setUnlockedUpgradeLevel') {\\r\\n\\t\\t\\tvar tmp = parseInt(args[0]);\\r\\n\\t\\t\\tif(!isNaN(tmp)){\\r\\n\\t\\t\\t\\t$gameSystem.unlockedUpgradeLevel = tmp;\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setRequiredFUBLevel') {\\r\\n\\t\\t\\tvar tmp = parseInt(args[0]);\\r\\n\\t\\t\\tif(!isNaN(tmp)){\\r\\n\\t\\t\\t\\t$gameSystem.requiredFUBLevel = tmp;\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setEventCounterAction') {\\t\\r\\n\\t\\t\\tvar actor = $gameSystem.EventToUnit(args[0])[1];\\r\\n\\t\\t\\tactor.counterBehavior = args[1];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setEventAttackAction') {\\t\\r\\n\\t\\t\\tvar actor = $gameSystem.EventToUnit(args[0])[1];\\r\\n\\t\\t\\tactor.attackBehavior = args[1];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setEventBattleMode') {\\t\\r\\n\\t\\t\\tvar battlerArray = $gameSystem.EventToUnit(args[0]);\\r\\n\\t\\t\\tif (battlerArray && (battlerArray[0] === 'actor' || battlerArray[0] === 'enemy')) {\\r\\n\\t\\t\\t\\tbattlerArray[1].setBattleMode(args[1], true);\\t\\t\\t\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(battlerArray[0] === 'enemy'){\\r\\n\\t\\t\\t\\tif(battlerArray[1].squadId != -1){\\r\\n\\t\\t\\t\\t\\tthis.setSquadMode(squadId, args[1]);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\t\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t};\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'hidePilotAbility') {\\t\\r\\n\\t\\t\\t$gameSystem.setPilotAbilityStatus(args[0], args[1], \\\"hidden\\\");\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'lockPilotAbility') {\\t\\r\\n\\t\\t\\t$gameSystem.setPilotAbilityStatus(args[0], args[1], \\\"locked\\\");\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'unlockPilotAbility') {\\t\\r\\n\\t\\t\\t$gameSystem.setPilotAbilityStatus(args[0], args[1], \\\"\\\");\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'hideMechAbility') {\\t\\r\\n\\t\\t\\t$gameSystem.setMechAbilityStatus(args[0], args[1], \\\"hidden\\\");\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'lockMechAbility') {\\t\\r\\n\\t\\t\\t$gameSystem.setMechAbilityStatus(args[0], args[1], \\\"locked\\\");\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'unlockMechAbility') {\\t\\r\\n\\t\\t\\t$gameSystem.setMechAbilityStatus(args[0], args[1], \\\"\\\");\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'lockTransformation') {\\t\\r\\n\\t\\t\\t$gameSystem.lockTransformation(args[0], args[1]);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'lockAllTransformations') {\\t\\r\\n\\t\\t\\t$gameSystem.lockAllTransformations();\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'unlockTransformation') {\\t\\r\\n\\t\\t\\t$gameSystem.unlockTransformation(args[0], args[1]);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'unlockAllTransformations') {\\t\\r\\n\\t\\t\\t$gameSystem.unlockAllTransformations();\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setFaceAlias') {\\t\\r\\n\\t\\t\\tif(!$gameSystem.faceAliases){\\r\\n\\t\\t\\t\\t$gameSystem.faceAliases = {};\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$gameSystem.faceAliases[args[0]] = args[1];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setCharacterIndexAlias') {\\t\\r\\n\\t\\t\\tif(!$gameSystem.characterIdexAliases){\\r\\n\\t\\t\\t\\t$gameSystem.characterIdexAliases = {};\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$gameSystem.characterIdexAliases[args[0]] = args[1];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setPilotAbilityUpgrade') {\\t\\r\\n\\t\\t\\t$pilotAbilityManager.setUpgrade(args[0], args[1]);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'setMechAbilityUpgrade') {\\t\\r\\n\\t\\t\\t$mechAbilityManager.setUpgrade(args[0], args[1]);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command == 'showTargetingReticule'){\\t\\t\\t\\r\\n\\t\\t\\tvar eventIdSource;\\r\\n\\t\\t\\tvar parts = args[0].match(/\\\\actor\\\\:(.*)/);\\t\\r\\n\\t\\t\\tif(parts && parts.length > 1){\\r\\n\\t\\t\\t\\teventIdSource = $gameSystem.ActorToEvent(parts[1]);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\teventIdSource = args[0];\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tvar eventIdTarget;\\r\\n\\t\\t\\tvar parts = args[1].match(/\\\\actor\\\\:(.*)/);\\t\\r\\n\\t\\t\\tif(parts && parts.length > 1){\\r\\n\\t\\t\\t\\teventIdTarget = $gameSystem.ActorToEvent(parts[1]);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\teventIdTarget = args[1];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tvar actionArray = $gameSystem.EventToUnit(eventIdSource);\\r\\n\\t\\t\\tvar targetArray = $gameSystem.EventToUnit(eventIdTarget);\\r\\n\\t\\t\\tif(actionArray && targetArray){\\r\\n\\t\\t\\t\\t$gameTemp.reticuleInfo = {\\r\\n\\t\\t\\t\\t\\tactor: actionArray[1],\\r\\n\\t\\t\\t\\t\\ttargetActor: targetArray[1]\\r\\n\\t\\t\\t\\t};\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'clearTile') {\\r\\n\\t\\t\\tvar position = {x: args[0], y: args[1]};\\r\\n\\t\\t\\tvar actor = $statCalc.activeUnitAtPosition(position);\\r\\n\\t\\t\\tif(actor){\\r\\n\\t\\t\\t\\tvar newPosition = $statCalc.getAdjacentFreeSpace(position);\\r\\n\\t\\t\\t\\tvar event = $statCalc.getReferenceEvent(actor);\\r\\n\\t\\t\\t\\tvar actorId = -1;\\r\\n\\t\\t\\t\\tif(actor.isActor()){\\r\\n\\t\\t\\t\\t\\tactorId = actor.actorId();\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(event.eventId() != args[2] && actorId != args[3]){\\r\\n\\t\\t\\t\\t\\tevent.locate(newPosition.x, newPosition.y);\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tfunction clearAdjacentToTile(position, includeDiagonal){\\r\\n\\t\\t\\tvar positions  = [];\\r\\n\\t\\t\\tpositions.push({position: {x: position.x - 1, y: position.y}, biasPosition:{x: position.x - 2, y: position.y}});\\r\\n\\t\\t\\tpositions.push({position: {x: position.x + 1, y: position.y}, biasPosition:{x: position.x + 2, y: position.y}});\\r\\n\\t\\t\\tpositions.push({position: {x: position.x, y: position.y + 1}, biasPosition:{x: position.x, y: position.y + 2}});\\r\\n\\t\\t\\tpositions.push({position: {x: position.x, y: position.y - 1}, biasPosition:{x: position.x, y: position.y - 2}});\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif(includeDiagonal){\\r\\n\\t\\t\\t\\tpositions.push({position: {x: position.x - 1, y: position.y - 1}, biasPosition:{x: position.x - 2, y: position.y - 2}});\\r\\n\\t\\t\\t\\tpositions.push({position: {x: position.x + 1, y: position.y + 1}, biasPosition:{x: position.x + 2, y: position.y + 2}});\\r\\n\\t\\t\\t\\tpositions.push({position: {x: position.x - 1, y: position.y + 1}, biasPosition:{x: position.x - 2, y: position.y + 2}});\\r\\n\\t\\t\\t\\tpositions.push({position: {x: position.x + 1, y: position.y - 1}, biasPosition:{x: position.x + 2, y: position.y - 2}});\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tvar usedPositions = {};\\r\\n\\t\\t\\tpositions.forEach(function(currentInfo){\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tvar actor = $statCalc.activeUnitAtPosition(currentInfo.position);\\r\\n\\t\\t\\t\\tif(actor){\\r\\n\\t\\t\\t\\t\\tvar newPosition = $statCalc.getAdjacentFreeSpace(currentInfo.position, null, null, currentInfo.biasPosition, true, usedPositions);\\r\\n\\t\\t\\t\\t\\tif(!usedPositions[newPosition.x]){\\r\\n\\t\\t\\t\\t\\t\\tusedPositions[newPosition.x] = {};\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tif(!usedPositions[newPosition.x][newPosition.y]){\\r\\n\\t\\t\\t\\t\\t\\tusedPositions[newPosition.x][newPosition.y] = true;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tvar event = $statCalc.getReferenceEvent(actor);\\r\\n\\t\\t\\t\\t\\tvar actorId = -1;\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tevent.locate(newPosition.x, newPosition.y);\\t\\t\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t});\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'clearAdjacentToTile') {\\r\\n\\t\\t\\tclearAdjacentToTile({x: args[0] * 1, y: args[1] * 1}, args[2] * 1);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'clearAdjacentToEvent') {\\r\\n\\t\\t\\tvar event = $gameMap.event(args[0]);\\r\\n\\t\\t\\tif(event){\\r\\n\\t\\t\\t\\tclearAdjacentToTile({x: event.posX(), y:  event.posY()}, args[1] * 1);\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (command === 'clearAdjacentToActor') {\\r\\n\\t\\t\\tvar event = $statCalc.getReferenceEvent($gameActors.actor(args[0]));\\r\\n\\t\\t\\tif(event){\\r\\n\\t\\t\\t\\tclearAdjacentToTile({x: event.posX(), y:  event.posY()}, args[1] * 1);\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\tif (command === 'stopSkipping') {\\r\\n\\t\\t\\t//exists purely to manually ensure A+Start skipping stops at the point the command is called.\\r\\n\\t\\t}\\r\\n    };\\t\\t\\r\\n//====================================================================\\r\\n// ●Game_Temp\\r\\n//====================================================================\\r\\n    //初期化処理\\r\\n    var _SRPG_Game_Temp_initialize = Game_Temp.prototype.initialize;\\r\\n    Game_Temp.prototype.initialize = function() {\\r\\n\\t\\t_SRPG_Game_Temp_initialize.call(this);\\r\\n\\t\\tthis._MoveTable = [];\\r\\n\\t\\tthis._MoveList = [];\\r\\n\\t\\tthis._RangeTable = [];\\r\\n\\t\\tthis._RangeList = [];\\r\\n\\t\\tthis._ResetMoveList = false;\\r\\n\\t\\tthis._SrpgDistance = 0;\\r\\n\\t\\tthis._SrpgSpecialRange = true;\\r\\n\\t\\tthis._ActiveEvent = null;\\r\\n\\t\\tthis._TargetEvent = null;\\r\\n\\t\\tthis._OriginalPos = [];\\r\\n\\t\\tthis._SrpgEventList = [];\\r\\n\\t\\tthis._autoMoveDestinationValid = false;\\r\\n\\t\\tthis._autoMoveDestinationX = -1;\\r\\n\\t\\tthis._autoMoveDestinationY = -1;\\r\\n\\t\\tthis._srpgLoadFlag = false;\\r\\n\\t\\tthis._srpgActorEquipFlag = false;\\r\\n\\t\\tthis._SrpgTurnEndFlag = false;\\r\\n\\t\\tthis._srpgBestSearchFlag = false;\\r\\n\\t\\tthis._srpgBestSearchRoute = [null, []];\\r\\n\\t\\tthis._srpgPriorityTarget = null;\\r\\n    };\\r\\n\\t\\r\\n\\tGame_Temp.prototype.killMenu = function(id) {\\r\\n\\t\\tif(!this.killMenus){\\r\\n\\t\\t\\tthis.killMenus = {};\\r\\n\\t\\t}\\r\\n\\t\\tthis.killMenus[id] = true;\\r\\n\\t}\\r\\n\\t\\r\\n\\tDataManager.loadGameWithoutRescue = function(savefileId) {\\r\\n\\t\\tif (this.isThisGameFile(savefileId)) {\\r\\n\\t\\t\\tvar json = StorageManager.load(savefileId);\\r\\n\\t\\t\\tthis.createGameObjects();\\r\\n\\t\\t\\tthis.extractSaveContents(JsonEx.parse(json));\\r\\n\\t\\t\\tthis._lastAccessedId = savefileId;\\r\\n\\t\\t\\t//$gameSystem.setSrpgActors();\\r\\n\\t\\t\\t//$gameSystem.setSrpgEnemys();\\r\\n\\t\\t\\tif($gameSystem.isIntermission()){\\r\\n\\t\\t\\t\\t$gameSystem.startIntermission();\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t$statCalc.softRefreshUnits();\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\t\\r\\n    //移動範囲と移動経路を記録する配列変数を返す\\r\\n    Game_Temp.prototype.MoveTable = function(x, y) {\\r\\n        return this._MoveTable[x][y];\\r\\n    };\\r\\n\\r\\n    //移動範囲を設定する\\r\\n    Game_Temp.prototype.setMoveTable = function(x, y, move, route) {\\r\\n        this._MoveTable[x][y] = [move, route];\\r\\n    };\\r\\n\\r\\n    //攻撃射程と計算経路を記録する配列変数を返す\\r\\n    Game_Temp.prototype.RangeTable = function(x, y) {\\r\\n        return this._RangeTable[x][y];\\r\\n    };\\r\\n\\r\\n    //攻撃射程を設定する\\r\\n    Game_Temp.prototype.setRangeTable = function(x, y, move, route) {\\r\\n        this._RangeTable[x][y] = [move, route];\\r\\n    };\\r\\n\\r\\n    //移動可能な座標のリストを返す(移動範囲表示で使用)\\r\\n    Game_Temp.prototype.moveList = function() {\\r\\n        return this._MoveList;\\r\\n    };\\r\\n\\r\\n    //移動可能な座標のリストに追加する\\r\\n    Game_Temp.prototype.pushMoveList = function(xy) {\\r\\n        this._MoveList.push(xy);\\r\\n    };\\r\\n\\r\\n    //座標リストにデータが入っているか返す\\r\\n    Game_Temp.prototype.isMoveListValid = function() {\\r\\n        return this._MoveList.length > 0;\\r\\n    };\\r\\n\\r\\n    //攻撃可能な座標のリストを返す(攻撃射程表示で使用)\\r\\n    Game_Temp.prototype.rangeList = function() {\\r\\n        return this._RangeList;\\r\\n    };\\r\\n\\r\\n    //攻撃可能な座標のリストに追加する\\r\\n    Game_Temp.prototype.pushRangeList = function(xy) {\\r\\n        this._RangeList.push(xy);\\r\\n    };\\r\\n\\r\\n    //移動範囲の配列に射程範囲の配列を結合する\\r\\n    Game_Temp.prototype.pushRangeListToMoveList = function(array) {\\r\\n        Array.prototype.push.apply(this._MoveList, this._RangeList);\\r\\n    };\\r\\n\\r\\n    //射程範囲から最低射程を除く\\r\\n    Game_Temp.prototype.minRangeAdapt = function(oriX, oriY, minRange) {\\r\\n        var newList = [];\\r\\n        for (var i = 0; i < this._RangeList.length; i++) {\\r\\n            var x = this._RangeList[i][0];\\r\\n            var y = this._RangeList[i][1];\\r\\n            var dis = Math.abs(x - oriX) + Math.abs(y - oriY);\\r\\n            if (dis >= minRange) {\\r\\n                newList.push(this._RangeList[i]);\\r\\n            }\\r\\n        }\\r\\n        this._RangeList = [];\\r\\n        this._RangeList = newList;\\r\\n    };\\r\\n\\r\\n    //移動範囲を初期化する\\r\\n    Game_Temp.prototype.clearMoveTable = function() {\\r\\n\\t\\t$gameTemp.validTiles = {};\\r\\n\\t\\t$gameSystem.highlightedTiles = [];\\r\\n\\t\\t$gameSystem.highlightsRefreshed = true;\\r\\n\\t\\t$gameTemp.disableHighlightGlow = false;\\r\\n        this._MoveTable = [];\\r\\n        this._MoveList = [];\\r\\n        for (var i = 0; i < $dataMap.width; i++) {\\r\\n          var vartical = [];\\r\\n          for (var j = 0; j < $dataMap.height; j++) {\\r\\n            vartical[j] = [-1, []];\\r\\n          }\\r\\n          this._MoveTable[i] = vartical;\\r\\n        }\\r\\n        this._RangeTable = [];\\r\\n        this._RangeList = [];\\r\\n        for (var i = 0; i < $dataMap.width; i++) {\\r\\n          var vartical = [];\\r\\n          for (var j = 0; j < $dataMap.height; j++) {\\r\\n            vartical[j] = [-1, []];\\r\\n          }\\r\\n          this._RangeTable[i] = vartical;\\r\\n        }\\r\\n    };\\r\\n\\r\\n    //移動範囲のスプライト消去のフラグを返す\\r\\n    Game_Temp.prototype.resetMoveList = function() {\\r\\n        return this._ResetMoveList;\\r\\n    };\\r\\n\\r\\n    //移動範囲のスプライト消去のフラグを設定する\\r\\n    Game_Temp.prototype.setResetMoveList = function(flag) {\\r\\n        this._ResetMoveList = flag;\\r\\n    };\\r\\n\\r\\n    //自身の直下は常に歩けるようにする\\r\\n    Game_Temp.prototype.initialMoveTable = function(oriX, oriY, oriMove) {\\r\\n        this.setMoveTable(oriX, oriY, oriMove, [0]);\\r\\n        this.pushMoveList([oriX, oriY, false]);\\r\\n    }\\r\\n\\r\\n    //自身の直下は常に攻撃射程に含める\\r\\n    Game_Temp.prototype.initialRangeTable = function(oriX, oriY, oriMove) {\\r\\n        this.setRangeTable(oriX, oriY, oriMove, [0]);\\r\\n        this.pushRangeList([oriX, oriY, true]);\\r\\n    }\\r\\n\\r\\n    //攻撃ユニットと対象の距離を返す\\r\\n    Game_Temp.prototype.SrpgDistance = function() {\\r\\n        return this._SrpgDistance;\\r\\n    };\\r\\n\\r\\n    //攻撃ユニットと対象の距離を設定する\\r\\n    Game_Temp.prototype.setSrpgDistance = function(val) {\\r\\n        this._SrpgDistance = val;\\r\\n    };\\r\\n\\r\\n    //攻撃ユニットと対象が特殊射程内にいるかを返す\\r\\n    Game_Temp.prototype.SrpgSpecialRange = function() {\\r\\n        return this._SrpgSpecialRange;\\r\\n    };\\r\\n\\r\\n    //攻撃ユニットと対象が特殊射程内にいるかを設定する\\r\\n    Game_Temp.prototype.setSrpgSpecialRange = function(val) {\\r\\n        this._SrpgSpecialRange = val;\\r\\n    };\\r\\n\\r\\n    //アクティブイベントの設定\\r\\n    Game_Temp.prototype.activeEvent = function() {\\r\\n        return this._ActiveEvent;\\r\\n    };\\r\\n\\r\\n    Game_Temp.prototype.setActiveEvent = function(event) {\\r\\n        this._ActiveEvent = event;\\r\\n        $gameVariables.setValue(_activeEventID, event.eventId());\\r\\n\\t\\tvar actor = $gameSystem.EventToUnit(event.eventId())[1];\\r\\n\\t\\tif(actor.isActor()){\\r\\n\\t\\t\\t$gameVariables.setValue(_currentActorId, actor.actorId());\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t$gameVariables.setValue(_currentEnemyId, actor.enemyId());\\r\\n\\t\\t}\\t\\t\\r\\n    };\\r\\n\\r\\n    Game_Temp.prototype.clearActiveEvent = function() {\\r\\n        this._ActiveEvent = null;\\r\\n        $gameVariables.setValue(_activeEventID, 0);\\r\\n    };\\r\\n\\r\\n    //行動対象となるユニットの設定\\r\\n    Game_Temp.prototype.targetEvent = function() {\\r\\n        return this._TargetEvent;\\r\\n    };\\r\\n\\r\\n    Game_Temp.prototype.setTargetEvent = function(event) {\\r\\n        this._TargetEvent = event;\\r\\n        if (this._TargetEvent) {\\r\\n            $gameVariables.setValue(_targetEventID, event.eventId());\\r\\n\\t\\t\\tvar actor = $gameSystem.EventToUnit(event.eventId())[1];\\r\\n\\t\\t\\tif(actor.isActor()){\\r\\n\\t\\t\\t\\t$gameVariables.setValue(_currentActorId, actor.actorId());\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t$gameVariables.setValue(_currentEnemyId, actor.enemyId());\\r\\n\\t\\t\\t}\\t\\r\\n        }\\r\\n    };\\r\\n\\r\\n    Game_Temp.prototype.clearTargetEvent = function() {\\r\\n        this._TargetEvent = null;\\r\\n        $gameVariables.setValue(_targetEventID, 0);\\r\\n    };\\r\\n\\r\\n    //アクティブイベントの座標を返す\\r\\n    Game_Temp.prototype.originalPos = function() {\\r\\n        return this._OriginalPos;\\r\\n    };\\r\\n\\r\\n    //アクティブイベントの座標を記録する\\r\\n    Game_Temp.prototype.reserveOriginalPos = function(x, y) {\\r\\n        this._OriginalPos = [x, y];\\r\\n    };\\r\\n\\r\\n    //実行待ちイベントリストを確認する\\r\\n    Game_Temp.prototype.isSrpgEventList = function() {\\r\\n        return this._SrpgEventList.length > 0;\\r\\n    };\\r\\n\\r\\n    //実行待ちイベントリストを追加する\\r\\n    Game_Temp.prototype.pushSrpgEventList = function(event) {\\r\\n        this._SrpgEventList.push(event);\\r\\n    };\\r\\n\\r\\n    //実行待ちイベントリストの先頭を取得し、前に詰める\\r\\n    Game_Temp.prototype.shiftSrpgEventList = function() {\\r\\n        var event = this._SrpgEventList[0];\\r\\n        this._SrpgEventList.shift();\\r\\n        return event;\\r\\n    };\\r\\n\\r\\n    //プレイヤーの自動移動フラグを返す\\r\\n    Game_Temp.prototype.isAutoMoveDestinationValid = function() {\\r\\n        return this._autoMoveDestinationValid;\\r\\n    };\\r\\n\\r\\n    //プレイヤーの自動移動フラグを設定する\\r\\n    Game_Temp.prototype.setAutoMoveDestinationValid = function(val) {\\r\\n        this._autoMoveDestinationValid = val;\\r\\n    };\\r\\n\\r\\n    //プレイヤーの自動移動先を返す(X)\\r\\n    Game_Temp.prototype.autoMoveDestinationX = function() {\\r\\n        return this._autoMoveDestinationX;\\r\\n    };\\r\\n\\r\\n    //プレイヤーの自動移動先を返す(Y)\\r\\n    Game_Temp.prototype.autoMoveDestinationY = function() {\\r\\n        return this._autoMoveDestinationY;\\r\\n    };\\r\\n\\r\\n    //プレイヤーの自動移動先を設定する\\r\\n    Game_Temp.prototype.setAutoMoveDestination = function(x, y) {\\r\\n        this._autoMoveDestinationX = x;\\r\\n        this._autoMoveDestinationY = y;\\r\\n    };\\r\\n\\r\\n    //戦闘中にロードしたフラグを返す\\r\\n    Game_Temp.prototype.isSrpgLoadFlag = function() {\\r\\n        return this._srpgLoadFlag;\\r\\n    };\\r\\n\\r\\n    //戦闘中にロードしたフラグを設定する\\r\\n    Game_Temp.prototype.setSrpgLoadFlag = function(flag) {\\r\\n        this._srpgLoadFlag = flag;\\r\\n    };\\r\\n\\r\\n    //ターン終了フラグを返す\\r\\n    Game_Temp.prototype.isTurnEndFlag = function() {\\r\\n        return this._SrpgTurnEndFlag;\\r\\n    };\\r\\n\\r\\n    //ターン終了フラグを変更する\\r\\n    Game_Temp.prototype.setTurnEndFlag = function(flag) {\\r\\n        this._SrpgTurnEndFlag = flag;\\r\\n    };\\r\\n\\r\\n    //オート戦闘フラグを返す\\r\\n    Game_Temp.prototype.isAutoBattleFlag = function() {\\r\\n        return this._SrpgAutoBattleFlag;\\r\\n    };\\r\\n\\r\\n    //オート戦闘フラグを変更する\\r\\n    Game_Temp.prototype.setAutoBattleFlag = function(flag) {\\r\\n        this._SrpgAutoBattleFlag = flag;\\r\\n    };\\r\\n\\r\\n    //アクターコマンドから装備を呼び出したフラグを返す\\r\\n    Game_Temp.prototype.isSrpgActorEquipFlag = function() {\\r\\n        return this._srpgActorEquipFlag;\\r\\n    };\\r\\n\\r\\n    //アクターコマンドから装備を呼び出したフラグを設定する\\r\\n    Game_Temp.prototype.setSrpgActorEquipFlag = function(flag) {\\r\\n        this._srpgActorEquipFlag = flag;\\r\\n    };\\r\\n\\r\\n    //探索用移動範囲計算時の実行フラグを返す\\r\\n    Game_Temp.prototype.isSrpgBestSearchFlag = function() {\\r\\n        return this._srpgBestSearchFlag;\\r\\n    };\\r\\n\\r\\n    //探索用移動範囲計算時の実行フラグを設定する\\r\\n    Game_Temp.prototype.setSrpgBestSearchFlag = function(flag) {\\r\\n        this._srpgBestSearchFlag = flag;\\r\\n    };\\r\\n\\r\\n    //探索用移動範囲計算時の最適ルートを返す\\r\\n    Game_Temp.prototype.isSrpgBestSearchRoute = function() {\\r\\n        return this._srpgBestSearchRoute;\\r\\n    };\\r\\n\\r\\n    //探索用移動範囲計算時の最適ルートを設定する\\r\\n    Game_Temp.prototype.setSrpgBestSearchRoute = function(array) {\\r\\n        this._srpgBestSearchRoute = array;\\r\\n    };\\r\\n\\r\\n    //優先ターゲットを返す\\r\\n    Game_Temp.prototype.isSrpgPriorityTarget = function() {\\r\\n        return this._srpgPriorityTarget;\\r\\n    };\\r\\n\\r\\n    //優先ターゲットを設定する\\r\\n    Game_Temp.prototype.setSrpgPriorityTarget = function(event) {\\r\\n        this._srpgPriorityTarget = event;\\r\\n    };\\r\\n\\t\\r\\n\\tGame_Temp.prototype.isMapTarget = function(eventId) {\\r\\n\\t\\tvar result = false;\\r\\n\\t\\tif(this.currentMapTargets){\\r\\n\\t\\t\\tfor(var i = 0; i < this.currentMapTargets.length; i++){\\r\\n\\t\\t\\t\\tif($statCalc.getReferenceEvent(this.currentMapTargets[i]).eventId() == eventId){\\r\\n\\t\\t\\t\\t\\tresult = true;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn result;\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// ●Game_System\\r\\n//====================================================================\\r\\n//初期化処理\\r\\n    var _SRPG_Game_System_initialize = Game_System.prototype.initialize;\\r\\n    Game_System.prototype.initialize = function() {\\r\\n        _SRPG_Game_System_initialize.call(this);\\r\\n        this._SRPGMode = false;\\r\\n        this._isBattlePhase = 'initialize';\\r\\n        this._isSubBattlePhase = 'initialize';\\r\\n        this._AutoUnitId = 0;\\r\\n        this._EventToUnit = [];\\r\\n        this._SrpgStatusWindowRefreshFlag = [false, null];\\r\\n        this._SrpgBattleWindowRefreshFlag = [false, null, null];\\r\\n        this._SrpgWaitMoving = false;\\r\\n        this._SrpgActorCommandWindowRefreshFlag = [false, null];\\r\\n        this._SrpgActorCommandStatusWindowRefreshFlag = [false, null];\\r\\n        this._srpgAllActors = []; //SRPGモードに参加する全てのアクターの配列\\r\\n        this._searchedItemList = [];\\r\\n\\t\\tthis.initOptions();\\r\\n    };\\r\\n\\t\\r\\n\\tGame_System.prototype.initOptions = function() {\\r\\n        if(this.optionDisableGrid == null){\\r\\n\\t\\t\\tthis.optionDisableGrid = false;\\r\\n\\t\\t}\\r\\n\\t\\tif(this.showWillIndicator == null){\\r\\n\\t\\t\\tthis.showWillIndicator = false;\\r\\n\\t\\t}\\r\\n\\t\\tif(this.optionDefaultSupport == null){\\r\\n\\t\\t\\tthis.optionDefaultSupport = true;\\r\\n\\t\\t}\\r\\n\\t\\tif(this.optionSkipUnitMoving == null){\\r\\n\\t\\t\\tthis.optionSkipUnitMoving = false;\\r\\n\\t\\t}\\r\\n\\t\\tif(this.optionBattleBGM == null){\\r\\n\\t\\t\\tthis.optionBattleBGM = true;\\r\\n\\t\\t}\\r\\n\\t\\tif(this.optionAfterBattleBGM == null){\\r\\n\\t\\t\\tthis.optionAfterBattleBGM = true;\\r\\n\\t\\t}\\r\\n    };\\r\\n\\r\\n//変数関係の処理\\r\\n    //戦闘中かどうかのフラグを返す\\r\\n    Game_System.prototype.isSRPGMode = function() {\\r\\n        return this._SRPGMode;\\r\\n    };\\r\\n\\r\\n    //戦闘のフェーズを返す\\r\\n    // initialize：初期化状態\\r\\n    // actor_phase：アクター行動フェーズ\\r\\n    // auto_actor_phase：アクター自動行動フェーズ\\r\\n    // enemy_phase：エネミー行動フェーズ\\r\\n    Game_System.prototype.isBattlePhase = function() {\\r\\n        return this._isBattlePhase;\\r\\n    };\\r\\n\\r\\n    //戦闘のフェーズを変更する\\r\\n    Game_System.prototype.setBattlePhase = function(phase) {\\r\\n        this._isBattlePhase = phase;\\r\\n    };\\r\\n\\r\\n    //戦闘のサブフェーズを返す。各BattlePhase内で使用され、処理の進行を制御する。\\r\\n    // initialize：初期化を行う状態\\r\\n    // normal：行動アクターが選択されていない状態\\r\\n    // actor_move：移動範囲が表示され、移動先を選択している状態\\r\\n    // actor_target：行動対象を選択している状態\\r\\n    // status_window：ステータスウィンドウが開かれている状態\\r\\n    // actor_command_window：アクターコマンドウィンドウが開かれている状態\\r\\n    // battle_window：攻撃確認ウィンドウが開かれている状態\\r\\n    // auto_actor_command：自動行動アクターをイベント順に行動決定する状態\\r\\n    // auto_actor_move : 自動行動アクターが移動先を決定し、移動する状態\\r\\n    // auto_actor_action：自動行動アクターの実際の行動を行う状態\\r\\n    // enemy_command：エネミーをイベント順に行動決定する状態\\r\\n    // enemy_move : エネミーが移動先を決定し、移動する状態\\r\\n    // enemy_action：エネミーの実際の行動を行う状態\\r\\n    // invoke_action：戦闘を実行している状態\\r\\n    // after_battle：戦闘終了後の処理を呼び出す状態\\r\\n    Game_System.prototype.isSubBattlePhase = function() {\\r\\n        return this._isSubBattlePhase;\\r\\n    };\\r\\n\\r\\n    //戦闘のサブフェーズを変更する\\r\\n    Game_System.prototype.setSubBattlePhase = function(phase) {\\r\\n\\t\\t$SRWGameState.requestNewState(phase);\\r\\n        this._isSubBattlePhase = phase;\\r\\n    };\\r\\n\\r\\n    //自動行動・エネミーの実行ＩＤを返す\\r\\n    Game_System.prototype.isAutoUnitId = function() {\\r\\n        return this._AutoUnitId;\\r\\n    };\\r\\n\\r\\n    //自動行動・エネミーの実行ＩＤを設定する\\r\\n    Game_System.prototype.setAutoUnitId = function(num) {\\r\\n        this._AutoUnitId = num;\\r\\n    };\\r\\n\\r\\n    // ステータスウィンドウのリフレッシュフラグを返す\\r\\n    Game_System.prototype.srpgStatusWindowNeedRefresh = function() {\\r\\n        return this._SrpgStatusWindowRefreshFlag;\\r\\n    };\\r\\n\\r\\n    // ステータスウィンドウのリフレッシュフラグを設定する\\r\\n    Game_System.prototype.setSrpgStatusWindowNeedRefresh = function(battlerArray) {\\r\\n        this._SrpgStatusWindowRefreshFlag = [true, battlerArray];\\r\\n    };\\r\\n\\r\\n    // ステータスウィンドウのリフレッシュフラグをクリアする\\r\\n    Game_System.prototype.clearSrpgStatusWindowNeedRefresh = function() {\\r\\n        this._SrpgStatusWindowRefreshFlag = [false, null];\\r\\n    };\\r\\n\\r\\n    // 予想ウィンドウ・戦闘開始ウィンドウのリフレッシュフラグを返す\\r\\n    Game_System.prototype.srpgBattleWindowNeedRefresh = function() {\\r\\n        return this._SrpgBattleWindowRefreshFlag;\\r\\n    };\\r\\n\\r\\n    // 予想ウィンドウ・戦闘開始ウィンドウのリフレッシュフラグを設定する\\r\\n    Game_System.prototype.setSrpgBattleWindowNeedRefresh = function(actionBattlerArray, targetBattlerArray) {\\r\\n        this._SrpgBattleWindowRefreshFlag = [true, actionBattlerArray, targetBattlerArray];\\r\\n    };\\r\\n\\r\\n    // 予想ウィンドウ・戦闘開始ウィンドウのリフレッシュフラグをクリアする\\r\\n    Game_System.prototype.clearSrpgBattleWindowNeedRefresh = function() {\\r\\n        this._SrpgBattleWindowRefreshFlag = [false, null, null];\\r\\n    };\\r\\n\\r\\n    //移動範囲を表示するスプライトの最大数\\r\\n    Game_System.prototype.spriteMoveTileMax = function() {\\r\\n        return Math.min($dataMap.width * $dataMap.height, 1000);\\r\\n    };\\r\\n\\r\\n    // 移動中のウェイトフラグを返す\\r\\n    Game_System.prototype.srpgWaitMoving = function() {\\r\\n        return this._SrpgWaitMoving;\\r\\n    };\\r\\n\\r\\n    // 移動中のウェイトフラグを設定する\\r\\n    Game_System.prototype.setSrpgWaitMoving = function(flag) {\\r\\n        this._SrpgWaitMoving = flag;\\r\\n    };\\r\\n\\r\\n    // アクターコマンドウィンドウのリフレッシュフラグを返す\\r\\n    Game_System.prototype.srpgActorCommandWindowNeedRefresh = function() {\\r\\n        return this._SrpgActorCommandWindowRefreshFlag;\\r\\n    };\\r\\n\\r\\n    // アクターコマンドウィンドウのリフレッシュフラグを設定する\\r\\n    Game_System.prototype.setSrpgActorCommandWindowNeedRefresh = function(battlerArray) {\\r\\n        this._SrpgActorCommandWindowRefreshFlag = [true, battlerArray];\\r\\n    };\\r\\n\\r\\n    // アクターコマンドウィンドウのリフレッシュフラグをクリアする\\r\\n    Game_System.prototype.clearSrpgActorCommandWindowNeedRefresh = function() {\\r\\n        this._SrpgActorCommandWindowRefreshFlag = [false, null];\\r\\n    };\\r\\n\\r\\n    // 行動中アクターの簡易ステータスウィンドウのリフレッシュフラグを返す\\r\\n    Game_System.prototype.srpgActorCommandStatusWindowNeedRefresh = function() {\\r\\n        return this._SrpgActorCommandStatusWindowRefreshFlag;\\r\\n    };\\r\\n\\r\\n    // 行動中アクターの簡易ステータスウィンドウのリフレッシュフラグを設定する\\r\\n    Game_System.prototype.setSrpgActorCommandStatusWindowNeedRefresh = function(battlerArray) {\\r\\n        this._SrpgActorCommandStatusWindowRefreshFlag = [true, battlerArray];\\r\\n    };\\r\\n\\r\\n    // 行動中アクターの簡易ステータスウィンドウのリフレッシュフラグをクリアする\\r\\n    Game_System.prototype.clearSrpgActorCommandStatusWindowNeedRefresh = function() {\\r\\n        this._SrpgActorCommandStatusWindowRefreshFlag = [false, null];\\r\\n    };\\r\\n\\r\\n    //戦闘に参加するアクターのリスト\\r\\n    Game_System.prototype.srpgAllActors = function() {\\r\\n        return this._srpgAllActors;\\r\\n    };\\r\\n\\r\\n    Game_System.prototype.clearSrpgAllActors = function() {\\r\\n        this._srpgAllActors = [];\\r\\n    };\\r\\n\\r\\n    Game_System.prototype.pushSrpgAllActors = function(actor) {\\r\\n        this._srpgAllActors.push(actor);\\r\\n    };\\r\\n\\r\\n    // 探査済み座標のリスト\\r\\n    Game_System.prototype.pushSearchedItemList = function(xy) {\\r\\n        if (!this._searchedItemList) {\\r\\n            this._searchedItemList = [];\\r\\n        }\\r\\n        this._searchedItemList.push(xy);\\r\\n    };\\r\\n\\r\\n    Game_System.prototype.indexOfSearchedItemList = function(xy) {\\r\\n        if (!this._searchedItemList) {\\r\\n            this._searchedItemList = [];\\r\\n        }\\r\\n        var flag = -1;\\r\\n        for (var i=0; i < this._searchedItemList.length; i++) {\\r\\n            var xy2 = this._searchedItemList[i];\\r\\n            if (xy[0] === xy2[0] && xy[1] === xy2[1]) {\\r\\n                flag = i;\\r\\n                break;\\r\\n            }\\r\\n        };\\r\\n        return flag;\\r\\n    };\\r\\n\\r\\n    Game_System.prototype.resetSearchedItemList = function() {\\r\\n        this._searchedItemList = [];\\r\\n    };\\r\\n\\r\\n//戦闘開始に関係する処理\\r\\n    //戦闘開始するためのプラグイン・コマンド\\r\\n\\tGame_System.prototype.startIntermission = function(){\\r\\n\\t\\tthis._isIntermission = true;\\r\\n\\t\\tthis._availableUnits = $gameParty.allMembers();\\r\\n\\t\\tthis.dummyId = 0;\\r\\n\\t\\tthis._availableUnits.forEach(function(actor){\\r\\n\\t\\t\\tactor.isSubPilot = false;\\r\\n\\t\\t\\t$statCalc.attachDummyEvent(actor, actor.SRWStats.mech.id);\\r\\n\\t\\t\\t$statCalc.invalidateAbilityCache();\\r\\n\\t\\t\\t$statCalc.initSRWStats(actor);\\t\\t\\t\\r\\n\\t\\t});\\r\\n\\t\\t\\r\\n\\t\\tthis._availableMechs = [];\\r\\n\\t\\tvar tmp = Object.keys($SRWSaveManager.getUnlockedUnits());\\t\\t\\t\\r\\n\\t\\tfor(var i = 0; i < tmp.length; i++){\\r\\n\\t\\t\\tvar currentPilot = $statCalc.getCurrentPilot(tmp[i]);\\r\\n\\t\\t\\tif(!currentPilot){\\r\\n\\t\\t\\t\\tvar mechData = $statCalc.getMechData($dataClasses[tmp[i]], true);\\t\\t\\t\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tvar result = $statCalc.createEmptyActor();\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tresult.SRWStats.mech = mechData;\\t\\t\\r\\n\\t\\t\\t\\t$statCalc.attachDummyEvent(result, mechData.id);\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tthis._availableMechs.push(result);\\r\\n\\t\\t\\t\\t$statCalc.invalidateAbilityCache();\\t\\r\\n\\t\\t\\t\\t$statCalc.calculateSRWMechStats(mechData, false, result);\\t\\t\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\t\\r\\n\\t\\t\\r\\n\\t\\t$statCalc.invalidateAbilityCache();\\r\\n\\t\\t$gameTemp.deployMode = \\\"\\\";\\r\\n\\t\\t\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.isIntermission = function(id){\\r\\n\\t\\treturn this._isIntermission;\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.getAvailableUnits = function(id){\\r\\n\\t\\treturn this._availableUnits;\\r\\n\\t}\\r\\n\\t\\r\\n\\t//use $gameActors.actor instead!\\r\\n\\tGame_System.prototype.getActorById = function(id){\\r\\n\\t\\tvar result;\\r\\n\\t\\tvar ctr = 0; \\r\\n\\t\\twhile(!result && ctr < this._availableUnits.length){\\r\\n\\t\\t\\tif(this._availableUnits[ctr].actorId() == id){\\r\\n\\t\\t\\t\\tresult = this._availableUnits[ctr];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tctr++;\\r\\n\\t\\t}\\r\\n\\t\\treturn result;\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.endIntermission = function(){\\r\\n\\t\\t$gameTemp.intermissionPending = false;\\r\\n\\t\\tthis._isIntermission = false;\\r\\n\\t}\\t\\r\\n\\t\\r\\n    Game_System.prototype.startSRPG = function() {\\r\\n        this._SRPGMode = true;\\r\\n\\t\\tthis.enableGrid = true;\\r\\n\\t\\t$gameTemp.listContext = \\\"actor\\\";\\r\\n        $gameSwitches.setValue(_srpgBattleSwitchID, true);\\r\\n        this._isBattlePhase = 'start_srpg';\\r\\n        this._isSubBattlePhase = 'start_srpg';\\r\\n        $gamePlayer.refresh();\\r\\n        $gameTemp.clearActiveEvent();\\r\\n\\t\\t$gameTemp.actorAction = {};\\r\\n\\t\\t$gameTemp.enemyAction = {};\\r\\n        this.clearData(); //データの初期化\\r\\n        this.setAllEventType(); //イベントタイプの設定\\r\\n\\t\\tthis._availableUnits = [];\\r\\n        this.setSrpgActors(); //アクターデータの作成\\r\\n        this.setSrpgEnemys(); //エネミーデータの作成\\r\\n\\t\\t\\r\\n        $gameMap.setEventImages();   // ユニットデータに合わせてイベントのグラフィックを変更する\\r\\n        this.runBattleStartEvent(); // ゲーム開始時の自動イベントを実行する\\r\\n\\t\\tthis.runAfterDeployEvent();\\r\\n\\t\\t//clear stage temp variables\\r\\n\\t\\tfor(var i = 21; i <= 60; i++){\\r\\n\\t\\t\\t$gameVariables.setValue(i, 0);\\r\\n\\t\\t}\\r\\n\\t\\r\\n        $gameVariables.setValue(_turnVarID, 1); //ターン数を初期化する\\r\\n        $gameSystem.resetSearchedItemList(); //探索済み座標を初期化する\\r\\n\\t\\t$gameSystem._specialTheme = -1;\\r\\n\\t\\t$gameSystem.highlightedTiles = [];\\r\\n\\t\\t$gameSystem.regionHighlights = {};\\r\\n\\t\\t$gameSystem.enemyUpgradeLevel = 0;\\r\\n\\t\\t$gameSystem.persuadeOptions = {};\\r\\n\\t\\t$gameTemp.currentSwapSource = -1;\\r\\n\\t\\t$gameTemp.enemyAppearQueue = [];\\r\\n\\t\\t$gameSystem.defaultBattleEnv = null;\\r\\n\\t\\t$gameSystem.skyBattleEnv = null;\\r\\n\\t\\t$gameSystem.regionBattleEnv = {};\\r\\n\\t\\t$gameSystem.regionSkyBattleEnv = {};\\r\\n\\t\\t$gameSystem.stageTextId = null;\\r\\n\\t\\t\\r\\n\\t\\tif($gameSystem.foregroundSpriteToggleState == null){\\r\\n\\t\\t\\t$gameSystem.foregroundSpriteToggleState = 0;\\r\\n\\t\\t}\\r\\n\\t\\t//$gameSystem.showWillIndicator = false;\\r\\n\\t\\t$gameTemp.disappearQueue = [];\\r\\n\\r\\n\\t\\t$gameSystem.actorRankLookup = $statCalc.getActorRankLookup();\\r\\n\\t\\t$gameTemp.AIWaitTimer = 0;\\r\\n\\t\\t\\r\\n\\t\\t$gameVariables.setValue(_masteryConditionText, APPSTRINGS.GENERAL.label_default_mastery_condition);\\t\\r\\n\\t\\t$gameVariables.setValue(_victoryConditionText, APPSTRINGS.GENERAL.label_default_victory_condition);\\t\\r\\n\\t\\t$gameVariables.setValue(_defeatConditionText, APPSTRINGS.GENERAL.label_default_defeat_condition);\\r\\n\\t\\t\\r\\n\\t\\t$gameSystem.factionConfig = {\\r\\n\\t\\t\\t0: {\\r\\n\\t\\t\\t\\tattacksPlayers:true,\\r\\n\\t\\t\\t\\tattacksFactions: [1,2],\\r\\n\\t\\t\\t\\tactive: true\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\t1: {\\r\\n\\t\\t\\t\\tattacksPlayers:false,\\r\\n\\t\\t\\t\\tattacksFactions: [0],\\r\\n\\t\\t\\t\\tactive: false\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\t2: {\\r\\n\\t\\t\\t\\tattacksPlayers:false,\\r\\n\\t\\t\\t\\tattacksFactions: [0],\\r\\n\\t\\t\\t\\tactive: false\\r\\n\\t\\t\\t}\\r\\n\\t\\t};\\r\\n\\t\\t$gameTemp.preventedDeathQuotes = {};\\r\\n\\t\\t$gameTemp.updatePlayerSpriteVisibility();\\r\\n\\t\\t\\r\\n\\t\\tSceneManager._scene.createPauseWindow(); //ensure pause menu is updated to reflect the new mode\\r\\n    };\\r\\n\\t\\r\\n\\tGame_Temp.prototype.updatePlayerSpriteVisibility = function(id) {\\r\\n\\t\\tif($gameSystem.isSRPGMode()){\\r\\n\\t\\t\\tif(this.upperPlayerSprite){\\r\\n\\t\\t\\t\\tthis.upperPlayerSprite.show();\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(this.lowerPlayerSprite){\\r\\n\\t\\t\\t\\tthis.lowerPlayerSprite.hide();\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif(this.upperPlayerSprite){\\r\\n\\t\\t\\t\\tthis.upperPlayerSprite.hide();\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(this.lowerPlayerSprite){\\r\\n\\t\\t\\t\\tthis.lowerPlayerSprite.show();\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.enableFaction = function(id) {\\r\\n\\t\\tif(this.factionConfig[id]){\\r\\n\\t\\t\\tthis.factionConfig[id].active = true;\\r\\n\\t\\t}\\t\\t\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.disableFaction = function(id) {\\r\\n\\t\\tif(this.factionConfig[id]){\\r\\n\\t\\t\\tthis.factionConfig[id].active = false;\\r\\n\\t\\t}\\t\\t\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.setFactionAggro = function(id, aggro) {\\r\\n\\t\\tif(this.factionConfig[id]){\\r\\n\\t\\t\\tthis.factionConfig[id].attacksFactions = [];\\r\\n\\t\\t\\tfor(var i = 0; i < aggro.length; i++){\\r\\n\\t\\t\\t\\tif(aggro[i] == \\\"player\\\"){\\r\\n\\t\\t\\t\\t\\tthis.factionConfig[id].attacksPlayers = true;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tthis.factionConfig[id].attacksFactions.push(aggro[i]);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\t\\t\\r\\n\\t\\t}\\r\\n\\t}\\t\\t\\r\\n\\t\\r\\n\\tGame_System.prototype.clearFactionAggro = function(id) {\\r\\n\\t\\tif(this.factionConfig[id]){\\r\\n\\t\\t\\tthis.factionConfig[id].attacksFactions = [];\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.getPlayerFactionInfo = function() {\\r\\n\\t\\t var aggressiveFactions = [];\\r\\n\\t\\t if(this.factionConfig[0].attacksPlayers){\\r\\n\\t\\t\\t aggressiveFactions.push(0);\\r\\n\\t\\t }\\r\\n\\t\\t if(this.factionConfig[1].attacksPlayers){\\r\\n\\t\\t\\t aggressiveFactions.push(1);\\r\\n\\t\\t }\\r\\n\\t\\t if(this.factionConfig[2].attacksPlayers){\\r\\n\\t\\t\\t aggressiveFactions.push(2);\\r\\n\\t\\t }\\r\\n\\t\\t return {\\r\\n\\t\\t\\tattacksPlayers:false,\\r\\n\\t\\t\\tattacksFactions: aggressiveFactions,\\r\\n\\t\\t\\tactive: true \\r\\n\\t\\t };\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.getFactionId = function(actor) {\\r\\n\\t\\tif(actor.isActor()){\\r\\n\\t\\t\\treturn \\\"player\\\";\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn actor.factionId;\\r\\n\\t\\t}\\t\\t\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.getEnemyFactionInfo = function(enemy) {\\r\\n\\t\\t return this.factionConfig[enemy.factionId];\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.isFriendly = function(actor, factionId) {\\r\\n\\t\\tvar factionInfo = this.getUnitFactionInfo(actor);\\r\\n\\t\\tif(factionId == \\\"player\\\"){\\r\\n\\t\\t\\treturn !factionInfo.attacksPlayers;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn factionInfo.attacksFactions.indexOf(factionId) == -1;\\r\\n\\t\\t}\\r\\n\\t}\\t\\r\\n\\t\\r\\n\\tGame_System.prototype.getUnitFactionInfo = function(actor) {\\r\\n\\t\\tif(actor.isActor()){\\r\\n\\t\\t\\treturn this.getPlayerFactionInfo();\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn this.getEnemyFactionInfo(actor);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.isEnemy = function(actor) {\\r\\n\\t\\tif(!actor.isActor){\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t}\\r\\n\\t\\tif(actor.isActor()){\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn this.getEnemyFactionInfo(actor).attacksPlayers;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.isEnemyPhase = function(actor) {\\r\\n\\t\\treturn $gameSystem.factionConfig[$gameTemp.currentFaction].attacksPlayers;\\r\\n\\t}\\r\\n\\r\\n    //イベントＩＤに対応するアクター・エネミーデータを初期化する\\r\\n    Game_System.prototype.clearData = function() {\\r\\n        this._EventToUnit = [];\\r\\n        $gameSystem.clearSrpgAllActors();\\r\\n    };\\r\\n\\r\\n    //イベントＩＤに対応するアクター・エネミーデータをセットする\\r\\n    Game_System.prototype.setEventToUnit = function(event_id, type, data) {\\r\\n        this._EventToUnit[event_id] = [type, data];\\r\\n    };\\r\\n\\t\\r\\n\\tGame_System.prototype.clearEventToUnit = function(event_id) {\\r\\n\\t\\tdelete this._EventToUnit[event_id];\\r\\n\\t}\\r\\n\\r\\n    //イベントＩＤから対応するアクター・エネミーデータを返す\\r\\n    Game_System.prototype.EventToUnit = function(event_id) {\\r\\n        //return this._EventToUnit[event_id];\\r\\n        var battlerArray = this._EventToUnit[event_id];\\r\\n        if (battlerArray) {\\r\\n            if (battlerArray[0] === 'actor') {\\r\\n                var actor = $gameActors.actor(battlerArray[1]);\\r\\n                return [battlerArray[0], actor]\\r\\n            } else {\\r\\n                return battlerArray;\\r\\n            }\\r\\n        } else {\\r\\n            return;\\r\\n        }\\r\\n    };\\r\\n\\r\\n    //アクターＩＤから対応するイベントＩＤを返す\\r\\n    Game_System.prototype.ActorToEvent = function(actor_id) {\\r\\n        var eventId = 0;\\r\\n        $gameMap.events().forEach(function(event) {\\r\\n            if (event.isType() === 'actor' || event.isType() === 'ship' || event.isType() === 'ship_event') {\\r\\n\\t\\t\\t\\tvar unit =  $gameSystem.EventToUnit(event.eventId());\\r\\n\\t\\t\\t\\tif(unit){\\r\\n\\t\\t\\t\\t\\tvar actor = unit[1];\\r\\n\\t\\t\\t\\t\\tif (actor && actor.actorId() == actor_id) {\\r\\n\\t\\t\\t\\t\\t\\teventId = event.eventId();\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}              \\r\\n            }\\r\\n        });\\r\\n        return eventId;\\r\\n    };\\r\\n\\t\\r\\n\\r\\n    // イベントのメモからイベントのタイプを設定する\\r\\n    Game_System.prototype.setAllEventType = function() {\\r\\n        $gameMap.events().forEach(function(event) {\\r\\n            if (event.event().meta.type) {\\r\\n                event.setType(event.event().meta.type);\\r\\n            }\\r\\n        });\\r\\n    }\\r\\n\\t\\r\\n\\tGame_System.prototype.getActorsWithAction = function(){\\r\\n\\t\\tvar _this = this;\\t\\t\\r\\n\\t\\tvar result = [];\\r\\n\\t\\t$gameMap.events().forEach(function(event) {\\r\\n\\t\\t\\tvar battlerArray = _this.EventToUnit(event.eventId());\\r\\n\\t\\t\\tif(!event.isErased() && battlerArray){\\r\\n\\t\\t\\t\\tvar actor = battlerArray[1];\\r\\n\\t\\t\\t\\tif(actor.isActor() && !actor.srpgTurnEnd()){\\r\\n\\t\\t\\t\\t\\tresult.push(actor);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n        });\\r\\n\\t\\treturn result;\\r\\n\\t}\\r\\n\\r\\n    // イベントのメモからアクターを読み込み、対応するイベントＩＤに紐づけする\\r\\n    Game_System.prototype.setSrpgActors = function() {\\r\\n  \\r\\n        $gameVariables.setValue(_existActorVarID, 0);\\r\\n\\t\\t$gameVariables.setValue(_actorsDestroyed, 0);\\r\\n\\t\\t$gameVariables.setValue(_existShipVarId, 0);\\t\\r\\n\\r\\n\\t\\tthis._availableUnits = $gameParty.allMembers();\\r\\n\\t\\tthis._availableUnits.forEach(function(actor){\\r\\n\\t\\t\\t$statCalc.initSRWStats(actor);\\r\\n\\t\\t\\tactor.event = null;\\r\\n\\t\\t});\\r\\n\\t\\t\\r\\n\\t\\t$gameMap.events().forEach(function(event) {\\r\\n\\t\\t\\tif (event.isType() === 'actor' || event.isType() === 'ship' || event.isType() === 'ship_event') {\\r\\n\\t\\t\\t\\tevent.erase();\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n    };\\r\\n\\r\\n\\tGame_System.prototype.deployShips = function(toAnimQueue) {\\t\\t\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tvar deployInfo = _this.getDeployInfo();\\r\\n\\t\\tvar deployList = _this.getActiveShipDeployList();\\t\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tvar shipCtr = 0;\\t\\t\\r\\n\\t\\t$gameMap.events().forEach(function(event) { //ensure to spawn ships first so that are drawn below the other actor sprites\\r\\n\\t\\t\\tif (event.isType() === 'ship' && !event.isDeployed) {\\r\\n\\t\\t\\t\\tvar actor_unit;\\r\\n\\t\\t\\t\\tvar entry = deployList[shipCtr] || {};\\r\\n\\t\\t\\t\\tvar actorId = entry.main;\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tif(typeof actorId != \\\"undefined\\\"){\\r\\n\\t\\t\\t\\t\\tactor_unit = $gameActors.actor(actorId);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif (actor_unit) {\\r\\n\\t\\t\\t\\t\\tactor_unit.event = event;\\r\\n                    _this.pushSrpgAllActors(event.eventId());\\r\\n                    event.isDeployed = true;\\r\\n                    var bitmap = ImageManager.loadFace(actor_unit.faceName()); //顔グラフィックをプリロードする\\r\\n                    var oldValue = $gameVariables.value(_existShipVarId);\\r\\n                    $gameVariables.setValue(_existShipVarId, oldValue + 1);\\r\\n                    _this.setEventToUnit(event.eventId(), 'actor', actor_unit.actorId());\\r\\n\\t\\t\\t\\t\\t$statCalc.initSRWStats(actor_unit);\\r\\n\\t\\t\\t\\t\\tactor_unit.setSrpgTurnEnd(false);\\t\\r\\n\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tif(toAnimQueue){\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\t$gameTemp.enemyAppearQueue.push(event);\\r\\n\\t\\t\\t\\t\\t\\tevent.erase();\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\tevent.appear();\\r\\n\\t\\t\\t\\t\\t\\t$gameMap.setEventImages();\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t}\\r\\n                } else {\\r\\n\\t\\t\\t\\t\\tevent.erase();\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tshipCtr++;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t});\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.deployActor = function(actor_unit, event, toAnimQueue, subId) {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tactor_unit.event = event;\\r\\n\\t\\t_this.pushSrpgAllActors(event.eventId());\\r\\n\\t\\tevent.isDeployed = true;\\r\\n\\t\\tvar bitmap = ImageManager.loadFace(actor_unit.faceName()); //顔グラフィックをプリロードする\\r\\n\\t\\tvar oldValue = $gameVariables.value(_existActorVarID);\\r\\n\\t\\t$gameVariables.setValue(_existActorVarID, oldValue + 1);\\r\\n\\t\\t_this.setEventToUnit(event.eventId(), 'actor', actor_unit.actorId());\\r\\n\\t\\tactor_unit.isSubPilot = false;\\r\\n\\t\\t\\r\\n\\t\\t$statCalc.initSRWStats(actor_unit);\\r\\n\\t\\t\\r\\n\\t\\t$statCalc.applyDeployActions(actor_unit.SRWStats.pilot.id, actor_unit.SRWStats.mech.id);\\r\\n\\t\\t\\r\\n\\t\\t$statCalc.applyBattleStartWill(actor_unit);\\r\\n\\t\\tactor_unit.SRPGActionTimesSet($statCalc.applyStatModsToValue(actor_unit, 1, [\\\"extra_action\\\"]));\\r\\n\\t\\tactor_unit.setSrpgTurnEnd(false);\\t\\r\\n\\t\\tactor_unit.setBattleMode(\\\"\\\");\\r\\n\\r\\n\\t\\tvar position = $statCalc.getAdjacentFreeSpace({x: event.posX(), y: event.posY()}, null, event.eventId());\\r\\n\\t\\tevent.locate(position.x, position.y);\\r\\n\\t\\t\\r\\n\\t\\tif(!$gameTemp.enemyAppearQueue){\\r\\n\\t\\t\\t$gameTemp.enemyAppearQueue = [];\\r\\n\\t\\t}\\t\\r\\n\\t\\tif(toAnimQueue){\\t\\t\\t\\t\\r\\n\\t\\t\\t$gameTemp.enemyAppearQueue.push(event);\\r\\n\\t\\t\\tevent.erase();\\r\\n\\t\\t\\tevent.isPendingDeploy = true;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tevent.appear();\\r\\n\\t\\t\\t//event.refreshImage();\\r\\n\\t\\t\\t$gameMap.setEventImages();\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\t/*var deployInfo = $gameSystem.getDeployInfo();\\r\\n\\t\\tvar currentSlot = -1;\\r\\n\\t\\tvar currentMaxSlot = -1;\\r\\n\\t\\t\\r\\n\\t\\tObject.keys(deployInfo.assigned).forEach(function(slot){\\r\\n\\t\\t\\tif(slot > currentMaxSlot){\\r\\n\\t\\t\\t\\tcurrentMaxSlot = slot;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(deployInfo.assigned[slot] == actor_unit.actorId()){\\r\\n\\t\\t\\t\\tcurrentSlot = slot;\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\t\\t\\r\\n\\t\\tif(currentSlot == -1){\\r\\n\\t\\t\\tdeployInfo.assigned[currentMaxSlot+1] = actor_unit.actorId();\\r\\n\\t\\t}\\r\\n\\t\\t$gameSystem.setDeployInfo(deployInfo);*/\\r\\n\\t\\t\\r\\n\\t\\tif(subId != null){\\r\\n\\t\\t\\tactor_unit.subTwinId = subId;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\t$statCalc.invalidateAbilityCache();\\r\\n\\t\\t$statCalc.initSRWStats(actor_unit);\\r\\n\\t\\t$statCalc.updateFlightState(actor_unit);\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.getEventDeploySlot = function(event) {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tif(!this.eventToDeploySlot){\\r\\n\\t\\t\\tthis.eventToDeploySlot = {};\\r\\n\\t\\t\\tvar i = 0;\\r\\n\\t\\t\\t$gameMap.events().forEach(function(event) {\\r\\n\\t\\t\\t\\tif(event.isType() === 'actor') {\\r\\n\\t\\t\\t\\t\\t_this.eventToDeploySlot[event.eventId()] = i++;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t});\\r\\n\\t\\t}\\r\\n\\t\\treturn this.eventToDeploySlot[event.eventId()];\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.highlightDeployTiles = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tif(!$gameSystem.highlightedTiles){\\r\\n\\t\\t\\t$gameSystem.highlightedTiles = [];\\r\\n\\t\\t}\\r\\n\\t\\tthis.removeDeployTileHighlights();\\r\\n\\t\\t$gameTemp.currentDeployTileHighlights = [];\\r\\n\\t\\tvar deployInfo = _this.getDeployInfo();\\r\\n\\t\\tvar i = 0;\\r\\n\\t\\t$gameMap.events().forEach(function(event) {\\r\\n\\t\\t\\tif(event.isType() === 'actor') {\\r\\n\\t\\t\\t\\tif(i == $gameTemp.currentSwapSource){\\r\\n\\t\\t\\t\\t\\t$gameSystem.highlightedTiles.push({x: event.posX(), y: event.posY(), color: \\\"#00FF00\\\"});\\r\\n\\t\\t\\t\\t} else if(deployInfo.lockedSlots[i]){\\r\\n\\t\\t\\t\\t\\t$gameSystem.highlightedTiles.push({x: event.posX(), y: event.posY(), color: \\\"yellow\\\"});\\r\\n\\t\\t\\t\\t} else if(deployInfo.assigned[i] && !$statCalc.canStandOnTile($gameActors.actor(deployInfo.assigned[i]), {x: event.posX(), y: event.posY()})){\\r\\n\\t\\t\\t\\t\\t$gameSystem.highlightedTiles.push({x: event.posX(), y: event.posY(), color: \\\"red\\\"});\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t$gameSystem.highlightedTiles.push({x: event.posX(), y: event.posY(), color: \\\"white\\\"});\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t$gameTemp.currentDeployTileHighlights.push({x: event.posX(), y: event.posY()});\\r\\n\\t\\t\\t\\ti++;\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\t\\r\\n\\t\\t$gameSystem.highlightsRefreshed = true;\\r\\n\\t}\\t\\r\\n\\t\\r\\n\\tGame_System.prototype.removeDeployTileHighlights = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tif($gameTemp.currentDeployTileHighlights && $gameSystem.highlightedTiles){\\r\\n\\t\\t\\tvar tileLookup = {};\\r\\n\\t\\t\\t$gameTemp.currentDeployTileHighlights.forEach(function(coords){\\r\\n\\t\\t\\t\\tif(!tileLookup[coords.x]){\\r\\n\\t\\t\\t\\t\\ttileLookup[coords.x] = {};\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\ttileLookup[coords.x][coords.y] = true;\\r\\n\\t\\t\\t});\\r\\n\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\tvar tmp = [];\\r\\n\\t\\t\\tfor(var i = 0; i < $gameSystem.highlightedTiles.length; i++){\\r\\n\\t\\t\\t\\tif(!tileLookup[$gameSystem.highlightedTiles[i].x] || !tileLookup[$gameSystem.highlightedTiles[i].x][$gameSystem.highlightedTiles[i].y]){\\r\\n\\t\\t\\t\\t\\ttmp.push($gameSystem.highlightedTiles);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$gameSystem.highlightedTiles = tmp;\\r\\n\\t\\t\\t$gameSystem.highlightsRefreshed = true;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.undeployActors = function(){\\r\\n\\t\\t$gameVariables.setValue(_existActorVarID, 0);\\r\\n\\t\\t$gameSystem.clearSrpgAllActors();\\r\\n\\t\\t$gameMap.events().forEach(function(event) {\\t\\t\\t\\r\\n\\t\\t\\tif (event.isType() === 'actor') {\\r\\n\\t\\t\\t\\t$gameSystem.clearEventToUnit(event.eventId());\\r\\n\\t\\t\\t\\tevent.isDeployed = false;\\r\\n\\t\\t\\t\\tevent.erase();\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.redeployActors = function(validatePositions){                                                                                                                                                                                                                             \\r\\n\\t\\t$gameVariables.setValue(_existActorVarID, 0);\\r\\n\\t\\t$gameSystem.clearSrpgAllActors();\\r\\n\\t\\t$gameMap.events().forEach(function(event) {\\r\\n            if (event.isType() === 'actor') {\\r\\n\\t\\t\\t\\t$gameSystem.clearEventToUnit(event.eventId());\\r\\n\\t\\t\\t\\tevent.isDeployed = false;\\r\\n\\t\\t\\t}\\r\\n\\t\\t });\\r\\n\\t\\t this.deployActors(false, $gameTemp.manualDeployType, validatePositions);\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.redeployActor = function(actorId, toAnimQueue){  \\r\\n\\t\\tvar actor = $gameActors.actor(actorId);\\t\\t\\r\\n\\t\\t$gameMap.events().forEach(function(event) {\\r\\n\\t\\t\\tif (event.eventId() === actor.event.eventId()) {\\r\\n\\t\\t\\t\\t$gameSystem.clearEventToUnit(event.eventId());\\r\\n\\t\\t\\t\\tevent.isDeployed = false;\\r\\n\\t\\t\\t\\tvar oldValue = $gameVariables.value(_existActorVarID);\\r\\n\\t\\t\\t\\t$gameVariables.setValue(_existActorVarID, oldValue - 1);\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\tthis.deployActor(actor, actor.event, toAnimQueue);\\r\\n\\t\\tactor.initImages(actor.SRWStats.mech.classData.meta.srpgOverworld.split(\\\",\\\"));\\r\\n\\t\\tif(!toAnimQueue){\\r\\n\\t\\t\\tactor.event.refreshImage();\\r\\n\\t\\t}\\t\\t \\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.deployActors = function(toAnimQueue, lockedOnly, validatePositions) {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tif(lockedOnly == null){\\r\\n\\t\\t\\tlockedOnly = \\\"all\\\";\\r\\n\\t\\t}\\r\\n\\t\\tvar deployInfo = _this.getDeployInfo();\\r\\n\\t\\tvar deployList = _this.getActiveDeployList();\\r\\n\\t\\tvar i = 0;\\r\\n        $gameMap.events().forEach(function(event) {\\r\\n            if (event.isType() === 'actor' && !event.isDeployed) {\\r\\n              \\tvar actor_unit;\\r\\n\\t\\t\\t\\tvar entry = deployList[i] || {};\\r\\n\\t\\t\\t\\tvar actorId =entry.main;\\t\\t\\r\\n\\t\\t\\t\\tif(lockedOnly == \\\"all\\\" || (lockedOnly == \\\"locked\\\" && deployInfo.lockedSlots[i]) || (lockedOnly == \\\"unlocked\\\" && !deployInfo.lockedSlots[i])){\\r\\n\\t\\t\\t\\t\\tif(typeof actorId != \\\"undefined\\\"){\\r\\n\\t\\t\\t\\t\\t\\tactor_unit = $gameActors.actor(actorId);\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tif (actor_unit) {\\r\\n\\t\\t\\t\\t\\t\\tvar validPosition;\\r\\n\\t\\t\\t\\t\\t\\tif(validatePositions && !deployInfo.lockedSlots[i]){\\r\\n\\t\\t\\t\\t\\t\\t\\tvalidPosition = $statCalc.canStandOnTile(actor_unit, {x: event.posX(), y: event.posY()})\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\t\\tvalidPosition = true;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\tif(validPosition){\\r\\n\\t\\t\\t\\t\\t\\t\\t_this.deployActor(actor_unit, event, toAnimQueue, entry.sub);\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\t\\tevent.erase();\\r\\n\\t\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\tevent.erase();\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\t\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\ti++;\\t\\r\\n            }\\t\\t\\r\\n        });\\r\\n\\t}\\r\\n\\t\\r\\n    // イベントのメモからエネミーを読み込み、対応するイベントＩＤに紐づけする\\r\\n    Game_System.prototype.setSrpgEnemys = function() {\\r\\n        $gameVariables.setValue(_existEnemyVarID, 0);\\r\\n\\t\\t$gameVariables.setValue(_enemiesDestroyed, 0);\\r\\n        var i = 0;\\r\\n        $gameMap.events().forEach(function(event) {\\r\\n            if (event.isType() === 'enemy') {\\r\\n                var enemyId = event.event().meta.id ? Number(event.event().meta.id) : 1;\\r\\n                var enemy_unit = new Game_Enemy(enemyId, 0, 0);\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tenemy_unit._mechClass = parseInt(event.event().meta.mechClass)\\r\\n\\t\\t\\t\\t\\r\\n                if (enemy_unit) {\\r\\n\\t\\t\\t\\t\\tenemy_unit.event = event;\\r\\n                    if (event.event().meta.mode) {\\r\\n                        enemy_unit.setBattleMode(event.event().meta.mode);\\r\\n                        if (event.event().meta.targetId) {\\r\\n                            enemy_unit.setTargetId(event.event().meta.targetId);\\r\\n                        }\\r\\n                    }\\r\\n                    enemy_unit.initTp(); //TPを初期化\\r\\n                    var faceName = enemy_unit.enemy().meta.faceName; //顔グラフィックをプリロードする\\r\\n                    if (faceName) {\\r\\n                        var bitmap = ImageManager.loadFace(faceName);\\r\\n                    } else {\\r\\n                        if ($gameSystem.isSideView()) {\\r\\n                            var bitmap = ImageManager.loadSvEnemy(enemy_unit.battlerName(), enemy_unit.battlerHue());\\r\\n                        } else {\\r\\n                            var bitmap = ImageManager.loadEnemy(enemy_unit.battlerName(), enemy_unit.battlerHue());\\r\\n                        }\\r\\n                    }\\r\\n                    var oldValue = $gameVariables.value(_existEnemyVarID);\\r\\n                    $gameVariables.setValue(_existEnemyVarID, oldValue + 1);\\r\\n                    $gameSystem.setEventToUnit(event.eventId(), 'enemy', enemy_unit);\\r\\n\\t\\t\\t\\t\\t$statCalc.initSRWStats(enemy_unit);\\r\\n                }\\r\\n            }\\r\\n        });\\r\\n    };\\r\\n\\r\\n    //２イベント間の距離を返す\\r\\n    Game_System.prototype.unitDistance = function(event1, event2) {\\r\\n        var minDisX = Math.abs(event1.posX() - event2.posX());\\r\\n        var minDisY = Math.abs(event1.posY() - event2.posY());\\r\\n        if ($gameMap.isLoopHorizontal() == true) {\\r\\n            var event1X = event1.posX() > event2.posX() ? event1.posX() - $gameMap.width() : event1.posX() + $gameMap.width();\\r\\n            var disX = Math.abs(event1X - event2.posX());\\r\\n            minDisX = minDisX < disX ? minDisX : disX;\\r\\n        }\\r\\n        if ($gameMap.isLoopVertical() == true) {\\r\\n            var event1Y = event1.posY() > event2.posY() ? event1.posY() - $gameMap.height() : event1.posY() + $gameMap.height();\\r\\n            var disY = Math.abs(event1Y - event2.posY());\\r\\n            minDisY = minDisY < disY ? minDisY : disY;\\r\\n        }\\r\\n        return minDisX + minDisY;\\r\\n    };\\r\\n\\r\\n//戦闘終了に関係する処理\\r\\n    //戦闘終了するためのプラグイン・コマンド\\r\\n    Game_System.prototype.endSRPG = function() {\\r\\n        $gameTemp.clearActiveEvent();\\r\\n        $gameMap.events().forEach(function(event) {\\r\\n            var battlerArray = $gameSystem.EventToUnit(event.eventId());\\r\\n            if (battlerArray && (battlerArray[0] === 'actor' || battlerArray[0] === 'enemy')) {\\r\\n                if (_srpgBattleEndAllHeal == 'true') {\\r\\n                    battlerArray[1].recoverAll();\\r\\n                }\\r\\n                battlerArray[1].onTurnEnd();\\r\\n            }\\r\\n        });\\r\\n        this._SRPGMode = false;\\r\\n        $gameSwitches.setValue(_srpgBattleSwitchID, false);\\r\\n        this._isBattlePhase = 'initialize';\\r\\n        this._isSubBattlePhase = 'initialize';\\r\\n        $gamePlayer.refresh();\\r\\n        this.clearData(); //データの初期化\\r\\n        $gameMap.setEventImages();   // ユニットデータに合わせてイベントのグラフィックを変更する\\r\\n\\t\\t\\r\\n\\t\\t$gameTemp.updatePlayerSpriteVisibility();\\r\\n\\t\\tSceneManager._scene.createPauseWindow(); //ensure pause menu is updated to reflect the new mode\\r\\n    };\\r\\n\\r\\n//戦闘の進行に関係する処理\\r\\n    // 戦闘開始時のイベントを起動する\\r\\n    Game_System.prototype.runBattleStartEvent = function() {\\r\\n        $gameMap.events().forEach(function(event) {\\r\\n            if (event.isType() === 'battleStart') {\\r\\n                if (event.pageIndex() >= 0) event.start();\\r\\n                $gameTemp.pushSrpgEventList(event);\\r\\n            }\\r\\n        });\\r\\n    };\\r\\n\\t\\r\\n\\tGame_System.prototype.runAfterDeployEvent = function() {\\r\\n        $gameMap.events().forEach(function(event) {\\r\\n            if (event.isType() === 'afterDeploy') {\\r\\n                if (event.pageIndex() >= 0) event.start();\\r\\n                $gameTemp.pushSrpgEventList(event);\\r\\n            }\\r\\n        });\\r\\n    };\\r\\n\\r\\n    //次のカーソル移動先のアクターを取得する(R)\\r\\n    Game_System.prototype.getNextRActor = function() {\\r\\n        var candidates =  $statCalc.getAllCandidates(\\\"actor\\\");\\r\\n\\t\\tthis.actorLRId++;\\r\\n\\t\\tif(this.actorLRId >= candidates.length){\\r\\n\\t\\t\\tthis.actorLRId = 0;\\r\\n\\t\\t}\\r\\n       \\tvar candidate = candidates[this.actorLRId];\\r\\n\\t\\tif(candidate){\\r\\n\\t\\t\\t$gamePlayer.locate(candidate.pos.x, candidate.pos.y);\\r\\n\\t\\t}  \\r\\n    }\\r\\n\\r\\n    //次のカーソル移動先のアクターを取得する(L)\\r\\n    Game_System.prototype.getNextLActor = function() {       \\r\\n\\t\\tvar candidates =  $statCalc.getAllCandidates(\\\"actor\\\");\\r\\n\\t\\tthis.actorLRId--;\\r\\n\\t\\tif(this.actorLRId < 0){\\r\\n\\t\\t\\tthis.actorLRId = candidates.length-1;\\r\\n\\t\\t}\\r\\n       \\tvar candidate = candidates[this.actorLRId];\\r\\n\\t\\tif(candidate){\\r\\n\\t\\t\\t$gamePlayer.locate(candidate.pos.x, candidate.pos.y);\\r\\n\\t\\t}        \\r\\n    }\\r\\n\\t\\r\\n\\tGame_System.prototype.isValidAttackTarget = function(candidate){\\r\\n\\t\\tvar actionBattlerArray = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId());\\r\\n\\t\\tvar targetBattlerArray = $gameSystem.EventToUnit(candidate.event.eventId());\\r\\n\\t   \\r\\n\\t\\tvar isInRange = $battleCalc.isTargetInRange({x: $gameTemp.activeEvent()._x, y: $gameTemp.activeEvent()._y}, {x: candidate.event.posX(), y: candidate.event.posY()}, $statCalc.getRealWeaponRange(actionBattlerArray[1], $gameTemp.actorAction.attack), $gameTemp.actorAction.attack.minRange);\\r\\n\\t\\tvar validTarget = $statCalc.canUseWeapon(actionBattlerArray[1], $gameTemp.actorAction.attack, false, targetBattlerArray[1]);\\r\\n\\t\\t\\r\\n\\t\\treturn isInRange && validTarget;\\r\\n\\t}                               \\r\\n\\t\\r\\n\\tGame_System.prototype.getNextRTarget = function() {\\r\\n        var candidates =  $statCalc.getAllCandidates(\\\"enemy\\\");\\r\\n\\t\\tvar candidate;\\r\\n\\t\\tvar ctr = 0;\\r\\n\\t\\twhile(ctr < candidates.length && !candidate){\\r\\n\\t\\t\\tthis.targetLRId++;\\r\\n\\t\\t\\tif(this.targetLRId >= candidates.length){\\r\\n\\t\\t\\t\\tthis.targetLRId = 0;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(this.isValidAttackTarget(candidates[this.targetLRId])){\\r\\n\\t\\t\\t\\tcandidate = candidates[this.targetLRId];\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\tctr++;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif(candidate){\\r\\n\\t\\t\\t$gamePlayer.locate(candidate.pos.x, candidate.pos.y);\\r\\n\\t\\t}  \\r\\n    }\\r\\n\\r\\n    //次のカーソル移動先のアクターを取得する(L)\\r\\n    Game_System.prototype.getNextLTarget = function() {       \\r\\n\\t\\tvar candidates =  $statCalc.getAllCandidates(\\\"enemy\\\");\\r\\n\\t\\tvar candidate;\\r\\n\\t\\tvar ctr = 0;\\r\\n\\t\\twhile(ctr < candidates.length && !candidate){\\r\\n\\t\\t\\tthis.targetLRId--;\\r\\n\\t\\t\\tif(this.targetLRId < 0){\\r\\n\\t\\t\\t\\tthis.targetLRId = candidates.length-1;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(this.isValidAttackTarget(candidates[this.targetLRId])){\\r\\n\\t\\t\\t\\tcandidate = candidates[this.targetLRId];\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\tctr++;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif(candidate){\\r\\n\\t\\t\\t$gamePlayer.locate(candidate.pos.x, candidate.pos.y);\\r\\n\\t\\t}  \\t\\t\\r\\n    }\\r\\n\\r\\n    //アクターターンの開始\\r\\n    Game_System.prototype.srpgStartActorTurn = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\t$statCalc.invalidateAbilityCache();\\r\\n\\t\\t\\r\\n\\t\\t$gameTemp.currentFaction = -1;\\r\\n\\t\\t$songManager.playStageSong();\\r\\n        this.aliveActorIdList = [];\\r\\n        this.actorLRId = 0;\\r\\n\\t\\tthis.targetLRId = 0;\\r\\n\\t\\tvar spiritActivations = [];\\r\\n\\t\\tvar AIActors = [];\\r\\n        $gameMap.events().forEach(function(event) {\\r\\n            if (event.isType() === 'actorTurn') {\\r\\n                if (event.pageIndex() >= 0) event.start();\\r\\n                $gameTemp.pushSrpgEventList(event);\\r\\n            }\\r\\n            var battlerArray = $gameSystem.EventToUnit(event.eventId());\\r\\n            if (battlerArray && battlerArray[0] === 'actor' && battlerArray[1].isAlive() && !event.isErased()) {\\r\\n                $gameSystem.aliveActorIdList.push(event.eventId());\\r\\n                battlerArray[1].SRPGActionTimesSet($statCalc.applyStatModsToValue(battlerArray[1], 1, [\\\"extra_action\\\"]));\\r\\n\\t\\t\\t\\tvar SPRegen = 0;\\r\\n\\t\\t\\t\\tSPRegen = $statCalc.applyStatModsToValue(battlerArray[1], SPRegen, [\\\"SP_regen\\\"]);\\r\\n\\t\\t\\t\\tif(ENGINE_SETTINGS.VXT_SP){\\r\\n\\t\\t\\t\\t\\tSPRegen+=5;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(ENGINE_SETTINGS.DEFAULT_SP_REGEN){\\r\\n\\t\\t\\t\\t\\tSPRegen+=ENGINE_SETTINGS.DEFAULT_SP_REGEN;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif($gameVariables.value(_turnVarID) != 1){\\r\\n\\t\\t\\t\\t\\t$statCalc.recoverSP(battlerArray[1], SPRegen);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tvar autoSpirits = $statCalc.getModDefinitions(battlerArray[1], [\\\"auto_spirit\\\"]);\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tautoSpirits.forEach(function(autoSpirit){\\t\\t\\r\\n\\t\\t\\t\\t\\t$statCalc.setAbilityUsed(battlerArray[1], \\\"auto_spirit_\\\"+autoSpirit.stackId);\\r\\n\\t\\t\\t\\t\\tspiritActivations.push({actor: battlerArray[1], spirit: autoSpirit.value});\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t});\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tif($statCalc.isAI(battlerArray[1])){\\r\\n\\t\\t\\t\\t\\tAIActors.push(event);\\r\\n\\t\\t\\t\\t}\\r\\n            }\\r\\n            if (battlerArray && battlerArray[0] === 'enemy' && battlerArray[1].isAlive()) {\\r\\n                battlerArray[1].SRPGActionTimesSet(1);\\r\\n            }\\r\\n\\t\\t\\t\\r\\n        });\\r\\n\\t\\t$statCalc.clearSpiritOnAll(\\\"actor\\\", \\\"strike\\\");\\r\\n\\t\\t$statCalc.clearSpiritOnAll(\\\"actor\\\", \\\"wall\\\");\\r\\n\\t\\t$statCalc.clearSpiritOnAll(\\\"actor\\\", \\\"focus\\\");\\r\\n\\t\\t$statCalc.clearSpiritOnAll(\\\"enemy\\\", \\\"disrupt\\\");\\r\\n\\t\\t$statCalc.clearSpiritOnAll(\\\"enemy\\\", \\\"analyse\\\");\\r\\n\\t\\t$statCalc.clearTempEffectOnAll(\\\"actor\\\", \\\"victory_turn\\\");\\r\\n\\t\\t$statCalc.resetAllBattleTemp();\\r\\n\\t\\t$statCalc.resetAllStatus(\\\"enemy\\\");\\r\\n\\t\\tif($gameVariables.value(_turnVarID) != 1){\\r\\n\\t\\t\\t$statCalc.applyTurnStartWill(\\\"actor\\\");\\r\\n\\t\\t}\\r\\n\\t\\t$statCalc.applyENRegen(\\\"actor\\\");\\r\\n\\t\\t$statCalc.applyAmmoRegen(\\\"actor\\\");\\r\\n\\t\\t$statCalc.applyHPRegen(\\\"actor\\\");\\r\\n        this.aliveActorIdList.sort(function(a, b) {\\r\\n            return a - b;\\r\\n        });\\r\\n        var actor1 = $gameMap.event(this.aliveActorIdList[0]);\\r\\n        if (actor1) {\\r\\n\\t\\t\\t$gamePlayer.locate(actor1.posX(), actor1.posY());\\r\\n        }\\r\\n\\t\\t$gameTemp.autoSpirits = spiritActivations;\\r\\n\\t\\t$gameTemp.autoSpiritsDelay = 150;\\r\\n\\t\\t\\r\\n\\t\\t_this.setBattlePhase('actor_phase');\\r\\n\\t\\t\\r\\n\\t\\t$gameTemp.AIActors = AIActors;\\r\\n\\t\\tif(spiritActivations.length){\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t_this.setSubBattlePhase('auto_spirits');\\r\\n\\t\\t} else if($gameTemp.AIActors.length){\\r\\n\\t\\t\\t_this.setBattlePhase('AI_phase');\\r\\n\\t\\t\\t_this.setSubBattlePhase('enemy_command');\\r\\n\\t\\t} else {\\t\\t\\t\\r\\n\\t\\t\\t_this.setSubBattlePhase('initialize');\\r\\n\\t\\t}\\t\\r\\n    };\\r\\n\\r\\n    //自動行動アクターターンの開始\\r\\n    Game_System.prototype.srpgStartAutoActorTurn = function() {\\r\\n        this.setBattlePhase('auto_actor_phase');\\r\\n        this.setSubBattlePhase('auto_actor_command');\\r\\n    };\\r\\n\\r\\n    //エネミーターンの開始\\r\\n    Game_System.prototype.srpgStartEnemyTurn = function(factionId) {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\t$statCalc.invalidateAbilityCache();\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\t$gameTemp.showAllyAttackIndicator = false;\\r\\n\\t\\t$gameTemp.showAllyDefendIndicator = false;\\r\\n\\t\\t$gameTemp.showEnemyAttackIndicator = false;\\r\\n\\t\\t$gameTemp.showEnemyDefendIndicator = false;\\r\\n\\t\\t$gameTemp.currentFaction = factionId;\\r\\n\\t\\tif(factionId > 2){\\r\\n\\t\\t\\t$gameSystem.srpgTurnEnd();\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif(!$gameSystem.factionConfig[factionId].active){\\r\\n\\t\\t\\t$gameTemp.currentFaction++;\\r\\n\\t\\t\\tthis.srpgStartEnemyTurn($gameTemp.currentFaction);\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\t$songManager.playStageSong();\\r\\n\\t\\tvar spiritActivations = [];\\r\\n\\t\\t$gameTemp.AIActors = [];\\r\\n        $gameMap.events().forEach(function(event) {\\r\\n            if (event.isType() === 'enemyTurn') {\\r\\n                if (event.pageIndex() >= 0) event.start();\\r\\n                $gameTemp.pushSrpgEventList(event);\\r\\n            }\\r\\n\\t\\t\\tvar battlerArray = $gameSystem.EventToUnit(event.eventId());\\r\\n\\t\\t\\tif (battlerArray && battlerArray[0] === 'enemy' && battlerArray[1].isAlive()) {\\r\\n                battlerArray[1].SRPGActionTimesSet($statCalc.applyStatModsToValue(battlerArray[1], 1, [\\\"extra_action\\\"]));\\r\\n\\t\\t\\t\\tvar SPRegen = 0;\\r\\n\\t\\t\\t\\tSPRegen = $statCalc.applyStatModsToValue(battlerArray[1], SPRegen, [\\\"SP_regen\\\"]);\\r\\n\\t\\t\\t\\t$statCalc.recoverSP(battlerArray[1], SPRegen);\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t$gameTemp.AIActors.push(event);\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tvar autoSpirits = $statCalc.getModDefinitions(battlerArray[1], [\\\"auto_spirit\\\"]);\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tautoSpirits.forEach(function(autoSpirit){\\t\\r\\n\\t\\t\\t\\t\\t$statCalc.setAbilityUsed(actor, \\\"auto_spirit_\\\"+autoSpirit.stackId);\\r\\n\\t\\t\\t\\t\\tspiritActivations.push({actor: battlerArray[1], spirit: autoSpirit.value});\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t});\\t\\r\\n            }\\r\\n        });\\r\\n\\t\\t\\r\\n\\t\\t$statCalc.clearSpiritOnAll(\\\"enemy\\\", \\\"strike\\\", factionId);\\r\\n\\t\\t$statCalc.clearSpiritOnAll(\\\"enemy\\\", \\\"wall\\\", factionId);\\r\\n\\t\\t$statCalc.clearSpiritOnAll(\\\"enemy\\\", \\\"focus\\\", factionId);\\r\\n\\t\\t$statCalc.clearSpiritOnAll(\\\"actor\\\", \\\"disrupt\\\");\\r\\n\\t\\t$statCalc.clearSpiritOnAll(\\\"actor\\\", \\\"analyse\\\");\\r\\n\\t\\t$statCalc.applyTurnStartWill(\\\"enemy\\\", factionId);\\r\\n\\t\\t$statCalc.applyENRegen(\\\"enemy\\\", factionId);\\r\\n\\t\\t$statCalc.applyAmmoRegen(\\\"enemy\\\", factionId);\\r\\n\\t\\t$statCalc.applyHPRegen(\\\"enemy\\\", factionId);\\r\\n\\t\\t$statCalc.resetAllBattleTemp(null, factionId);\\r\\n\\t\\t$statCalc.resetAllStatus(\\\"actor\\\");\\r\\n\\t\\t$gameTemp.AIWaitTimer = 0;\\r\\n\\t\\t\\r\\n\\t\\t$gameTemp.autoSpirits = spiritActivations;\\r\\n\\t\\t$gameTemp.autoSpiritsDelay = 150;\\r\\n\\t\\t\\r\\n\\t\\tif(spiritActivations.length){\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t_this.setSubBattlePhase('auto_spirits');\\r\\n\\t\\t} //else if($gameTemp.AIActors.length){\\r\\n\\t\\t\\t_this.setBattlePhase('AI_phase');\\r\\n\\t\\t\\t_this.setSubBattlePhase('enemy_command');\\r\\n\\t\\t//}\\r\\n\\t\\t\\r\\n        //this.setSubBattlePhase('enemy_command');\\r\\n    };\\r\\n\\r\\n    //ターン終了\\r\\n    Game_System.prototype.srpgTurnEnd = function() {\\r\\n        $gameMap.events().forEach(function(event) {\\r\\n            var battlerArray = $gameSystem.EventToUnit(event.eventId());\\r\\n            if (battlerArray && (battlerArray[0] === 'actor' || battlerArray[0] === 'enemy')) {\\r\\n                battlerArray[1].onTurnEnd();\\r\\n            }\\r\\n        });\\r\\n        $gameMap.events().forEach(function(event) {\\r\\n            if (event.isType() === 'turnEnd') {\\r\\n                if (event.pageIndex() >= 0) event.start();\\r\\n                $gameTemp.pushSrpgEventList(event);\\r\\n            }\\r\\n        });\\r\\n        this.srpgTurnPlus();\\r\\n        this.srpgStartActorTurn();//アクターターンを開始する\\r\\n    };\\r\\n\\r\\n    //ターン数を増やす\\r\\n    Game_System.prototype.srpgTurnPlus = function() {\\r\\n        var oldValue = $gameVariables.value(_turnVarID);\\r\\n        $gameVariables.setValue(_turnVarID, oldValue + 1);\\r\\n\\t\\t\\r\\n\\t\\tvar oldValue = $gameVariables.value(_turnCountVariable);\\r\\n        $gameVariables.setValue(_turnCountVariable, oldValue + 1);\\r\\n    };\\r\\n\\r\\n//戦闘の計算に関係する処理\\r\\n    // 移動範囲および攻撃範囲を計算・表示する\\r\\n    Game_System.prototype.srpgMakeMoveTable = function(event) {\\r\\n        var battlerArray = $gameSystem.EventToUnit(event.eventId());\\r\\n\\t\\t\\r\\n\\t\\tvar moveRange = $statCalc.getCurrentMoveRange(battlerArray[1]);\\r\\n        $gameTemp.clearMoveTable();\\r\\n        $gameTemp.initialMoveTable(event.posX(), event.posY(), battlerArray[1].srpgThroughTag());\\r\\n        event.makeMoveTable(event.posX(), event.posY(), moveRange, [0], battlerArray[1]);\\r\\n        var list = $gameTemp.moveList();\\r\\n\\t\\t\\r\\n        $gameTemp.pushRangeListToMoveList();\\r\\n    };\\r\\n\\r\\n    //移動先にアクターまたはエネミーがいる場合は移動できない（重なりを避ける）\\r\\n    Game_System.prototype.areTheyNoUnits = function(x, y, type) {\\r\\n        var flag = true;\\r\\n        $gameMap.eventsXy(x, y).forEach(function(event) {\\r\\n            var battlerArray = $gameSystem.EventToUnit(event._eventId);\\r\\n            if (battlerArray && event != $gameTemp.activeEvent() && !event.isErased() &&\\r\\n                battlerArray[0] === type || event.isType() === 'playerEvent') {\\r\\n                flag = false;\\r\\n            }\\r\\n        });\\r\\n        return flag;\\r\\n    };\\r\\n\\r\\n    //移動先にイベントユニットがあるかどうか\\r\\n    Game_System.prototype.isThereEventUnit = function(x, y) {\\r\\n        var flag = false;\\r\\n        $gameMap.eventsXy(x, y).forEach(function(event) {\\r\\n            if (event.isType() === 'unitEvent') {\\r\\n                flag = true;\\r\\n            }\\r\\n        });\\r\\n        return flag;\\r\\n    };\\r\\n\\t\\r\\n\\tGame_System.prototype.getTwinInfo = function() {\\r\\n\\t\\tif(!$gameSystem.twinInfo){\\r\\n\\t\\t\\t$gameSystem.twinInfo = {};\\r\\n\\t\\t} \\r\\n\\t\\treturn $gameSystem.twinInfo;\\r\\n    };\\r\\n\\t\\r\\n\\tGame_System.prototype.getIsTwinInfo = function() {\\r\\n\\t\\tif(!$gameSystem.isTwinInfo){\\r\\n\\t\\t\\t$gameSystem.isTwinInfo = {};\\r\\n\\t\\t} \\r\\n\\t\\treturn $gameSystem.isTwinInfo;\\r\\n    };\\r\\n\\t\\r\\n\\tGame_System.prototype.getPreferredSlotInfo = function() {\\r\\n\\t\\tif(!this.preferredSlotInfo){\\r\\n\\t\\t\\tthis.preferredSlotInfo = {};\\r\\n\\t\\t} \\r\\n\\t\\treturn this.preferredSlotInfo;\\r\\n    };\\r\\n\\t\\r\\n\\tGame_System.prototype.getPreferredShipSlotInfo = function() {\\r\\n\\t\\tif(!this.preferredShipSlotInfo){\\r\\n\\t\\t\\tthis.preferredShipSlotInfo = {};\\r\\n\\t\\t} \\r\\n\\t\\treturn this.preferredShipSlotInfo;\\r\\n    };\\r\\n\\t\\r\\n\\tGame_System.prototype.invalidateDeployList = function() {\\r\\n\\t\\t$gameSystem.deployList = null;\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.getDeployList = function() {\\r\\n\\t\\tif(!$gameSystem.deployList){\\r\\n\\t\\t\\tthis.constructDeployList();\\r\\n\\t\\t}\\r\\n\\t\\treturn $gameSystem.deployList;\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.getShipDeployList = function() {\\r\\n\\t\\tif(!$gameSystem.shipDeployList){\\r\\n\\t\\t\\tthis.constructShipDeployList();\\r\\n\\t\\t}\\r\\n\\t\\treturn $gameSystem.shipDeployList;\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.getActiveDeployList = function() {\\r\\n\\t\\treturn this._activeDeploylist;\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.setActiveDeployList = function(list) {\\r\\n\\t\\tthis._activeDeploylist = list;\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.getActiveShipDeployList = function() {\\r\\n\\t\\treturn this._activeShipDeploylist;\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.setActiveShipDeployList = function(list) {\\r\\n\\t\\tthis._activeShipDeploylist = list;\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.constructDeployList = function(forShips) {\\r\\n\\t\\t$gameSystem.deployList = [];\\r\\n\\t\\tvar deployInfo = this.getDeployInfo();\\r\\n\\t\\tvar usedUnits = {};\\r\\n\\t\\tvar slotLookup = {};\\r\\n\\t\\t\\r\\n\\t\\tvar validActors = {};\\r\\n\\t\\tvar candidates = $gameSystem.getAvailableUnits();\\t\\r\\n\\t\\tvar tmp = [];\\r\\n\\t\\tcandidates.forEach(function(candidate){\\r\\n\\t\\t\\tif($statCalc.isValidForDeploy(candidate) && !$statCalc.isShip(candidate)){\\r\\n\\t\\t\\t\\tvalidActors[candidate.actorId()] = true;\\r\\n\\t\\t\\t\\ttmp.push(candidate);\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\t\\r\\n\\t\\tcandidates = tmp;\\r\\n\\t\\t\\r\\n\\t\\tvar sortedCandidates = [];\\r\\n\\t\\tvar usedActors = {};\\r\\n\\t\\tvar preferredSlotInfo = this.getPreferredSlotInfo();\\r\\n\\t\\tObject.keys(preferredSlotInfo).forEach(function(slot){\\r\\n\\t\\t\\tvar info = preferredSlotInfo[slot];\\t\\t\\t\\r\\n\\t\\t\\tvar entry = {\\r\\n\\t\\t\\t\\tmain: null,\\r\\n\\t\\t\\t\\tsub: null\\r\\n\\t\\t\\t};\\r\\n\\t\\t\\tisValid = false;\\r\\n\\t\\t\\tif(info.main != -1 && validActors[info.main]){\\r\\n\\t\\t\\t\\tentry.main = info.main;\\r\\n\\t\\t\\t\\tisValid = true;\\r\\n\\t\\t\\t\\tusedActors[entry.main] = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(info.sub != -1 && validActors[info.sub]){\\r\\n\\t\\t\\t\\tentry.sub = info.sub;\\r\\n\\t\\t\\t\\tisValid = true;\\r\\n\\t\\t\\t\\tusedActors[entry.sub] = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(isValid){\\r\\n\\t\\t\\t\\tsortedCandidates.push(entry);\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\t\\r\\n\\t\\ttmp.forEach(function(candidate){\\r\\n\\t\\t\\tif(!usedActors[candidate.actorId()]){\\r\\n\\t\\t\\t\\tsortedCandidates.push({\\r\\n\\t\\t\\t\\t\\tmain: candidate.actorId(),\\r\\n\\t\\t\\t\\t\\tsub: null\\r\\n\\t\\t\\t\\t});\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\t\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tvar i = 0;\\r\\n\\t\\twhile(sortedCandidates.length){\\t\\r\\n\\t\\t\\tvar entry = {};\\r\\n\\t\\t\\tif(i < deployInfo.count){\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tvar isPredefined = false;\\r\\n\\t\\t\\t\\tif(deployInfo.assigned[i] && validActors[deployInfo.assigned[i]]){\\r\\n\\t\\t\\t\\t\\tentry.main = deployInfo.assigned[i];\\r\\n\\t\\t\\t\\t\\tisPredefined = true;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(deployInfo.assignedSub[i] && validActors[deployInfo.assigned[i]]){\\r\\n\\t\\t\\t\\t\\tentry.sub = deployInfo.assignedSub[i];\\r\\n\\t\\t\\t\\t\\tisPredefined = true;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(!isPredefined){\\r\\n\\t\\t\\t\\t\\tentry = sortedCandidates.pop();\\r\\n\\t\\t\\t\\t} \\t\\t\\t\\t\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tentry = sortedCandidates.pop();\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(usedUnits[entry.main]){\\r\\n\\t\\t\\t\\tentry.main = null;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(usedUnits[entry.sub]){\\r\\n\\t\\t\\t\\tentry.sub = null;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(entry.main || entry.sub){\\r\\n\\t\\t\\t\\t$gameSystem.deployList.push(entry);\\t\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tusedUnits[entry.main] = true;\\r\\n\\t\\t\\t\\tusedUnits[entry.sub] = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\ti++;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.constructShipDeployList = function() {\\r\\n\\t\\t$gameSystem.shipDeployList = [];\\r\\n\\t\\tvar deployInfo = this.getDeployInfo();\\r\\n\\t\\tvar usedUnits = {};\\r\\n\\t\\t\\r\\n\\t\\tvar validActors = {};\\r\\n\\t\\tvar candidates = $gameSystem.getAvailableUnits();\\t\\r\\n\\t\\tvar tmp = [];\\r\\n\\t\\tcandidates.forEach(function(candidate){\\r\\n\\t\\t\\tif($statCalc.isValidForDeploy(candidate) && $statCalc.isShip(candidate)){\\r\\n\\t\\t\\t\\tvalidActors[candidate.actorId()] = true;\\r\\n\\t\\t\\t\\ttmp.push(candidate);\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\t\\r\\n\\t\\tcandidates = tmp;\\r\\n\\t\\t\\r\\n\\t\\tvar sortedCandidates = [];\\r\\n\\t\\tvar usedActors = {};\\r\\n\\t\\tvar preferredSlotInfo = this.getPreferredShipSlotInfo();\\r\\n\\t\\tObject.keys(preferredSlotInfo).forEach(function(slot){\\r\\n\\t\\t\\tvar info = preferredSlotInfo[slot];\\t\\t\\t\\r\\n\\t\\t\\tvar entry = {\\r\\n\\t\\t\\t\\tmain: null,\\r\\n\\t\\t\\t\\tsub: null\\r\\n\\t\\t\\t};\\r\\n\\t\\t\\tisValid = false;\\r\\n\\t\\t\\tif(info.main != -1 && validActors[info.main]){\\r\\n\\t\\t\\t\\tentry.main = info.main;\\r\\n\\t\\t\\t\\tisValid = true;\\r\\n\\t\\t\\t\\tusedActors[entry.main] = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(isValid){\\r\\n\\t\\t\\t\\tsortedCandidates.push(entry);\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\t\\r\\n\\t\\ttmp.forEach(function(candidate){\\r\\n\\t\\t\\tif(!usedActors[candidate.actorId()]){\\r\\n\\t\\t\\t\\tsortedCandidates.push({\\r\\n\\t\\t\\t\\t\\tmain: candidate.actorId(),\\r\\n\\t\\t\\t\\t\\tsub: null\\r\\n\\t\\t\\t\\t});\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\t\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tvar i = 0;\\r\\n\\t\\twhile(sortedCandidates.length){\\t\\r\\n\\t\\t\\tvar entry = {};\\r\\n\\t\\t\\tif(i < deployInfo.shipCount){\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tvar isPredefined = false;\\r\\n\\t\\t\\t\\tif(deployInfo.assignedShips[i] && validActors[deployInfo.assignedShips[i]]){\\r\\n\\t\\t\\t\\t\\tentry.main = deployInfo.assignedShips[i];\\r\\n\\t\\t\\t\\t\\tisPredefined = true;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(!isPredefined){\\r\\n\\t\\t\\t\\t\\tentry = sortedCandidates.pop();\\r\\n\\t\\t\\t\\t} \\t\\t\\t\\t\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tentry = sortedCandidates.pop();\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(usedUnits[entry.main]){\\r\\n\\t\\t\\t\\tentry.main = null;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(usedUnits[entry.sub]){\\r\\n\\t\\t\\t\\tentry.sub = null;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(entry.main || entry.sub){\\r\\n\\t\\t\\t\\t$gameSystem.shipDeployList.push(entry);\\t\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tusedUnits[entry.main] = true;\\r\\n\\t\\t\\t\\tusedUnits[entry.sub] = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\ti++;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.syncPreferredSlots = function() {\\r\\n\\t\\tvar deployInfo = this.getDeployList();\\r\\n\\t\\tthis.preferredSlotInfo = {};\\r\\n\\t\\tfor(var i = 0; i < deployInfo.length; i++){\\r\\n\\t\\t\\tthis.preferredSlotInfo[i] = deployInfo[i];\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.getDeployInfo = function() {\\r\\n\\t\\tvar info = $gameVariables.value(_nextMapDeployVariable);\\r\\n\\t\\tif(!info){\\r\\n\\t\\t\\tinfo = {\\r\\n\\t\\t\\t\\tcount: 0,\\r\\n\\t\\t\\t\\tshipCount: 0,\\r\\n\\t\\t\\t\\tassigned: {},\\r\\n\\t\\t\\t\\tassignedSub: {},\\r\\n\\t\\t\\t\\tassignedShips: {},\\r\\n\\t\\t\\t\\tlockedSlots: {},\\t\\t\\r\\n\\t\\t\\t\\tlockedShipSlots: {},\\t\\r\\n\\t\\t\\t\\tfavorites: {}\\r\\n\\t\\t\\t};\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tinfo = JSON.parse(info);\\r\\n\\t\\t}\\r\\n\\t\\treturn info;\\r\\n    };\\r\\n\\t\\r\\n\\tGame_System.prototype.setDeployInfo = function(info) {\\r\\n\\t\\tthis.invalidateDeployList();\\r\\n\\t\\t$gameVariables.setValue(_nextMapDeployVariable, JSON.stringify(info));\\r\\n    };\\r\\n\\t\\r\\n\\tGame_System.prototype.clearActorDeployInfo = function(actorId) {\\r\\n\\t\\tvar deployInfo = this.getDeployInfo();\\r\\n\\t\\tObject.keys(deployInfo.assigned).forEach(function(slot){\\r\\n\\t\\t\\tif(deployInfo.assigned[slot] == actorId){\\r\\n\\t\\t\\t\\tdelete deployInfo.assigned[slot];\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\tthis.setDeployInfo(deployInfo);\\r\\n    };\\r\\n\\t\\r\\n\\tGame_System.prototype.getPersuadeOption = function(actor) {\\r\\n\\t\\tif(this.persuadeOptions && actor.isActor()){\\r\\n\\t\\t\\tvar lookup = this.persuadeOptions[actor.actorId()];\\r\\n\\t\\t\\tif(lookup){\\r\\n\\t\\t\\t\\tvar event = actor.event;\\r\\n\\t\\t\\t\\tvar position = {x: event.posX(), y: event.posY()};\\r\\n\\t\\t\\t\\tvar adjacentEvents = $statCalc.getAdjacentEvents(null, position);\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tvar option;\\r\\n\\t\\t\\t\\tvar ctr = 0;\\r\\n\\t\\t\\t\\twhile(!option && ctr < adjacentEvents.length){\\r\\n\\t\\t\\t\\t\\tvar eventId = adjacentEvents[ctr].eventId();\\r\\n\\t\\t\\t\\t\\tif(lookup[eventId] != null){\\r\\n\\t\\t\\t\\t\\t\\toption = {eventId: eventId, controlVar: lookup[eventId]};\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tctr++;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\treturn option;\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t} \\r\\n\\t\\treturn null;\\t\\t\\r\\n    };\\r\\n\\t\\r\\n\\tGame_System.prototype.getUnitSceneBgId = function(actor) {\\r\\n\\t\\tif($gameTemp.editMode){\\r\\n\\t\\t\\treturn $SRWEditor.getBattleEnvironmentId();\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tvar event = $statCalc.getReferenceEvent(actor);\\r\\n\\t\\t\\tvar region = $gameMap.regionId(event.posX(), event.posY());\\r\\n\\t\\t\\tif($statCalc.isFlying(actor)){\\r\\n\\t\\t\\t\\tif($gameSystem.regionSkyBattleEnv[region] != null){\\r\\n\\t\\t\\t\\t\\treturn $gameSystem.regionSkyBattleEnv[region];\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tif($gameSystem.skyBattleEnv){\\r\\n\\t\\t\\t\\t\\treturn $gameSystem.skyBattleEnv;\\r\\n\\t\\t\\t\\t} \\r\\n\\t\\t\\t} \\r\\n\\t\\t\\tif($gameSystem.regionBattleEnv[region] != null){\\r\\n\\t\\t\\t\\treturn $gameSystem.regionBattleEnv[region];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn $gameSystem.defaultBattleEnv;\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t}\\r\\n    };\\r\\n\\t\\r\\n\\tGame_System.prototype.validateAbilityLockInfo = function(actorId, abilityId) {\\r\\n\\t\\tif(!this.abilityLockInfo){\\r\\n\\t\\t\\tthis.abilityLockInfo = {\\r\\n\\t\\t\\t\\tactor: {},\\r\\n\\t\\t\\t\\tmech: {}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.setAbilityStatus = function(abilityInfo, id, abilityId, status) {\\r\\n\\t\\t//status: hidden, locked, \\\"\\\"\\r\\n\\t\\tif(!abilityInfo[id]){\\r\\n\\t\\t\\tabilityInfo[id] = {};\\r\\n\\t\\t}\\r\\n\\t\\tabilityInfo[id][abilityId] = status;\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.getAbilityStatus = function(abilityInfo, id, abilityId) {\\r\\n\\t\\t//status: hidden, locked, \\\"\\\"\\t\\t\\r\\n\\t\\tvar result = \\\"\\\";\\r\\n\\t\\tif(abilityInfo[id] && abilityInfo[id][abilityId]){\\r\\n\\t\\t\\tresult = abilityInfo[id][abilityId];\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\treturn result;\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.setPilotAbilityStatus = function(actorId, abilityId, status) {\\t\\t\\r\\n\\t\\tthis.validateAbilityLockInfo();\\r\\n\\t\\tthis.setAbilityStatus(this.abilityLockInfo.actor, actorId, abilityId, status);\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.getPilotAbilityStatus = function(actorId, abilityId) {\\t\\r\\n\\t\\tthis.validateAbilityLockInfo();\\r\\n\\t\\treturn this.getAbilityStatus(this.abilityLockInfo.actor, actorId, abilityId);\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.isHiddenActorAbility = function(actor, abilityId) {\\r\\n\\t\\tvar result = false;\\r\\n\\t\\tif(actor.isActor()){\\r\\n\\t\\t\\tvar status = this.getPilotAbilityStatus(actor.actorId(), abilityId);\\r\\n\\t\\t\\tresult = status == \\\"hidden\\\" || status == \\\"locked\\\";\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\treturn result;\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.isLockedActorAbility = function(actor, abilityId) {\\r\\n\\t\\tvar result = false;\\r\\n\\t\\tif(actor.isActor()){\\r\\n\\t\\t\\tvar status = this.getPilotAbilityStatus(actor.actorId(), abilityId);\\r\\n\\t\\t\\tresult = status == \\\"locked\\\";\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\treturn result;\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.setMechAbilityStatus = function(mechId, abilityId, status) {\\t\\t\\r\\n\\t\\tthis.validateAbilityLockInfo();\\r\\n\\t\\tthis.setAbilityStatus(this.abilityLockInfo.mech, mechId, abilityId, status);\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.getMechAbilityStatus = function(mechId, abilityId) {\\t\\r\\n\\t\\tthis.validateAbilityLockInfo();\\r\\n\\t\\treturn this.getAbilityStatus(this.abilityLockInfo.mech, mechId, abilityId);\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.isHiddenMechAbility = function(actor, abilityId) {\\r\\n\\t\\tvar result = false;\\r\\n\\t\\tif(actor.SRWStats && actor.SRWStats.mech){\\r\\n\\t\\t\\tvar status = this.getMechAbilityStatus(actor.SRWStats.mech.id, abilityId);\\r\\n\\t\\t\\tresult = status == \\\"hidden\\\" || status == \\\"locked\\\";\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\treturn result;\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.isLockedMechAbility = function(actor, abilityId) {\\r\\n\\t\\tvar result = false;\\r\\n\\t\\tif(actor.SRWStats && actor.SRWStats.mech){\\r\\n\\t\\t\\tvar status = this.getMechAbilityStatus(actor.SRWStats.mech.id, abilityId);\\r\\n\\t\\t\\tresult = status == \\\"locked\\\";\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\treturn result;\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.validateTransformationLockInfo = function() {\\r\\n\\t\\tif(!this.transformationLockInfo){\\r\\n\\t\\t\\tthis.transformationLockInfo = {}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.isTransformationLocked = function(mechId, index) {\\r\\n\\t\\tthis.validateTransformationLockInfo();\\r\\n\\t\\tif(this.transformationLockInfo[mechId]){\\r\\n\\t\\t\\treturn this.transformationLockInfo[mechId][index];\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\t\\t\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.lockTransformation = function(mechId, index) {\\r\\n\\t\\tthis.validateTransformationLockInfo();\\r\\n\\t\\tif(!this.transformationLockInfo[mechId]){\\r\\n\\t\\t\\tthis.transformationLockInfo[mechId] = {};\\r\\n\\t\\t}\\r\\n\\t\\tthis.transformationLockInfo[mechId][index] = true;\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.lockAllTransformations = function() {\\r\\n\\t\\tthis.validateTransformationLockInfo();\\r\\n\\t\\tfor(var i = 1; i < $dataClasses.length; i++){\\r\\n\\t\\t\\tvar mechProperties = $dataClasses[i].meta;\\r\\n\\t\\t\\tvar transformsInto;\\r\\n\\t\\t\\ttransformsInto = mechProperties.mechTransformsInto * 1 || -1;\\t\\r\\n\\t\\t\\tif(transformsInto == -1 && mechProperties.mechTransformsInto != null){\\r\\n\\t\\t\\t\\ttry {\\r\\n\\t\\t\\t\\t\\ttransformsInto = JSON.parse(mechProperties.mechTransformsInto);\\r\\n\\t\\t\\t\\t} catch(e){\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif(transformsInto && transformsInto != -1){\\r\\n\\t\\t\\t\\tif(!Array.isArray(transformsInto)){\\r\\n\\t\\t\\t\\t\\ttransformsInto = [transformsInto];\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\ttransformsInto = [];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthis.transformationLockInfo[i] = {};\\r\\n\\t\\t\\tfor(var j = 0; j < transformsInto.length; j++){\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tthis.transformationLockInfo[i][j] = true;\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}\\t\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.unlockTransformation = function(mechId, index) {\\r\\n\\t\\tthis.validateTransformationLockInfo();\\r\\n\\t\\tif(this.transformationLockInfo[mechId]){\\r\\n\\t\\t\\tthis.transformationLockInfo[mechId][index] = false;\\r\\n\\t\\t}\\t\\t\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.unlockAllTransformations = function() {\\r\\n\\t\\tthis.validateTransformationLockInfo();\\r\\n\\t\\tfor(var i = 1; i < $dataClasses.length; i++){\\r\\n\\t\\t\\tdelete this.transformationLockInfo[i];\\r\\n\\t\\t}\\t\\r\\n\\t}\\r\\n\\t\\r\\n\\t\\r\\n\\tGame_System.prototype.validateAbilityUpgradesInfo = function(type) {\\r\\n\\t\\tif(!this.abilityUpgradesInfo){\\r\\n\\t\\t\\tthis.abilityUpgradesInfo = {}\\r\\n\\t\\t}\\r\\n\\t\\tif(!this.abilityUpgradesInfo[type]){\\r\\n\\t\\t\\tthis.abilityUpgradesInfo[type] = {};\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.setAbilityUpgrade = function(type, baseIdx, upgradeIdx) {\\r\\n\\t\\tthis.validateAbilityUpgradesInfo(type);\\r\\n\\t\\tthis.abilityUpgradesInfo[type][baseIdx] = upgradeIdx;\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_System.prototype.getAbilityUpgrades = function(type) {\\r\\n\\t\\tthis.validateAbilityUpgradesInfo(type);\\r\\n\\t\\treturn this.abilityUpgradesInfo[type];\\r\\n\\t}\\r\\n//==================================================================\\r\\n// ●Game_Action\\r\\n//====================================================================\\r\\n    // 予想ダメージの計算\\r\\n    Game_Action.prototype.srpgPredictionDamage = function(target) {\\r\\n        var item = this.item();\\r\\n        if (this.item().damage.type > 0) {\\r\\n            var baseValue = this.evalDamageFormula(target);\\r\\n        } else {\\r\\n            var baseValue = 0;\\r\\n        }\\r\\n        var value = baseValue * this.calcElementRate(target);\\r\\n        if (this.isPhysical()) {\\r\\n            value *= target.pdr;\\r\\n        }\\r\\n        if (this.isMagical()) {\\r\\n            value *= target.mdr;\\r\\n        }\\r\\n        if (baseValue < 0) {\\r\\n            value *= target.rec;\\r\\n        }\\r\\n        item.effects.forEach(function(effect) {\\r\\n            value -= this.srpgPredictionItemEffect(target, effect);\\r\\n        }, this);\\r\\n        return Math.round(value);\\r\\n    };\\r\\n\\r\\n    // エネミーアクションのインデックスを設定する\\r\\n    Game_Action.prototype.srpgPredictionItemEffect = function(target, effect) {\\r\\n        switch (effect.code) {\\r\\n        case Game_Action.EFFECT_RECOVER_HP:\\r\\n            var value = (target.mhp * effect.value1 + effect.value2) * target.rec;\\r\\n            if (this.isItem()) {\\r\\n                value *= this.subject().pha;\\r\\n            }\\r\\n            return Math.floor(value);\\r\\n        case Game_Action.EFFECT_RECOVER_MP:\\r\\n            var value = (target.mmp * effect.value1 + effect.value2) * target.rec;\\r\\n            if (this.isItem()) {\\r\\n                value *= this.subject().pha;\\r\\n            }\\r\\n            return Math.floor(value);\\r\\n        case Game_Action.EFFECT_GAIN_TP:\\r\\n            var value = Math.floor(effect.value1);\\r\\n            return Math.floor(value);\\r\\n        }\\r\\n        return 0;\\r\\n    };\\r\\n\\r\\n    // エネミーアクションのインデックスを設定する\\r\\n    Game_Action.prototype.setSrpgEnemySubject = function(index) {\\r\\n        this._subjectEnemyIndex = index;\\r\\n        this._subjectActorId = 0;\\r\\n    };\\r\\n\\r\\n    // 混乱状態でのターゲットを設定する\\r\\n    var _SRPG_Game_Action_confusionTarget = Game_Action.prototype.confusionTarget;\\r\\n    Game_Action.prototype.confusionTarget = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            if (this._targetIndex == 0) {\\r\\n                 return this.opponentsUnit().smoothTarget(this._targetIndex);\\r\\n            } else {\\r\\n                 return this.friendsUnit().smoothTarget(this._targetIndex);\\r\\n            }\\r\\n        } else {\\r\\n            _SRPG_Game_Action_confusionTarget.call(this);\\r\\n        }\\r\\n    };\\r\\n\\t\\r\\n\\tGame_Action.prototype.makeDamageValue = function(target, critical) {\\t\\t\\r\\n\\t\\treturn $gameTemp.battleEffectCache[this._cacheReference].damageInflicted;\\t\\t\\t  \\r\\n    };\\r\\n\\t\\r\\n\\tGame_Action.prototype.itemHit = function(target) {  \\r\\n\\t\\treturn $gameTemp.battleEffectCache[this._cacheReference].hits;\\t\\t\\r\\n    };\\r\\n\\t\\r\\n\\tGame_Action.prototype.itemCri = function(target) {  \\r\\n\\t\\treturn $gameTemp.battleEffectCache[this._cacheReference].inflictedCritical;\\t\\t\\r\\n    };\\r\\n\\t//fixes a bug where a battle scene would sometimes be set up with invalid items, root cause still under investigation\\r\\n\\tGame_Action.prototype.isValid = function() {\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n//==================================================================\\r\\n// ●Game_BattlerBase\\r\\n//====================================================================\\r\\n    // 初期処理\\r\\n\\tObject.defineProperties(Game_BattlerBase.prototype, {\\r\\n\\t\\t// Hit Points\\r\\n\\t\\thp: { get: function() { \\r\\n\\t\\t\\tif($statCalc.isActorSRWInitialized(this)){\\r\\n\\t\\t\\t\\treturn this.SRWStats.mech.stats.calculated.currentHP;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\treturn this._hp; \\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}, configurable: true },\\r\\n\\t\\t// Magic Points\\r\\n\\t\\tmp: { get: function() { \\r\\n\\t\\t\\tif($statCalc.isActorSRWInitialized(this)){\\r\\n\\t\\t\\t\\treturn this.SRWStats.mech.stats.calculated.currentEN;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\treturn this._mp; \\r\\n\\t\\t\\t}\\r\\n\\t\\t}, configurable: true },\\r\\n\\t\\t// Tactical Points\\r\\n\\t\\tmhp: { get: function() { \\r\\n\\t\\t\\tif($statCalc.isActorSRWInitialized(this)){\\r\\n\\t\\t\\t\\treturn this.SRWStats.mech.stats.calculated.maxHP;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\treturn this.param(0); \\r\\n\\t\\t\\t}\\t\\t\\r\\n\\t\\t}, configurable: true },\\r\\n\\t\\t// Maximum Magic Points\\r\\n\\t\\tmmp: { get: function() { \\r\\n\\t\\t\\tif($statCalc.isActorSRWInitialized(this)){\\r\\n\\t\\t\\t\\treturn this.SRWStats.mech.stats.calculated.maxEN;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\treturn this.param(1); \\r\\n\\t\\t\\t}\\r\\n\\t\\t}, configurable: true },\\r\\n\\t\\t// ATtacK power\\r\\n\\t});\\r\\n\\t\\r\\n\\tGame_BattlerBase.prototype.setHp = function(hp) {\\r\\n\\t\\tif(!isNaN(hp)){\\r\\n\\t\\t\\tif(hp < 0){\\r\\n\\t\\t\\t\\thp = 0;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif($statCalc.isActorSRWInitialized(this)){\\r\\n\\t\\t\\t\\tthis.SRWStats.mech.stats.calculated.currentHP = hp;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthis._hp = hp;\\r\\n\\t\\t\\tthis.refresh();\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tconsole.log(\\\"setHp received invalid value!\\\");\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tGame_BattlerBase.prototype.setMp = function(mp) {\\r\\n\\t\\tif(!isNaN(mp)){\\r\\n\\t\\t\\tif(mp < 0){\\r\\n\\t\\t\\t\\tmp = 0;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif($statCalc.isActorSRWInitialized(this)){\\r\\n\\t\\t\\t\\tthis.SRWStats.mech.stats.calculated.currentEN = mp;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthis._mp = mp;\\r\\n\\t\\t\\tthis.refresh();\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tconsole.log(\\\"setMp received invalid value!\\\");\\r\\n\\t\\t}\\t\\t\\r\\n\\t};\\t\\r\\n\\t\\r\\n    var _SRPG_Game_BattlerBase_initMembers = Game_BattlerBase.prototype.initMembers;\\r\\n    Game_BattlerBase.prototype.initMembers = function() {\\r\\n        _SRPG_Game_BattlerBase_initMembers.call(this);\\r\\n        this._srpgTurnEnd = false;\\r\\n        this._srpgActionTiming = -1; // 0:攻撃側、1:防御側\\r\\n    };\\r\\n\\r\\n    // 移動力を返す（定義は、gameActor, gameEnemyで行う）\\r\\n    Game_BattlerBase.prototype.srpgMove = function() {\\r\\n        return 0;\\r\\n    };\\r\\n\\r\\n    // スキル・アイテムの射程を返す（定義は、gameActor, gameEnemyで行う）\\r\\n    Game_BattlerBase.prototype.srpgSkillRange = function(skill) {\\r\\n        return 0;\\r\\n    };\\r\\n\\r\\n    // 武器の攻撃射程を返す（定義は、gameActor, gameEnemyで行う）\\r\\n    Game_BattlerBase.prototype.srpgWeaponRange = function() {\\r\\n        return 0;\\r\\n    };\\r\\n\\r\\n    // 武器が反撃可能かを返す（定義は、gameActor, gameEnemyで行う）\\r\\n    Game_BattlerBase.prototype.srpgWeaponCounter = function() {\\r\\n        return true;\\r\\n    };\\r\\n\\r\\n    // 通行可能タグを返す（定義は、gameActor, gameEnemyで行う）\\r\\n    Game_BattlerBase.prototype.srpgThroughTag = function() {\\r\\n        return 0;\\r\\n    };\\r\\n\\r\\n    //行動終了かどうかを返す\\r\\n    Game_BattlerBase.prototype.srpgTurnEnd = function() {\\r\\n        return this._srpgTurnEnd;\\r\\n    };\\r\\n\\r\\n    //行動終了を設定する\\r\\n    Game_BattlerBase.prototype.setSrpgTurnEnd = function(flag) {\\r\\n\\t\\tif(flag){\\r\\n\\t\\t\\t$statCalc.setTurnEnd(this);\\r\\n\\t\\t}\\t\\t\\r\\n        this._srpgTurnEnd = flag;\\r\\n    };\\r\\n\\r\\n    //攻撃側か防御側かを返す\\r\\n    Game_BattlerBase.prototype.srpgActionTiming = function() {\\r\\n        return this._srpgActionTiming;\\r\\n    };\\r\\n\\r\\n    //攻撃側か防御側かを設定する\\r\\n    Game_BattlerBase.prototype.setActionTiming = function(timing) {\\r\\n        this._srpgActionTiming = timing;\\r\\n    };\\r\\n\\r\\n    // 入力可能かどうかの判定\\r\\n    var _SRPG_Game_BattlerBase_canInput = Game_BattlerBase.prototype.canInput;\\r\\n    Game_BattlerBase.prototype.canInput = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            return this.isAppeared() && !this.isRestricted() && !this.isAutoBattle() &&\\r\\n                   !this.srpgTurnEnd();\\r\\n        } else {\\r\\n            return _SRPG_Game_BattlerBase_canInput.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    // スキル・アイテムが使用可能かの判定\\r\\n    var _SRPG_Game_BattlerBase_isOccasionOk = Game_BattlerBase.prototype.isOccasionOk;\\r\\n    Game_BattlerBase.prototype.isOccasionOk = function(item) {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            if ($gameSystem.isBattlePhase() === 'actor_phase' &&\\r\\n                $gameSystem.isSubBattlePhase() === 'normal') {\\r\\n                return false;\\r\\n            } else {\\r\\n                return item.occasion === 0 || item.occasion === 1;\\r\\n            }\\r\\n        } else {\\r\\n            return _SRPG_Game_BattlerBase_isOccasionOk.call(this, item);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    // スキル・アイテムが使用可能かの判定\\r\\n    var _SRPG_Game_BattlerBase_canUse = Game_BattlerBase.prototype.canUse;\\r\\n    Game_BattlerBase.prototype.canUse = function(item) {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            if (!item) {\\r\\n                return false;\\r\\n            }\\r\\n            if ($gameSystem.isBattlePhase() === 'actor_phase' && \\r\\n                $gameSystem.isSubBattlePhase() === 'normal') {\\r\\n                return false;\\r\\n            }\\r\\n            if (($gameSystem.isSubBattlePhase() === 'invoke_action' ||\\r\\n                 $gameSystem.isSubBattlePhase() === 'auto_actor_action' ||\\r\\n                 $gameSystem.isSubBattlePhase() === 'enemy_action' ||\\r\\n                 $gameSystem.isSubBattlePhase() === 'battle_window') &&\\r\\n                (this.srpgSkillRange(item) < $gameTemp.SrpgDistance() ||\\r\\n                this.srpgSkillMinRange(item) > $gameTemp.SrpgDistance() ||\\r\\n                $gameTemp.SrpgSpecialRange() == false ||\\r\\n                (this._srpgActionTiming == 1 && this.srpgWeaponCounter() == false))) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        return _SRPG_Game_BattlerBase_canUse.call(this, item);\\r\\n    };\\r\\n\\r\\n    // ステートのターン経過処理（ＳＲＰＧ用）\\r\\n    // 行動終了時：行動ごとに１ターン経過\\r\\n    // ターン終了時：全体のターン終了ごとに１ターン経過\\r\\n    Game_BattlerBase.prototype.updateSrpgStateTurns = function(timing) {\\r\\n        this._states.forEach(function(stateId) {\\r\\n            if (this._stateTurns[stateId] > 0 && $dataStates[stateId].autoRemovalTiming === timing) {\\r\\n                this._stateTurns[stateId]--;\\r\\n            }\\r\\n        }, this);\\r\\n    };\\r\\n\\r\\n\\r\\n//====================================================================\\r\\n// ●Game_Battler\\r\\n//====================================================================\\r\\n\\t\\r\\n\\r\\n    var _SRPG_Game_Battler_initMembers = Game_Battler.prototype.initMembers;\\r\\n    Game_Battler.prototype.initMembers = function() {\\r\\n        _SRPG_Game_Battler_initMembers.call(this);\\r\\n        this._battleMode = 'normal';\\r\\n        this._searchItem = false;\\r\\n        this._targetId = -1;\\r\\n        this._SRPGActionTimes = 1;\\r\\n    };\\r\\n\\r\\n    // 行動モードの設定\\r\\n    Game_Battler.prototype.setBattleMode = function(mode, force) {\\r\\n\\t\\tif(force || (this._battleMode != \\\"fixed\\\" && this._battleMode != \\\"disabled\\\")){\\r\\n\\t\\t\\tthis._battleMode = mode;\\t\\r\\n\\t\\t}        \\r\\n    };\\r\\n\\t\\r\\n\\tGame_Battler.prototype.setSquadMode = function(mode) {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\t_this.setBattleMode(mode);\\r\\n\\t\\tif(_this.squadId != -1){\\r\\n\\t\\t\\tvar type = _this.isActor() ? \\\"actor\\\" : \\\"enemy\\\";\\r\\n\\t\\t\\t$gameMap.events().forEach(function(event) {\\r\\n\\t\\t\\t\\tif (event.isType() === type) {\\r\\n\\t\\t\\t\\t\\tvar enemy = $gameSystem.EventToUnit(event.eventId())[1];\\t\\r\\n\\t\\t\\t\\t\\tif(enemy.squadId == _this.squadId){\\r\\n\\t\\t\\t\\t\\t\\tenemy.setBattleMode(_this._battleMode);\\r\\n\\t\\t\\t\\t\\t}\\t\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t});\\r\\n\\t\\t}\\t\\t\\r\\n\\t}\\r\\n\\r\\n    Game_Battler.prototype.battleMode = function() {\\r\\n        return this._battleMode;\\r\\n    };\\r\\n\\r\\n    // アイテム探査モードの設定\\r\\n    Game_Battler.prototype.setSearchItem = function(mode) {\\r\\n        if (mode) {\\r\\n            this._searchItem = true;\\r\\n        } else {\\r\\n            this._searchItem = false;\\r\\n        }\\r\\n    };\\r\\n\\r\\n    Game_Battler.prototype.searchItem = function() {\\r\\n        return this._searchItem;\\r\\n    };\\r\\n\\r\\n    // ターゲットＩＤの設定\\r\\n    Game_Battler.prototype.setTargetId = function(id) {\\r\\n        this._targetId = id;\\r\\n    };\\r\\n\\r\\n    Game_Battler.prototype.targetId = function() {\\r\\n        return this._targetId;\\r\\n    };\\r\\n\\r\\n    // 行動回数を設定する（SRPG用）\\r\\n    Game_Battler.prototype.SRPGActionTimesSet = function(amount) {\\r\\n        this._SRPGActionTimes = amount || 1;\\r\\n    };\\r\\n\\r\\n    // 行動回数を返す\\r\\n    Game_Battler.prototype.SRPGActionTimes = function() {\\r\\n        return this._SRPGActionTimes;\\r\\n    };\\r\\n\\r\\n    // 行動回数を消費する\\r\\n    Game_Battler.prototype.useSRPGActionTimes = function(num) {\\r\\n        this._SRPGActionTimes -= num;\\r\\n    };\\r\\n\\r\\n    // 行動回数の設定（戦闘用）\\r\\n    var _SRPG_Game_Battler_makeActionTimes = Game_Battler.prototype.makeActionTimes;\\r\\n    Game_Battler.prototype.makeActionTimes = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            return 1;\\r\\n        } else {\\r\\n            return _SRPG_Game_Battler_makeActionTimes.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    // アクションのから配列を作成する\\r\\n    Game_Battler.prototype.srpgMakeNewActions = function() {\\r\\n        this.clearActions();\\r\\n        //if (this.canMove()) {\\r\\n            var actionTimes = this.makeActionTimes();\\r\\n            this._actions = [];\\r\\n            for (var i = 0; i < actionTimes; i++) {\\r\\n                this._actions.push(new Game_Action(this));\\r\\n            }\\r\\n        //}\\r\\n        this.setActionState('waiting');\\r\\n    };\\r\\n\\t\\r\\n\\tGame_Battler.prototype.srpgInitAction = function() {\\r\\n\\t\\t this.clearActions();\\r\\n\\t\\t this._actions.push(new Game_Action(this));\\r\\n\\t}\\r\\n\\r\\n    // 行動開始時の処理\\r\\n    var _SRPG_Game_Battler_onBattleStart = Game_Battler.prototype.onBattleStart;\\r\\n    Game_Battler.prototype.onBattleStart = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            this.setActionState('undecided');\\r\\n            this.clearMotion();\\r\\n        } else {\\r\\n            return _SRPG_Game_Battler_onBattleStart.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    // 行動終了時の処理\\r\\n    var _SRPG_Game_Battler_onAllActionsEnd = Game_Battler.prototype.onAllActionsEnd;\\r\\n    Game_Battler.prototype.onAllActionsEnd = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            this.updateSrpgStateTurns(1);\\r\\n            this.removeStatesAuto(1);\\r\\n            this.clearResult();\\r\\n        } else {\\r\\n            return _SRPG_Game_Battler_onAllActionsEnd.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    // ターン終了時の処理\\r\\n    var _SRPG_Game_Battler_onTurnEnd = Game_Battler.prototype.onTurnEnd;\\r\\n    Game_Battler.prototype.onTurnEnd = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            this.regenerateAll();\\r\\n            this.updateSrpgStateTurns(2);\\r\\n            this.updateBuffTurns();\\r\\n            this.removeStatesAuto(2);\\r\\n            this.removeBuffsAuto();\\r\\n            this.clearResult();\\r\\n            this.setSrpgTurnEnd(false);\\r\\n        } else {\\r\\n            return _SRPG_Game_Battler_onTurnEnd.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    Game_Battler.prototype.srpgCheckFloorEffect = function(x, y) {\\r\\n        if ($gameMap.isDamageFloor(x, y) == true) {\\r\\n            this.srpgExecuteFloorDamage();\\r\\n        }\\r\\n    };\\r\\n\\r\\n    Game_Battler.prototype.srpgExecuteFloorDamage = function() {\\r\\n        var damage = Math.floor(this.srpgBasicFloorDamage() * this.fdr);\\r\\n        damage = Math.min(damage, this.srpgMaxFloorDamage());\\r\\n        this.gainHp(-damage);\\r\\n        if (damage > 0) {\\r\\n            $gameScreen.startFlashForDamage();\\r\\n        }\\r\\n    };\\r\\n\\r\\n    Game_Battler.prototype.srpgBasicFloorDamage = function() {\\r\\n        return this.mhp * 0.1;\\r\\n    };\\r\\n\\r\\n    Game_Battler.prototype.srpgMaxFloorDamage = function() {\\r\\n        return $dataSystem.optFloorDeath ? this.hp : Math.max(this.hp - 1, 0);\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// ●Game_Actor\\r\\n//====================================================================\\r\\n\\tObject.defineProperty(Game_Actor.prototype, 'level', {\\r\\n\\t\\tget: function() {\\r\\n\\t\\t\\tif($statCalc.isActorSRWInitialized(this)){\\r\\n\\t\\t\\t\\treturn this.SRWStats.pilot.level;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\treturn this._level; \\r\\n\\t\\t\\t}\\t\\r\\n\\t\\t},\\r\\n\\t\\tconfigurable: true\\r\\n\\t});\\r\\n\\t\\r\\n\\t\\r\\n\\tGame_Actor.prototype.expForLevel = function(level) {\\r\\n\\t\\treturn 500 * level;\\r\\n\\t};\\r\\n\\r\\n\\tGame_Actor.prototype.initExp = function() {\\r\\n\\t\\t//stubbed\\t\\r\\n\\t};\\r\\n\\r\\n\\tGame_Actor.prototype.currentExp = function() {\\r\\n\\t\\treturn this.SRWStats.pilot.exp;\\r\\n\\t};\\r\\n\\r\\n\\tGame_Actor.prototype.currentLevelExp = function() {\\r\\n\\t\\treturn this.expForLevel(this._level);\\r\\n\\t};\\r\\n\\r\\n\\tGame_Actor.prototype.nextLevelExp = function() {\\r\\n\\t\\treturn this.expForLevel(this._level + 1);\\r\\n\\t};\\r\\n\\r\\n\\tGame_Actor.prototype.nextRequiredExp = function() {\\r\\n\\t\\treturn this.nextLevelExp() - this.currentExp();\\r\\n\\t};\\r\\n\\r\\n\\tGame_Actor.prototype.maxLevel = function() {\\r\\n\\t\\treturn 99;\\r\\n\\t};\\r\\n\\r\\n\\tGame_Actor.prototype.isMaxLevel = function() {\\r\\n\\t\\treturn this._level >= this.maxLevel();\\r\\n\\t};\\r\\n\\t\\r\\n\\tvar Game_Actor_initImages = Game_Actor.prototype.initImages;\\r\\n\\tGame_Actor.prototype.initImages = function(overworldSpriteData) {\\r\\n\\t\\tif($gameSystem.isSRPGMode()){\\r\\n\\t\\t\\tvar actor = this.actor();\\r\\n\\t\\t\\tif(!overworldSpriteData){\\r\\n\\t\\t\\t\\tif($dataClasses[actor.classId].meta.srpgOverworld){\\r\\n\\t\\t\\t\\t\\toverworldSpriteData = $dataClasses[actor.classId].meta.srpgOverworld.split(\\\",\\\");\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\toverworldSpriteData = [actor.characterName, actor.characterIndex];\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\r\\n\\t\\t\\tthis._characterName = overworldSpriteData[0];\\r\\n\\t\\t\\tthis._characterIndex = overworldSpriteData[1];\\r\\n\\t\\t\\tthis._faceName = actor.faceName;\\r\\n\\t\\t\\tthis._faceIndex = actor.faceIndex;\\r\\n\\t\\t\\tthis._battlerName = actor.battlerName;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tGame_Actor_initImages.call(this);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t};\\r\\n\\r\\n    // 装備変更可能か\\r\\n    Window_EquipSlot.prototype.isEnabled = function(index) {\\r\\n        return this._actor ? this._actor.isEquipChangeOk(index) : false;\\r\\n    };\\r\\n\\t\\r\\n\\tGame_Actor.prototype.setAttack = function(slotId, item) {\\r\\n\\t\\tthis._equips[slotId].setObject(item);\\r\\n\\t};\\r\\n\\r\\n    var _SRPG_Game_Actor_isEquipChangeOk = Game_Actor.prototype.isEquipChangeOk;\\r\\n    Game_Actor.prototype.isEquipChangeOk = function(slotId) {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            if (this.srpgTurnEnd() == true || this.isRestricted() == true) {\\r\\n                return false;\\r\\n            } else {\\r\\n                return _SRPG_Game_Actor_isEquipChangeOk.call(this, slotId);\\r\\n            }\\r\\n        } else {\\r\\n            return _SRPG_Game_Actor_isEquipChangeOk.call(this, slotId);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    // アクターコマンドで装備が可能か（移動後は不可）\\r\\n    Game_Actor.prototype.canSrpgEquip = function() {\\r\\n        return $gameTemp.originalPos()[0] == $gameTemp.activeEvent().posX() &&\\r\\n               $gameTemp.originalPos()[1] == $gameTemp.activeEvent().posY();\\r\\n    };\\r\\n\\r\\n    // 経験値の割合を返す\\r\\n    Game_Actor.prototype.expRate = function() {\\r\\n        if (this.isMaxLevel()) {\\r\\n            var rate = 1.0;\\r\\n        } else {\\r\\n            var rate = (this.currentExp() - this.currentLevelExp()) / (this.nextLevelExp() - this.currentLevelExp());\\r\\n        }\\r\\n        return rate;\\r\\n    };\\r\\n\\r\\n    // 移動力を返す\\r\\n    Game_Actor.prototype.srpgMove = function() {\\r\\n        var n = this.currentClass().meta.srpgMove;\\r\\n        if (!n) {\\r\\n            n = _defaultMove;\\r\\n        }\\r\\n        n = Number(n);\\r\\n        // ステートによる変更\\r\\n        this.states().forEach(function(state) {\\r\\n            if (state.meta.srpgMovePlus) {\\r\\n                n += Number(state.meta.srpgMovePlus);\\r\\n            }\\r\\n        }, this);\\r\\n        // 装備による変更\\r\\n        var equips = this.equips();\\r\\n        for (var i = 0; i < equips.length; i++) {\\r\\n            var item = equips[i];\\r\\n            if (item && item.meta.srpgMovePlus) {\\r\\n                n += Number(item.meta.srpgMovePlus);\\r\\n            }\\r\\n        }\\r\\n        n = Number(Math.max(n, 0));\\r\\n        return n;\\r\\n    };\\r\\n\\r\\n    // スキル・アイテムの射程を返す\\r\\n    Game_Actor.prototype.srpgSkillRange = function(skill) {\\r\\n        var range = 1;\\r\\n        if (skill && skill.meta.srpgRange == -1) {\\r\\n            if (!this.hasNoWeapons()) {\\r\\n                weapon = this.weapons()[0];\\r\\n                range = weapon.meta.weaponRange;\\r\\n            }\\r\\n        } else if (skill.meta.srpgRange) {\\r\\n            range = skill.meta.srpgRange;\\r\\n        } else {\\r\\n            range = 1;\\r\\n        }\\r\\n        return Number(range);\\r\\n    };\\r\\n\\r\\n    // 武器の攻撃射程を返す\\r\\n    Game_Actor.prototype.srpgWeaponRange = function() {\\r\\n        return this.srpgSkillRange($dataSkills[this.attackSkillId()]);\\r\\n    };\\r\\n\\r\\n    // 武器が反撃可能かを返す\\r\\n    Game_Actor.prototype.srpgWeaponCounter = function() {\\r\\n        if (this.hasNoWeapons()) {\\r\\n            return true;\\r\\n        } else {\\r\\n            var weapon = this.weapons()[0];\\r\\n            if (!weapon.meta.srpgCounter || !weapon.meta.srpgCounter == 'false') {\\r\\n                return true;\\r\\n            } else {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n    };\\r\\n\\r\\n    // 通行可能タグを返す（class, equip, stateの設定で最大の物を採用する）\\r\\n    Game_Actor.prototype.srpgThroughTag = function() {\\r\\n        var n = 0;\\r\\n        // 職業\\r\\n        if (this.currentClass().meta.srpgThroughTag && n < Number(this.currentClass().meta.srpgThroughTag)) {\\r\\n            n = Number(this.currentClass().meta.srpgThroughTag);\\r\\n        }\\r\\n        // ステート\\r\\n        this.states().forEach(function(state) {\\r\\n            if (state.meta.srpgThroughTag && n < Number(state.meta.srpgThroughTag)) {\\r\\n                n = Number(state.meta.srpgThroughTag);\\r\\n            }\\r\\n        }, this);\\r\\n        // 装備\\r\\n        var equips = this.equips();\\r\\n        for (var i = 0; i < equips.length; i++) {\\r\\n            var item = equips[i];\\r\\n            if (item && item.meta.srpgThroughTag && n < Number(item.meta.srpgThroughTag)) {\\r\\n                n = Number(item.meta.srpgThroughTag);\\r\\n            }\\r\\n        }\\r\\n        return n;\\r\\n    };\\r\\n\\r\\n    // スキル・アイテムの最低射程を返す\\r\\n    Game_Actor.prototype.srpgSkillMinRange = function(skill) {\\r\\n        var minRange = 0;\\r\\n        if (skill) {\\r\\n            if (skill.meta.srpgRange == -1) {\\r\\n                if (!this.hasNoWeapons()) {\\r\\n                    var weapon = this.weapons()[0];\\r\\n                    minRange = weapon.meta.weaponMinRange;\\r\\n                }\\r\\n            } else if (skill.meta.srpgMinRange) {\\r\\n                minRange = skill.meta.srpgMinRange;\\r\\n            }\\r\\n            if (!minRange) {\\r\\n                minRange = 0;\\r\\n            }\\r\\n        } else {\\r\\n            minRange = 0;\\r\\n        }\\r\\n        if (minRange > this.srpgSkillRange(skill)) {\\r\\n            minRange = this.srpgSkillRange(skill);\\r\\n        }\\r\\n        return Number(minRange);\\r\\n    };\\r\\n\\r\\n    // 武器の最低射程を返す\\r\\n    Game_Actor.prototype.srpgWeaponMinRange = function() {\\r\\n        return this.srpgSkillMinRange($dataSkills[this.attackSkillId()]);\\r\\n    };\\r\\n\\r\\n    // attackSkillId == 1 以外の武器を作る\\r\\n    Game_Actor.prototype.attackSkillId = function() {\\r\\n        var weapon = this.weapons()[0];\\r\\n        if (weapon && weapon.meta.srpgWeaponSkill) {\\r\\n            return Number(weapon.meta.srpgWeaponSkill);\\r\\n        } else {\\r\\n            return Game_BattlerBase.prototype.attackSkillId.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    //自動行動を決定する\\r\\n    var _SRPG_Game_Actor_makeAutoBattleActions = Game_Actor.prototype.makeAutoBattleActions;\\r\\n    Game_Actor.prototype.makeAutoBattleActions = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            for (var i = 0; i < this.numActions(); i++) {\\r\\n                var list = this.makeActionList();\\r\\n                this.setAction(i, list[Math.randomInt(list.length)]);\\r\\n            }\\r\\n            this.setActionState('waiting');\\r\\n        } else {\\r\\n            return _SRPG_Game_Actor_makeAutoBattleActions.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// ●Game_Enemy\\r\\n//====================================================================\\r\\n    // 戦闘画面での座標を設定する\\r\\n    Game_Enemy.prototype.setScreenXy = function(x, y) {\\r\\n        this._screenX = x;\\r\\n        this._screenY = y;\\r\\n    };\\r\\n\\r\\n    // 移動力を返す\\r\\n    Game_Enemy.prototype.srpgMove = function() {\\r\\n        var n = this.enemy().meta.srpgMove;\\r\\n        if (!n) {\\r\\n            n = _defaultMove;\\r\\n        }\\r\\n        n = Number(n);\\r\\n        // ステートによる変更\\r\\n        this.states().forEach(function(state) {\\r\\n            if (state.meta.srpgMovePlus) {\\r\\n                n += Number(state.meta.srpgMovePlus);\\r\\n            }\\r\\n        }, this);\\r\\n        // 装備による変更\\r\\n        if (!this.hasNoWeapons()) {\\r\\n            var item = $dataWeapons[this.enemy().meta.srpgWeapon];\\r\\n            if (item && item.meta.srpgMovePlus) {\\r\\n                n += Number(item.meta.srpgMovePlus);\\r\\n            }\\r\\n        }\\r\\n        n = Number(Math.max(n, 0));\\r\\n        return n;\\r\\n    };\\r\\n\\r\\n    // スキル・アイテムの射程を返す\\r\\n    Game_Enemy.prototype.srpgSkillRange = function(skill) {\\r\\n        var range = 1;\\r\\n        if (skill && skill.meta.srpgRange == -1) {\\r\\n            if (!this.hasNoWeapons()) {\\r\\n                var weapon = $dataWeapons[this.enemy().meta.srpgWeapon];\\r\\n                range = weapon.meta.weaponRange;\\r\\n            } else {\\r\\n                range = this.enemy().meta.weaponRange;\\r\\n            }\\r\\n        } else if (skill.meta.srpgRange) {\\r\\n            range = skill.meta.srpgRange;\\r\\n        } else {\\r\\n            range = 1;\\r\\n        }\\r\\n        return Number(range);\\r\\n    };\\r\\n\\r\\n    // 武器の攻撃射程を返す\\r\\n    Game_Enemy.prototype.srpgWeaponRange = function() {\\r\\n        return this.srpgSkillRange($dataSkills[this.attackSkillId()]);\\r\\n    };\\r\\n\\r\\n    // 武器が反撃可能かを返す\\r\\n    Game_Enemy.prototype.srpgWeaponCounter = function() {\\r\\n        if (!this.hasNoWeapons()) {\\r\\n            var weapon = $dataWeapons[this.enemy().meta.srpgWeapon];\\r\\n            var counter = weapon.meta.srpgCounter;\\r\\n        } else {\\r\\n            var counter = this.enemy().meta.srpgCounter;\\r\\n        } \\r\\n        if (!counter || !counter == 'false') {\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    };\\r\\n\\r\\n    // 通行可能タグを返す（enemy, equip, stateの設定で最大の物を採用する）\\r\\n    Game_Enemy.prototype.srpgThroughTag = function() {\\r\\n        var n = 0;\\r\\n        // エネミー\\r\\n        if (this.enemy().meta.srpgThroughTag && n < Number(this.enemy().meta.srpgThroughTag)) {\\r\\n            n = Number(this.enemy().meta.srpgThroughTag);\\r\\n        }\\r\\n        // ステート\\r\\n        this.states().forEach(function(state) {\\r\\n            if (state.meta.srpgThroughTag && n < Number(state.meta.srpgThroughTag)) {\\r\\n                n = Number(state.meta.srpgThroughTag);\\r\\n            }\\r\\n        }, this);\\r\\n        // 装備\\r\\n        if (!this.hasNoWeapons()) {\\r\\n            var item = $dataWeapons[this.enemy().meta.srpgWeapon];\\r\\n            if (item && item.meta.srpgThroughTag && n < Number(item.meta.srpgThroughTag)) {\\r\\n                n = Number(item.meta.srpgThroughTag);\\r\\n            }\\r\\n        }\\r\\n        return n;\\r\\n    };\\r\\n\\r\\n    // スキル・アイテムの最低射程を返す\\r\\n    Game_Enemy.prototype.srpgSkillMinRange = function(skill) {\\r\\n        var minRange = 0;\\r\\n        if (skill) {\\r\\n            if (skill.meta.srpgRange == -1) {\\r\\n                if (!this.hasNoWeapons()) {\\r\\n                    var weapon = $dataWeapons[this.enemy().meta.srpgWeapon];\\r\\n                    minRange = weapon.meta.weaponMinRange;\\r\\n                } else {\\r\\n                    minRange = this.enemy().meta.weaponMinRange;\\r\\n                }\\r\\n            } else if (skill.meta.srpgMinRange) {\\r\\n                minRange = skill.meta.srpgMinRange;\\r\\n            }\\r\\n            if (!minRange) {\\r\\n                minRange = 0;\\r\\n            }\\r\\n        } else {\\r\\n            minRange = 0;\\r\\n        }\\r\\n        if (minRange > this.srpgSkillRange(skill)) {\\r\\n            minRange = this.srpgSkillRange(skill);\\r\\n        }\\r\\n        return Number(minRange);\\r\\n    };\\r\\n\\r\\n    // 武器の最低射程を返す\\r\\n    Game_Enemy.prototype.srpgWeaponMinRange = function() {\\r\\n        return this.srpgSkillMinRange($dataSkills[this.attackSkillId()]);\\r\\n    };\\r\\n\\r\\n    // 武器を装備しているか返す\\r\\n    Game_Enemy.prototype.hasNoWeapons = function() {\\r\\n        return !$dataWeapons[this.enemy().meta.srpgWeapon];\\r\\n    };\\r\\n\\r\\n    // 装備の特徴を反映する\\r\\n    var _SRPG_Game_Enemy_traitObjects = Game_Enemy.prototype.traitObjects;\\r\\n    Game_Enemy.prototype.traitObjects = function() {\\r\\n        var objects = _SRPG_Game_Enemy_traitObjects.call(this);\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            var item = $dataWeapons[this.enemy().meta.srpgWeapon];\\r\\n            if (item) {\\r\\n                objects.push(item);\\r\\n            }\\r\\n        }\\r\\n        return objects;\\r\\n    };\\r\\n\\r\\n    // 装備の能力変化値を反映する\\r\\n    Game_Enemy.prototype.paramPlus = function(paramId) {\\r\\n        var value = Game_Battler.prototype.paramPlus.call(this, paramId);\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            var item = $dataWeapons[this.enemy().meta.srpgWeapon];\\r\\n            if (item) {\\r\\n                value += item.params[paramId];\\r\\n            }\\r\\n        }\\r\\n        return value;\\r\\n    };\\r\\n\\r\\n    // 装備のアニメーションを反映する\\r\\n    Game_Enemy.prototype.attackAnimationId = function() {\\r\\n        if (this.hasNoWeapons()) {\\r\\n            return this.bareHandsAnimationId();\\r\\n        } else {\\r\\n            var weapons = $dataWeapons[this.enemy().meta.srpgWeapon];\\r\\n            return weapons ? weapons.animationId : 1;\\r\\n        }\\r\\n    };\\r\\n\\r\\n    // 装備が設定されていない（素手）の時のアニメーションＩＤ\\r\\n    Game_Enemy.prototype.bareHandsAnimationId = function() {\\r\\n        return 1;\\r\\n    };\\r\\n\\r\\n    // attackSkillId == 1 以外の武器を作る\\r\\n    Game_Enemy.prototype.attackSkillId = function() {\\r\\n        var weapon = $dataWeapons[this.enemy().meta.srpgWeapon];\\r\\n        if (weapon && weapon.meta.srpgWeaponSkill) {\\r\\n            return Number(weapon.meta.srpgWeaponSkill);\\r\\n        } else {\\r\\n            return Game_BattlerBase.prototype.attackSkillId.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    // ＳＲＰＧ用の行動決定\\r\\n    Game_Enemy.prototype.makeSrpgActions = function() {\\r\\n        Game_Battler.prototype.makeActions.call(this);\\r\\n        if (this.numActions() > 0) {\\r\\n            if (this.isConfused()) {\\r\\n                this.makeConfusionActions();\\r\\n            } else {\\r\\n                var actionList = this.enemy().actions.filter(function(a) {\\r\\n                    if (a.skillId == 1) {\\r\\n                        a.skillId = this.attackSkillId();\\r\\n                    }\\r\\n                    return this.isActionValid(a);\\r\\n                }, this);\\r\\n                if (actionList.length > 0) {\\r\\n                    this.selectAllActions(actionList);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        this.setActionState('waiting');\\r\\n    };\\r\\n\\r\\n    // ＳＲＰＧ用の行動決定\\r\\n    Game_Enemy.prototype.makeConfusionActions = function() {\\r\\n        for (var i = 0; i < this.numActions(); i++) {\\r\\n            this.action(i).setSkill(this.attackSkillId());\\r\\n        }\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// ●Game_Unit\\r\\n//====================================================================\\r\\n    var _SRPG_Game_Unit_onBattleEnd = Game_Unit.prototype.onBattleEnd;\\r\\n    Game_Unit.prototype.onBattleEnd = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            this._inBattle = false;\\r\\n        } else {\\r\\n            _SRPG_Game_Unit_onBattleEnd.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// ●Game_Party\\r\\n//====================================================================\\r\\n    // 初期化\\r\\n    var _SRPG_Game_Party_initialize = Game_Party.prototype.initialize;\\r\\n    Game_Party.prototype.initialize = function() {\\r\\n        _SRPG_Game_Party_initialize.call(this);\\r\\n        this._srpgBattleActors = []; //SRPGモードの戦闘時に呼び出すメンバーを設定する（行動者と対象者）\\r\\n    };\\r\\n\\r\\n    Game_Party.prototype.SrpgBattleActors = function() {\\r\\n        return this._srpgBattleActors;\\r\\n    };\\r\\n\\r\\n    Game_Party.prototype.clearSrpgBattleActors = function() {\\r\\n        this._srpgBattleActors = [];\\r\\n    };\\r\\n\\r\\n    Game_Party.prototype.pushSrpgBattleActors = function(actor) {\\r\\n        this._srpgBattleActors.push(actor);\\r\\n    };\\r\\n\\t\\r\\n\\t Game_Party.prototype.setSrpgBattleActors = function(actors) {\\r\\n        this._srpgBattleActors = actors;\\r\\n    };\\r\\n\\r\\n    //プレイヤー移動時の処理\\r\\n    var _SRPG_Game_Party_onPlayerWalk = Game_Party.prototype.onPlayerWalk;\\r\\n    Game_Party.prototype.onPlayerWalk = function() {\\r\\n        if ($gameSystem.isSRPGMode() == false) {\\r\\n            return _SRPG_Game_Party_onPlayerWalk.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    // SRPG戦闘中にはmembersで呼び出す配列を変える\\r\\n    var _SRPG_Game_Party_members = Game_Party.prototype.members;\\r\\n    Game_Party.prototype.members = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            if ($gameSystem.isSubBattlePhase() === 'normal' || $gameSystem.isSubBattlePhase() === 'initialize') {\\r\\n                return this.allMembers();\\r\\n            } else {\\r\\n                return this.battleMembers();\\r\\n            }\\r\\n        } else {\\r\\n            return _SRPG_Game_Party_members.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    // SRPG戦闘中にはbattleMembersで呼び出す配列を変える\\r\\n    var _SRPG_Game_Party_battleMembers = Game_Party.prototype.battleMembers;\\r\\n    Game_Party.prototype.battleMembers = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            return this.SrpgBattleActors();\\r\\n        } else {\\r\\n            return _SRPG_Game_Party_battleMembers.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    // セーブファイル用の処理\\r\\n    var _SRPG_Game_Party_charactersForSavefile = Game_Party.prototype.charactersForSavefile;\\r\\n    Game_Party.prototype.charactersForSavefile = function() {\\r\\n\\t\\treturn null;\\r\\n\\t\\t\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            return this.allMembers().map(function(actor) {\\r\\n                return [actor.characterName(), actor.characterIndex()];\\r\\n            });\\r\\n        } else {\\r\\n            return _SRPG_Game_Party_charactersForSavefile.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    var _SRPG_Game_Party_facesForSavefile = Game_Party.prototype.facesForSavefile;\\r\\n    Game_Party.prototype.facesForSavefile = function() {\\r\\n\\t\\treturn null;\\r\\n\\t\\t\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            return this.allMembers().map(function(actor) {\\r\\n                return [actor.faceName(), actor.faceIndex()];\\r\\n            });\\r\\n        } else {\\r\\n            return _SRPG_Game_Party_facesForSavefile.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n/*\\r\\n    // アイテム・スキルの使用条件\\r\\n    var _SRPG_Game_Party_canUse = Game_Party.prototype.canUse;\\r\\n    Game_Party.prototype.canUse = function(item) {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            var actor = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n            return actor.canUse(item);\\r\\n        } else {\\r\\n            return _SRPG_Game_Party_canUse.call(this, item);\\r\\n        }\\r\\n    };\\r\\n*/\\r\\n//====================================================================\\r\\n// ●Game_Troop\\r\\n//====================================================================\\r\\n    // 初期化\\r\\n    var _Game_Troop_initialize = Game_Troop.prototype.initialize\\r\\n    Game_Troop.prototype.initialize = function() {\\r\\n        _Game_Troop_initialize.call(this);\\r\\n        this._srpgBattleEnemys = []; //SRPGモードの戦闘時に呼び出すメンバーを設定する（行動者と対象者）\\r\\n    };\\r\\n\\r\\n    Game_Troop.prototype.SrpgBattleEnemys = function() {\\r\\n        return this._srpgBattleEnemys;\\r\\n    };\\r\\n\\r\\n    Game_Troop.prototype.clearSrpgBattleEnemys = function() {\\r\\n        this._srpgBattleEnemys = [];\\r\\n    };\\r\\n\\r\\n    Game_Troop.prototype.pushSrpgBattleEnemys = function(enemy) {\\r\\n        this._srpgBattleEnemys.push(enemy);\\r\\n    };\\r\\n\\t\\r\\n\\t Game_Troop.prototype.setSrpgBattleEnemys = function(enemies) {\\r\\n        this._srpgBattleEnemys = enemies;\\r\\n\\t\\tthis._enemies = enemies;\\r\\n    };\\r\\n\\r\\n    Game_Troop.prototype.pushMembers = function(enemy) {\\r\\n        this._enemies.push(enemy);\\r\\n    };\\r\\n\\r\\n    // セットアップ\\r\\n    var _SRPG_Game_Troop_setup = Game_Troop.prototype.setup;\\r\\n    Game_Troop.prototype.setup = function(troopId) {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            this.clear();\\r\\n            this._troopId = troopId;\\r\\n            this._enemies = [];\\r\\n            for (var i = 0; i < this.SrpgBattleEnemys().length; i++) {\\r\\n                var enemy = this.SrpgBattleEnemys()[i];\\r\\n                enemy.setScreenXy(200 + 240 * i, Graphics.height / 2 + 48);\\r\\n                this._enemies.push(enemy);\\r\\n            }\\r\\n            this.makeUniqueNames();\\r\\n        } else {\\r\\n            _SRPG_Game_Troop_setup.call(this, troopId);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    // EXPを返す\\r\\n    var _SRPG_Game_Troop_expTotal = Game_Troop.prototype.expTotal;\\r\\n    Game_Troop.prototype.expTotal = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            if (this.SrpgBattleEnemys() && this.SrpgBattleEnemys().length > 0) {\\r\\n                if (this.isAllDead()) {\\r\\n                    return _SRPG_Game_Troop_expTotal.call(this);\\r\\n                } else {\\r\\n                    var exp = 0;\\r\\n                    for (var i = 0; i < this.members().length; i++) {\\r\\n                        var enemy = this.members()[i];\\r\\n                        exp += enemy.exp();\\r\\n                    }\\r\\n                    return Math.floor(exp * _srpgBattleExpRate);\\r\\n                }\\r\\n            } else {\\r\\n                var actor = $gameParty.battleMembers()[0];\\r\\n                var exp = actor.nextLevelExp() - actor.currentLevelExp();\\r\\n                return Math.floor(exp * _srpgBattleExpRateForActors);\\r\\n            }\\r\\n        } else {\\r\\n            return _SRPG_Game_Troop_expTotal.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// ●Game_CharacterBase\\r\\n//====================================================================\\r\\n    //X座標を返す\\r\\n    Game_CharacterBase.prototype.posX = function() {\\r\\n        return this._x;\\r\\n    };\\r\\n\\r\\n    //Y座標を返す\\r\\n    Game_CharacterBase.prototype.posY = function() {\\r\\n        return this._y;\\r\\n    };\\r\\n\\t\\r\\n\\tGame_CharacterBase.prototype.shiftY = function() {\\r\\n\\t\\treturn 0;\\r\\n\\t}\\r\\n\\r\\n    //イベントかどうかを返す\\r\\n    Game_CharacterBase.prototype.isEvent = function() {\\r\\n        return false;\\r\\n    };\\r\\n\\r\\n    //プレイヤーの移動速度を変える（自動移動中は高速化）\\r\\n    var _SRPG_Game_CharacterBase_realMoveSpeed = Game_CharacterBase.prototype.realMoveSpeed;\\r\\n    Game_CharacterBase.prototype.realMoveSpeed = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true && \\r\\n           ($gameTemp.isAutoMoveDestinationValid() == true || $gameTemp.isDestinationValid() == true)) {\\r\\n            return 6;\\r\\n        } else {\\r\\n            return this._moveSpeed + (this.isDashing() ? 2 : 0);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    //戦闘中はキャラクターがすり抜けて移動するように変更する\\r\\n    var _SRPG_Game_CharacterBase_canPass = Game_CharacterBase.prototype.canPass;\\r\\n    Game_CharacterBase.prototype.canPass = function(x, y, d) {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            var x2 = $gameMap.roundXWithDirection(x, d);\\r\\n            var y2 = $gameMap.roundYWithDirection(y, d);\\r\\n            if (!$gameMap.isValid(x2, y2)) {\\r\\n                return false;\\r\\n            }\\r\\n            return true;\\r\\n        } else {\\r\\n            return _SRPG_Game_CharacterBase_canPass.call(this, x, y, d);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    //対立陣営であれば通り抜けられない（移動範囲演算用） オブジェクトも一緒に処理する\\r\\n    Game_CharacterBase.prototype.isSrpgCollidedWithEvents = function(x, y) {\\r\\n        var events = $gameMap.eventsXyNt(x, y);\\r\\n        return events.some(function(event) {\\r\\n            if ((event.isType() === 'actor' && $gameTemp.activeEvent().isType() === 'enemy') ||\\r\\n                (event.isType() === 'enemy' && $gameTemp.activeEvent().isType() === 'actor') ||\\r\\n                (event.isType() === 'object' && event.characterName() != '') && !event.isErased()) {\\r\\n                return true;\\r\\n            } else {\\r\\n                return false;\\r\\n            }\\r\\n        });\\r\\n    };\\r\\n\\r\\n    //移動可能かを判定する（移動範囲演算用）\\r\\n    Game_CharacterBase.prototype.srpgMoveCanPass = function(x, y, d, tag) {\\r\\n        var x2 = $gameMap.roundXWithDirection(x, d);\\r\\n        var y2 = $gameMap.roundYWithDirection(y, d);\\r\\n        if (!$gameMap.isValid(x2, y2)) {\\r\\n            return false;\\r\\n        }\\r\\n        if (this.isSrpgCollidedWithEvents(x2, y2)) {\\r\\n            return false;\\r\\n        }\\r\\n        if (this.isThrough()) {\\r\\n            return true;\\r\\n        }\\r\\n        if (($gameMap.terrainTag(x2, y2) > 0 && $gameMap.terrainTag(x2, y2) <= tag) ||\\r\\n            ($gameMap.terrainTag(x, y) > 0 && $gameMap.terrainTag(x, y) <= tag &&\\r\\n             $gameMap.isPassable(x2, y2, this.reverseDir(d)))) {\\r\\n            return true;\\r\\n        }\\r\\n        if (!this.isMapPassable(x, y, d)) {\\r\\n            return false;\\r\\n        }\\r\\n        return true;\\r\\n    };\\r\\n\\r\\n    //対立陣営がいるか調べる（探索用移動範囲演算）\\r\\n    Game_CharacterBase.prototype.isSrpgCollidedWithOpponentsUnit = function(x, y, d, route) {\\r\\n        var x2 = $gameMap.roundXWithDirection(x, d);\\r\\n        var y2 = $gameMap.roundYWithDirection(y, d);\\r\\n        var events = $gameMap.eventsXyNt(x2, y2);\\r\\n        return events.some(function(event) {\\r\\n            if ((event.isType() === 'actor' && $gameTemp.activeEvent().isType() === 'enemy') ||\\r\\n                (event.isType() === 'enemy' && $gameTemp.activeEvent().isType() === 'actor') && !event.isErased()) {\\r\\n                if ($gameTemp.isSrpgPriorityTarget()) {\\r\\n                    if ($gameTemp.isSrpgPriorityTarget() == event &&\\r\\n                        $gameTemp.isSrpgBestSearchRoute()[1].length > route.length) {\\r\\n                        $gameTemp.setSrpgBestSearchRoute([event, route]);\\r\\n                    }\\r\\n                } else {\\r\\n                    if ($gameTemp.isSrpgBestSearchRoute()[1].length > route.length) {\\r\\n                        $gameTemp.setSrpgBestSearchRoute([event, route]);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        });\\r\\n    };\\r\\n\\r\\n    //移動範囲の計算\\r\\n    Game_CharacterBase.prototype.makeMoveTable = function(x, y, move, route, actor) {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tfunction isPassableTile(currentX, currentY, x, y, actor){\\r\\n\\t\\t\\tif(ENGINE_SETTINGS.USE_TILE_PASSAGE && !$statCalc.isFlying(actor)){\\r\\n\\t\\t\\t\\tvar direction = 0;\\t\\t\\t\\r\\n\\t\\t\\t\\tif(currentX == x){\\r\\n\\t\\t\\t\\t\\tif(currentY > y){\\r\\n\\t\\t\\t\\t\\t\\tdirection = 8; //up\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\tdirection = 2; //down\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tif(currentX > x){\\r\\n\\t\\t\\t\\t\\t\\tdirection = 4; //left\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\tdirection = 6; //right\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tif(!_this.isMapPassable(currentX, currentY, direction)){\\r\\n\\t\\t\\t\\t\\treturn false;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif($gameMap.regionId(x, y) == 0){\\r\\n\\t\\t\\t\\treturn false;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif($gameTemp._MoveTable[x] == undefined){\\r\\n\\t\\t\\t\\treturn false;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif($gameTemp._MoveTable[x][y] == undefined){\\r\\n\\t\\t\\t\\treturn false;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif($gameMap.regionId(x, y) % 8 == 1 && !$statCalc.isFlying(actor)){\\r\\n\\t\\t\\t\\treturn false;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif($gameMap.regionId(x, y) % 8 == 2 && !$statCalc.canBeOnLand(actor) && !$statCalc.isFlying(actor)){\\r\\n\\t\\t\\t\\treturn false;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif($gameMap.regionId(x, y) % 8 == 3 && !$statCalc.canBeOnWater(actor) && !$statCalc.isFlying(actor)){\\r\\n\\t\\t\\t\\treturn false;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif($gameMap.regionId(x, y) % 8 == 4 && !$statCalc.canBeOnSpace(actor)){\\r\\n\\t\\t\\t\\treturn false;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn $statCalc.isFreeSpace({x: x, y: y}, actor.isActor() ? \\\"enemy\\\" : \\\"actor\\\");\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tvar currentRegion = $gameMap.regionId(x, y) % 8; //1 air, 2 land, 3 water, 4 space\\r\\n\\t\\tvar moveCost = 1;\\r\\n\\t\\tif(route.length > 1){//no movecost for the start tile\\r\\n\\t\\t\\tvar taggedCost = $gameMap.SRPGTerrainTag(x, y);\\r\\n\\t\\t\\tif(taggedCost > 1){\\r\\n\\t\\t\\t\\tif(currentRegion == 4 || !$statCalc.isFlying(actor)){\\r\\n\\t\\t\\t\\t\\tmoveCost = taggedCost;\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\t\\t\\r\\n\\r\\n\\t\\tif(currentRegion == 3 && !$statCalc.isFlying(actor)){\\r\\n\\t\\t\\tif($statCalc.canBeOnWater(actor, \\\"water\\\") < 2){\\r\\n\\t\\t\\t\\tmoveCost*=2;\\r\\n\\t\\t\\t}\\r\\n\\t\\t} \\t\\t\\r\\n\\t\\t\\r\\n        if (move <= 0) {\\r\\n            return;\\r\\n        }\\r\\n        //上方向を探索\\r\\n        if (route[route.length - 1] != 2) {\\r\\n            if (isPassableTile(x, y, x, y-1, actor)) {\\r\\n                if ($gameTemp.MoveTable(x, $gameMap.roundY(y - 1))[0] < move - moveCost) {\\r\\n                    if ($gameTemp.MoveTable(x, $gameMap.roundY(y - 1))[0] < 0) {\\r\\n                        $gameTemp.pushMoveList([x, $gameMap.roundY(y - 1), false]);\\r\\n                    }\\r\\n                    $gameTemp.setMoveTable(x, $gameMap.roundY(y - 1), move - moveCost, route.concat(8));\\r\\n                    this.makeMoveTable(x, $gameMap.roundY(y - 1), move - moveCost, route.concat(8), actor);\\r\\n                }\\r\\n            } else if ($gameTemp.isSrpgBestSearchFlag() == true) {\\r\\n                this.isSrpgCollidedWithOpponentsUnit(x, y, 8, route);\\r\\n            }\\r\\n        }\\r\\n        //右方向を探索\\r\\n        if (route[route.length - 1] != 4) {\\r\\n            if (isPassableTile(x, y, x+1, y, actor)) {\\r\\n                if ($gameTemp.MoveTable($gameMap.roundX(x + 1), y)[0] < move - moveCost) {\\r\\n                    if ($gameTemp.MoveTable($gameMap.roundX(x + 1), y)[0] < 0) {\\r\\n                        $gameTemp.pushMoveList([$gameMap.roundX(x + 1), y, false]);\\r\\n                    }\\r\\n                    $gameTemp.setMoveTable($gameMap.roundX(x + 1), y, move - moveCost, route.concat(6));\\r\\n                    this.makeMoveTable($gameMap.roundX(x + 1), y, move - moveCost, route.concat(6), actor);\\r\\n                }\\r\\n            } else if ($gameTemp.isSrpgBestSearchFlag() == true) {\\r\\n                this.isSrpgCollidedWithOpponentsUnit(x, y, 6, route);\\r\\n            }\\r\\n        }\\r\\n        //左方向を探索\\r\\n        if (route[route.length - 1] != 6) {\\r\\n            if (isPassableTile(x, y, x-1, y, actor)) {\\r\\n                if ($gameTemp.MoveTable($gameMap.roundX(x - 1), y)[0] < move - moveCost) {\\r\\n                    if ($gameTemp.MoveTable($gameMap.roundX(x - 1), y)[0] < 0) {\\r\\n                        $gameTemp.pushMoveList([$gameMap.roundX(x - 1), y, false]);\\r\\n                    }\\r\\n                    $gameTemp.setMoveTable($gameMap.roundX(x - 1), y, move - moveCost, route.concat(4));\\r\\n                    this.makeMoveTable($gameMap.roundX(x - 1), y, move - moveCost, route.concat(4), actor);\\r\\n                }\\r\\n            } else if ($gameTemp.isSrpgBestSearchFlag() == true) {\\r\\n                this.isSrpgCollidedWithOpponentsUnit(x, y, 4, route);\\r\\n            }\\r\\n        }\\r\\n        //下方向を探索\\r\\n        if (route[route.length - 1] != 8) {\\r\\n            if (isPassableTile(x, y, x, y+1, actor)) {\\r\\n                if ($gameTemp.MoveTable(x, $gameMap.roundY(y + 1))[0] < move - moveCost) {\\r\\n                    if ($gameTemp.MoveTable(x, $gameMap.roundY(y + 1))[0] < 0) {\\r\\n                        $gameTemp.pushMoveList([x, $gameMap.roundY(y + 1), false]);\\r\\n                    }\\r\\n                    $gameTemp.setMoveTable(x, $gameMap.roundY(y + 1), move - moveCost, route.concat(2));\\r\\n                    this.makeMoveTable(x, $gameMap.roundY(y + 1), move - moveCost, route.concat(2), actor);\\r\\n                }\\r\\n            } else if ($gameTemp.isSrpgBestSearchFlag() == true) {\\r\\n                this.isSrpgCollidedWithOpponentsUnit(x, y, 2, route);\\r\\n            }\\r\\n        }\\r\\n    };\\r\\n\\r\\n    //通行可能かを判定する（攻撃射程演算用）\\r\\n    Game_CharacterBase.prototype.srpgRangeCanPass = function(x, y, d) {\\r\\n        var x2 = $gameMap.roundXWithDirection(x, d);\\r\\n        var y2 = $gameMap.roundYWithDirection(y, d);\\r\\n        if (!$gameMap.isValid(x2, y2)) {\\r\\n            return false;\\r\\n        }\\r\\n        if ($gameMap.terrainTag(x2, y2) == 7) {\\r\\n            return false;\\r\\n        }\\r\\n        return true;\\r\\n    };\\r\\n    \\r\\n    //特殊射程の処理\\r\\n    Game_CharacterBase.prototype.srpgRangeExtention = function(x, y, oriX, oriY, skill, range) {\\r\\n        switch (skill && skill.meta.specialRange) {\\r\\n        case 'king': \\r\\n            if ((Math.abs(x - oriX) <= range / 2) && (Math.abs(y - oriY) <= range / 2)) {\\r\\n                return true;\\r\\n            } else {\\r\\n                return false;\\r\\n            }\\r\\n        case 'queen': \\r\\n            if ((x == oriX || y == oriY) || (Math.abs(x - oriX) == Math.abs(y - oriY))) {\\r\\n                return true;\\r\\n            } else {\\r\\n                return false;\\r\\n            }\\r\\n        case 'luke': \\r\\n            if (x == oriX || y == oriY) {\\r\\n                return true;\\r\\n            } else {\\r\\n                return false;\\r\\n            }\\r\\n        case 'bishop': \\r\\n            if (Math.abs(x - oriX) == Math.abs(y - oriY)) {\\r\\n                return true;\\r\\n            } else {\\r\\n                return false;\\r\\n            }\\r\\n        case 'knight': \\r\\n            if (!((x == oriX || y == oriY) || (Math.abs(x - oriX) == Math.abs(y - oriY)))) {\\r\\n                return true;\\r\\n            } else {\\r\\n                return false;\\r\\n            }\\r\\n        default:\\r\\n            return true;\\r\\n        }\\r\\n    };\\r\\n\\r\\n    //攻撃射程の計算\\r\\n    Game_CharacterBase.prototype.makeRangeTable = function(x, y, range, route, oriX, oriY, skill) {\\r\\n        if (range <= 0) {\\r\\n            return;\\r\\n        }\\r\\n        //上方向を探索\\r\\n        if (route[route.length - 1] != 2) {\\r\\n            if (this.srpgRangeCanPass(x, y, 8)) {\\r\\n                //if ($gameTemp.RangeTable(x, $gameMap.roundY(y - 1))[0] < range - 1) {\\r\\n                    if (this.srpgRangeExtention(x, $gameMap.roundY(y - 1), oriX, oriY, skill, range + route.length - 1) == true) {\\r\\n                        if ($gameTemp.MoveTable(x, $gameMap.roundY(y - 1))[0] < 0 && $gameTemp.RangeTable(x, $gameMap.roundY(y - 1))[0] < 0) {\\r\\n                            $gameTemp.pushRangeList([x, $gameMap.roundY(y - 1), true]);\\r\\n                        }\\r\\n                        $gameTemp.setRangeTable(x, $gameMap.roundY(y - 1), range - 1, route.concat(8));\\r\\n                    }\\r\\n                    this.makeRangeTable(x, $gameMap.roundY(y - 1), range - 1, route.concat(8), oriX, oriY, skill);\\r\\n                //}\\r\\n            }\\r\\n        }\\r\\n        //右方向を探索\\r\\n        if (route[route.length - 1] != 4) {\\r\\n            if (this.srpgRangeCanPass(x, y, 6)) {\\r\\n                //if ($gameTemp.RangeTable($gameMap.roundX(x + 1), y)[0] < range - 1) {\\r\\n                    if (this.srpgRangeExtention($gameMap.roundX(x + 1), y, oriX, oriY, skill, range + route.length - 1) == true) {\\r\\n                        if ($gameTemp.MoveTable($gameMap.roundX(x + 1), y)[0] < 0 && $gameTemp.RangeTable($gameMap.roundX(x + 1), y)[0] < 0) {\\r\\n                            $gameTemp.pushRangeList([$gameMap.roundX(x + 1), y, true]);\\r\\n                        }\\r\\n                        $gameTemp.setRangeTable($gameMap.roundX(x + 1), y, range - 1, route.concat(6));\\r\\n                    }\\r\\n                    this.makeRangeTable($gameMap.roundX(x + 1), y, range - 1, route.concat(6), oriX, oriY, skill);\\r\\n                //}\\r\\n            }\\r\\n        }\\r\\n        //左方向を探索\\r\\n        if (route[route.length - 1] != 6) {\\r\\n            if (this.srpgRangeCanPass(x, y, 4)) {\\r\\n                //if ($gameTemp.RangeTable($gameMap.roundX(x - 1), y)[0] < range - 1) {\\r\\n                    if (this.srpgRangeExtention($gameMap.roundX(x - 1), y, oriX, oriY, skill, range + route.length - 1) == true) {\\r\\n                        if ($gameTemp.MoveTable($gameMap.roundX(x - 1), y)[0] < 0 && $gameTemp.RangeTable($gameMap.roundX(x - 1), y)[0] < 0) {\\r\\n                            $gameTemp.pushRangeList([$gameMap.roundX(x - 1), y, true]);\\r\\n                        }\\r\\n                        $gameTemp.setRangeTable($gameMap.roundX(x - 1), y, range - 1, route.concat(4));\\r\\n                    }\\r\\n                    this.makeRangeTable($gameMap.roundX(x - 1), y, range - 1, route.concat(4), oriX, oriY, skill);\\r\\n                //}\\r\\n            }\\r\\n        }\\r\\n        //下方向を探索\\r\\n        if (route[route.length - 1] != 8) {\\r\\n            if (this.srpgRangeCanPass(x, y, 2)) {\\r\\n                //if ($gameTemp.RangeTable(x, $gameMap.roundY(y + 1))[0] < range - 1) {\\r\\n                    if (this.srpgRangeExtention(x, $gameMap.roundY(y + 1), oriX, oriY, skill, range + route.length - 1) == true) {\\r\\n                        if ($gameTemp.MoveTable(x, $gameMap.roundY(y + 1))[0] < 0 && $gameTemp.RangeTable(x, $gameMap.roundY(y + 1))[0] < 0) {\\r\\n                            $gameTemp.pushRangeList([x, $gameMap.roundY(y + 1), true]);\\r\\n                        }\\r\\n                        $gameTemp.setRangeTable(x, $gameMap.roundY(y + 1), range - 1, route.concat(2));\\r\\n                    }\\r\\n                    this.makeRangeTable(x, $gameMap.roundY(y + 1), range - 1, route.concat(2), oriX, oriY, skill);\\r\\n                //}\\r\\n            }\\r\\n        }\\r\\n    };\\r\\n\\r\\n    //移動可能かを判定する（イベント出現時用）\\r\\n    Game_CharacterBase.prototype.srpgAppearCanPass = function(x, y, d) {\\r\\n        var x2 = $gameMap.roundXWithDirection(x, d);\\r\\n        var y2 = $gameMap.roundYWithDirection(y, d);\\r\\n        if (!$gameMap.isValid(x2, y2)) {\\r\\n            return false;\\r\\n        }\\r\\n        if (!this.isMapPassable(x, y, d)) {\\r\\n            return false;\\r\\n        }\\r\\n        return true;\\r\\n    };\\r\\n\\r\\n    //出現可能場所の計算\\r\\n    Game_CharacterBase.prototype.makeAppearPoint = function(event, x, y) {\\r\\n        var events = $gameMap.eventsXyNt(x, y);\\r\\n        if (events.length == 0 || (events.length == 1 && events[0] == event)) {\\r\\n            return [x,y];\\r\\n        }\\r\\n        //上方向を探索\\r\\n        if (this.srpgAppearCanPass(x, y, 8)) {\\r\\n            return this.makeAppearPoint(event, x, y - 1);\\r\\n        }\\r\\n        //右方向を探索\\r\\n        if (this.srpgAppearCanPass(x, y, 6)) {\\r\\n            return this.makeAppearPoint(event, x + 1, y);\\r\\n        }\\r\\n        //左方向を探索\\r\\n        if (this.srpgAppearCanPass(x, y, 4)) {\\r\\n            return this.makeAppearPoint(event, x - 1, y);\\r\\n        }\\r\\n        //下方向を探索\\r\\n        if (this.srpgAppearCanPass(x, y, 2)) {\\r\\n            return this.makeAppearPoint(event, x, y + 1);\\r\\n        }\\r\\n    };\\r\\n\\t\\r\\n\\tvar Game_CharacterBase_update = Game_CharacterBase.prototype.update;\\r\\n\\tGame_CharacterBase.prototype.update = function() {\\r\\n\\t\\tGame_CharacterBase_update.call(this);\\r\\n\\t\\t\\r\\n\\t}\\r\\n\\t\\r\\n\\tvar Game_CharacterBase_initialize = Game_CharacterBase.prototype.initialize;\\r\\n\\tGame_CharacterBase.prototype.initialize = function() {\\r\\n\\t\\tGame_CharacterBase_initialize.call(this);\\r\\n\\t\\tthis._floatOffset = 0;\\r\\n\\t\\tthis._floatAmount = 10;\\r\\n\\t\\tthis._floating = false;\\r\\n\\t}\\r\\n\\t\\r\\n\\tvar Game_CharacterBase_screenY = Game_CharacterBase.prototype.screenY;\\r\\n\\tGame_CharacterBase.prototype.screenY = function() {\\r\\n\\t\\tvar value = Game_CharacterBase_screenY.call(this);\\r\\n\\t\\tvar battlerArray = $gameSystem.EventToUnit(this._eventId);\\r\\n\\t\\tif(battlerArray && $statCalc.isFlying(battlerArray[1])){\\r\\n\\t\\t\\tif(!this._floating){\\r\\n\\t\\t\\t\\tthis._floatOffset = 0;\\r\\n\\t\\t\\t\\tthis._floating = true;\\r\\n\\t\\t\\t\\tthis._floatTimer = this._floatAmount;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(this._floatTimer > 0) {\\r\\n\\t\\t\\t\\tthis._floatTimer--;\\r\\n\\t\\t\\t\\tthis._floatOffset--;\\r\\n\\t\\t\\t}\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif(this._floating){\\r\\n\\t\\t\\t\\tthis._floatOffset = this._floatAmount * -1;\\r\\n\\t\\t\\t\\tthis._floating = false;\\r\\n\\t\\t\\t\\tthis._floatTimer = this._floatAmount;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(this._floatTimer > 0) {\\r\\n\\t\\t\\t\\tthis._floatTimer--;\\r\\n\\t\\t\\t\\tthis._floatOffset++;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\t\\r\\n\\t\\tvalue+=this._floatOffset;\\r\\n\\t\\treturn Math.round(value);\\r\\n\\t};\\r\\n\\t\\r\\n\\t/*Extensions to character map animations*/\\r\\n\\t\\r\\n\\tGame_CharacterBase.prototype.requestAnimation = function(animationId, options) {\\r\\n\\t\\tthis._animationId = animationId;\\r\\n\\t\\tthis._animationOptions = options;\\r\\n\\t};\\r\\n\\t\\r\\n\\tSprite_Character.prototype.setupAnimation = function() {\\r\\n\\t\\tif (this._character.animationId() > 0) {\\r\\n\\t\\t\\tvar animation = $dataAnimations[this._character.animationId()];\\r\\n\\t\\t\\tvar animOptions = this._character._animationOptions;\\r\\n\\t\\t\\tif(animOptions){\\r\\n\\t\\t\\t\\tObject.keys(animOptions).forEach(function(key){\\r\\n\\t\\t\\t\\t\\tanimation[key] = animOptions[key];\\r\\n\\t\\t\\t\\t});\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthis.startAnimation(animation, false, 0);\\r\\n\\t\\t\\tthis._character.startAnimation();\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\t\\r\\n\\tSprite_Animation.prototype.update = function() {\\r\\n\\t\\tSprite.prototype.update.call(this);\\r\\n\\t\\tthis.updateMain();\\r\\n\\t\\tthis.updateFlash();\\r\\n\\t\\tthis.updateScreenFlash();\\r\\n\\t\\tthis.updateHiding();\\r\\n\\t\\tSprite_Animation._checker1 = {};\\r\\n\\t\\tSprite_Animation._checker2 = {};\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tthis.scale.x = 1;\\r\\n\\t\\tthis.scale.y = 1;\\t\\r\\n\\t\\tthis.rotation = 0;\\r\\n\\t\\tif(this._animation.direction){\\t\\t\\t\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif(this._animation.direction == \\\"down\\\"){\\r\\n\\t\\t\\t\\tthis.scale.y = -1;\\t\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(this._animation.direction == \\\"left\\\" || this._animation.direction == \\\"right\\\"){\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tthis.scale.x = -1;\\t\\t\\r\\n\\t\\t\\t\\tthis.rotation = 90 * Math.PI / 180;\\t\\t\\t\\t\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif(this._animation.direction == \\\"left\\\"){\\r\\n\\t\\t\\t\\tthis.scale.y = -1;\\t\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif(this._animation.offset){\\r\\n\\t\\t\\t\\tvar offset = this._animation.offset[this._animation.direction];\\t\\r\\n\\t\\t\\t\\tif(offset){\\r\\n\\t\\t\\t\\t\\tthis.x+=offset.x;\\r\\n\\t\\t\\t\\t\\tthis.y+=offset.y;\\r\\n\\t\\t\\t\\t}\\t\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif(this._animation.scale){\\r\\n\\t\\t\\tthis.scale.y*=this._animation.scale;\\r\\n\\t\\t\\tthis.scale.x*=this._animation.scale;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t};\\r\\n\\t\\r\\n\\t\\r\\n//====================================================================\\r\\n// ●Game_Player\\r\\n//====================================================================\\r\\n    //プレイヤーの画像を変更する\\r\\n\\t\\r\\n\\tGame_Player.prototype.initialize = function() {\\r\\n    Game_Character.prototype.initialize.call(this);\\r\\n\\t\\tthis.setTransparent($dataSystem.optTransparent);\\r\\n\\t\\tthis._topSpeed = ENGINE_SETTINGS.CURSOR_SPEED || 4;\\r\\n\\t\\tthis._initialSpeed = this._topSpeed;\\r\\n\\t\\tthis._moveSpeed = this._initialSpeed + 1;\\r\\n\\t\\tthis._tileCounter = 0;\\r\\n\\t\\tthis._speedResetCounter = 0;\\r\\n\\t\\tthis._followSpeed = 0;\\r\\n\\t};\\r\\n\\t\\r\\n\\tGame_Player.prototype.setMoveSpeed = function(moveSpeed) {\\r\\n\\t\\tthis._moveSpeed = moveSpeed;\\r\\n\\t};\\r\\n\\t\\r\\n    var _SRPG_Game_Player_refresh = Game_Player.prototype.refresh;\\r\\n    Game_Player.prototype.refresh = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            var characterName = 'srpg_set';\\r\\n            var characterIndex = 0;\\r\\n            this.setImage(characterName, characterIndex);\\r\\n            this._followers.refresh();\\r\\n        } else {\\r\\n            _SRPG_Game_Player_refresh.call(this);\\r\\n        }\\r\\n    };\\r\\n\\t\\r\\n\\tGame_Player.prototype.setFollowSpeed = function(speed) {\\r\\n\\t\\tthis._moveSpeed = speed;\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_Player.prototype.clearFollowSpeed = function() {\\r\\n\\t\\tthis._moveSpeed = this._topSpeed + 1;\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_Player.prototype.update = function(sceneActive) {\\t\\t\\r\\n\\t\\t/*if(this._followSpeed){\\r\\n\\t\\t\\tthis._moveSpeed = this._followSpeed;\\r\\n\\t\\t}else if(Input.isPressed('shift')){\\r\\n\\t\\t\\tthis._moveSpeed = ENGINE_SETTINGS.CURSOR_MAX_SPEED || this._topSpeed;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif(this._tileCounter > 1){\\r\\n\\t\\t\\t\\tthis._moveSpeed = this._topSpeed;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tif(this._speedResetCounter <= 0){\\r\\n\\t\\t\\t\\t\\tthis._moveSpeed = this._initialSpeed;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tthis._speedResetCounter--;\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}*/\\r\\n\\t\\tif(!this._moveSpeed){ //support for old save files\\r\\n\\t\\t\\tthis._moveSpeed = ENGINE_SETTINGS.CURSOR_SPEED || 4;\\r\\n\\t\\t}\\t\\r\\n\\t\\t//console.log(\\\"move speed: \\\"+this._moveSpeed);\\r\\n\\t\\t\\r\\n\\t\\tvar lastScrolledX = this.scrolledX();\\r\\n\\t\\tvar lastScrolledY = this.scrolledY();\\r\\n\\t\\tvar wasMoving = this.isMoving();\\r\\n\\t\\tthis.updateDashing();\\r\\n\\t\\tif (sceneActive) {\\r\\n\\t\\t\\tthis.moveByInput();\\r\\n\\t\\t}\\r\\n\\t\\tGame_Character.prototype.update.call(this);\\r\\n\\t\\tthis.updateScroll(lastScrolledX, lastScrolledY);\\r\\n\\t\\tthis.updateVehicle();\\r\\n\\t\\tif (!this.isMoving()) {\\r\\n\\t\\t\\tthis.updateNonmoving(wasMoving);\\r\\n\\t\\t}\\r\\n\\t\\tthis._followers.update();\\r\\n\\t};\\r\\n\\r\\n    //プレイヤーの自動移動を設定する\\r\\n    var _SRPG_Game_Player_moveByInput = Game_Player.prototype.moveByInput;\\r\\n    Game_Player.prototype.moveByInput = function() {\\t\\t\\r\\n\\t\\tif(!this.getInputDirection()){\\t\\t\\t\\r\\n\\t\\t\\tif(this._tileCounter > 0){\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tthis._speedResetCounter = 10;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthis._tileCounter = 0;\\t\\t\\r\\n\\t\\t} else if(!this.isMoving()){\\r\\n\\t\\t\\tthis._tileCounter++;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\t if ($gameSystem.isSRPGMode() == true && $gameTemp.isAutoMoveDestinationValid() == true &&\\r\\n\\t\\t\\t!this.isMoving()) {\\r\\n\\t\\t\\tvar x = $gameTemp.autoMoveDestinationX() - this.x;\\r\\n\\t\\t\\tvar y = $gameTemp.autoMoveDestinationY() - this.y;\\r\\n\\t\\t\\tif ($gameMap.isLoopHorizontal() == true) {\\r\\n\\t　　        var minDisX = Math.abs($gameTemp.autoMoveDestinationX() - this.x);\\r\\n\\t\\t\\t\\tvar destX = $gameTemp.autoMoveDestinationX() > this.x ? $gameTemp.autoMoveDestinationX() - $gameMap.width() : $gameTemp.autoMoveDestinationX() + $gameMap.width();\\r\\n\\t\\t\\t\\tvar disX = Math.abs(destX - this.x);\\r\\n\\t\\t\\t\\tx = minDisX < disX ? x : x * -1;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif ($gameMap.isLoopVertical() == true) {\\r\\n\\t\\t　　    var minDisY = Math.abs($gameTemp.autoMoveDestinationY() - this.y);\\r\\n\\t\\t\\t\\tvar destY = $gameTemp.autoMoveDestinationY() > this.y ? $gameTemp.autoMoveDestinationY() - $gameMap.height() : $gameTemp.autoMoveDestinationY() + $gameMap.height();\\r\\n\\t\\t\\t\\tvar disY = Math.abs(destY - this.y);\\r\\n\\t\\t\\t\\ty = minDisY < disY ? y : y * -1;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (x < 0) {\\r\\n\\t\\t\\t\\tif (y < 0) {\\r\\n\\t\\t\\t\\t\\tthis.moveDiagonally(4, 8);\\r\\n\\t\\t\\t\\t} else if (y == 0) {\\r\\n\\t\\t\\t\\t\\tthis.moveStraight(4);\\r\\n\\t\\t\\t\\t} else if (y > 0) {\\r\\n\\t\\t\\t\\t\\tthis.moveDiagonally(4, 2);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t} else if (x == 0) {\\r\\n\\t\\t\\t\\tif (y < 0) {\\r\\n\\t\\t\\t\\t\\tthis.moveStraight(8);\\r\\n\\t\\t\\t\\t} else if (y == 0) {\\r\\n\\t\\t\\t\\t\\t$gameTemp.setAutoMoveDestinationValid(false);\\r\\n\\t\\t\\t\\t\\t$gameTemp.setAutoMoveDestination(-1, -1);\\r\\n\\t\\t\\t\\t} else if (y > 0) {\\r\\n\\t\\t\\t\\t\\tthis.moveStraight(2);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t} else if (x > 0) {\\r\\n\\t\\t\\t\\tif (y < 0) {\\r\\n\\t\\t\\t\\t\\tthis.moveDiagonally(6, 8);\\r\\n\\t\\t\\t\\t} else if (y == 0) {\\r\\n\\t\\t\\t\\t\\tthis.moveStraight(6);\\r\\n\\t\\t\\t\\t} else if (y > 0) {\\r\\n\\t\\t\\t\\t\\tthis.moveDiagonally(6, 2);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\t\\r\\n\\t\\t//\\tmapRetargetLock\\r\\n\\t\\t\\tif (!this.isMoving() && this.canMove()) {\\r\\n\\t\\t\\t\\tvar direction = this.getInputDirection();\\r\\n\\t\\t\\t\\tvar validDestination = true;\\r\\n\\t\\t\\t\\tif($gameTemp.mapRetargetLock && $gameTemp.currentMapTargetTiles && $gameTemp.currentMapTargetTiles.length){\\r\\n\\t\\t\\t\\t\\t// up: 8 down: 2 left: 4 right: 6\\r\\n\\t\\t\\t\\t\\tvar x = this._realX;\\r\\n\\t\\t\\t\\t\\tvar y = this._realY;\\r\\n\\t\\t\\t\\t\\tif(direction == 8){\\r\\n\\t\\t\\t\\t\\t\\ty--;\\r\\n\\t\\t\\t\\t\\t} else if(direction == 2){\\r\\n\\t\\t\\t\\t\\t\\ty++;\\r\\n\\t\\t\\t\\t\\t} else if(direction == 6){\\r\\n\\t\\t\\t\\t\\t\\tx++;\\r\\n\\t\\t\\t\\t\\t} else if(direction == 4){\\r\\n\\t\\t\\t\\t\\t\\tx--;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tvalidDestination = false;\\r\\n\\t\\t\\t\\t\\tctr = 0;\\r\\n\\t\\t\\t\\t\\twhile(!validDestination && ctr < $gameTemp.currentMapTargetTiles.length){\\r\\n\\t\\t\\t\\t\\t\\tvar coords = $gameTemp.currentMapTargetTiles[ctr++];\\r\\n\\t\\t\\t\\t\\t\\tif(coords[0] == x && coords[1] == y){\\r\\n\\t\\t\\t\\t\\t\\t\\tvalidDestination = true;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(validDestination){\\r\\n\\t\\t\\t\\t\\tif (direction > 0) {\\r\\n\\t\\t\\t\\t\\t\\t$gameTemp.clearDestination();\\r\\n\\t\\t\\t\\t\\t} else if ($gameTemp.isDestinationValid()){\\r\\n\\t\\t\\t\\t\\t\\tvar x = $gameTemp.destinationX();\\r\\n\\t\\t\\t\\t\\t\\tvar y = $gameTemp.destinationY();\\r\\n\\t\\t\\t\\t\\t\\tdirection = this.findDirectionTo(x, y);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tif (direction > 0) {\\r\\n\\t\\t\\t\\t\\t\\tthis.executeMove(direction);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}      \\r\\n    };\\r\\n\\t\\r\\n\\tGame_Player.prototype.updateEncounterCount = function() {\\r\\n\\t\\t\\r\\n\\t};\\r\\n\\t\\r\\n/* 戦闘中のイベント起動に関する処理\\r\\n * 戦闘中、通常のイベント内容は起動しないようにする\\r\\n * 戦闘中はユニットが選択されたと判断して、移動範囲演算とステータスの表示を行う(行動可能アクターなら行動する)。\\r\\n*/\\r\\n    //戦闘中、ユニット上で決定キーが押された時の処理\\r\\n    var _SRPG_Game_Player_startMapEvent = Game_Player.prototype.startMapEvent;\\r\\n    Game_Player.prototype.startMapEvent = function(x, y, triggers, normal) {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n\\t\\t\\tif (!$gameMap.isEventRunning() && $gameSystem.isBattlePhase() === 'actor_phase') {\\r\\n\\t\\t\\t\\tif(!$SRWGameState.updateMapEvent(x, y, triggers)){\\r\\n\\t\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\r\\n                if ($gameSystem.isSubBattlePhase() === 'normal') {\\r\\n                    \\r\\n                } else if ($gameSystem.isSubBattlePhase() === 'twin_selection') {\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\t\\t\\r\\n                } \\r\\n            }\\r\\n        } else {\\r\\n            _SRPG_Game_Player_startMapEvent.call(this, x, y, triggers, normal);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    //戦闘中、サブフェーズの状況に応じてプレイヤーの移動を制限する\\r\\n    var _SRPG_Game_Player_canMove = Game_Player.prototype.canMove;\\r\\n    Game_Player.prototype.canMove = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            /*if ($gameSystem.srpgWaitMoving() == true ||\\r\\n                $gameSystem.isSubBattlePhase() === 'status_window' ||\\r\\n             //   $gameSystem.isSubBattlePhase() === 'actor_command_window' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'post_move_command_window' ||\\t\\t\\t\\t\\r\\n                $gameSystem.isSubBattlePhase() === 'battle_window' ||\\r\\n                $gameSystem.isBattlePhase() === 'auto_actor_phase' ||\\r\\n                $gameSystem.isBattlePhase() === 'AI_phase' ||\\r\\n                $gameSystem.isSubBattlePhase() === 'rewards_display' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'level_up_display' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'process_death_queue' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'process_death' || \\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'pause_menu' || \\t\\t\\t\\t\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'event_before_battle' || \\t\\t\\t\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'battle_basic' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'spirit_activation' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'after_battle' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'actor_map_target' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'map_attack_animation' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'process_map_attack_queue' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'map_spirit_animation' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'confirm_boarding' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'enemy_unit_summary' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'confirm_end_turn'\\t||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'enemy_targeting_display' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'enemy_attack' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'await_character_anim' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'process_destroy_transform_queue'\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t){\\r\\n                return false;\\r\\n            }*/\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif(!$SRWGameState.canCursorMove()){\\r\\n\\t\\t\\t\\treturn false;\\r\\n\\t\\t\\t}\\r\\n        }\\r\\n\\t\\tif($gameSystem.isSubBattlePhase() === 'rearrange_deploys'){\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t}\\r\\n        return _SRPG_Game_Player_canMove.call(this);\\r\\n    };\\r\\n\\r\\n    //戦闘中、サブフェーズの状況に応じて決定キー・タッチの処理を変える\\r\\n    var _SRPG_Game_Player_triggerAction = Game_Player.prototype.triggerAction;\\r\\n    Game_Player.prototype.triggerAction = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n\\t\\t\\tif(!$SRWGameState.updateTriggerAction(this)){\\r\\n\\t\\t\\t\\treturn false;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\treturn _SRPG_Game_Player_triggerAction.call(this);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t//TODO remove these checks once all states are migrated\\r\\n            /*if ($gameSystem.srpgWaitMoving() == true ||\\r\\n                //$gameTemp.isAutoMoveDestinationValid() == true ||\\r\\n                //$gameSystem.isSubBattlePhase() === 'actor_command_window' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'post_move_command_window' ||\\r\\n                $gameSystem.isSubBattlePhase() === 'battle_window' ||\\r\\n                $gameSystem.isBattlePhase() === 'auto_actor_phase' ||\\r\\n                $gameSystem.isBattlePhase() === 'AI_phase' || \\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'rewards_display' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'level_up_display' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'battle_basic' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'spirit_activation' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'after_battle' ) {\\r\\n                return false;\\r\\n            }  else {\\r\\n                \\r\\n            }\\t*/\\t\\t\\r\\n        } else {\\r\\n            return _SRPG_Game_Player_triggerAction.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    //戦闘中、隣接するイベントへの起動判定は行わない\\r\\n    var _SRPG_Game_Player_checkEventTriggerThere = Game_Player.prototype.checkEventTriggerThere;\\r\\n    Game_Player.prototype.checkEventTriggerThere = function(triggers) {\\r\\n        if ($gameSystem.isSRPGMode() == false) {\\r\\n            _SRPG_Game_Player_checkEventTriggerThere.call(this, triggers);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    //戦闘中、接触による起動判定は行わない\\r\\n    var _SRPG_Game_Player_checkEventTriggerTouch = Game_Player.prototype.checkEventTriggerTouch;\\r\\n    Game_Player.prototype.checkEventTriggerTouch = function(x, y) {\\r\\n        if ($gameSystem.isSRPGMode() == false) {\\r\\n            _SRPG_Game_Player_checkEventTriggerTouch.call(this, x, y);\\r\\n        }\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// ●Game_Follower\\r\\n//====================================================================\\r\\n    //戦闘中、フォロワーが表示されないようにする\\r\\n    var _SRPG_Game_Follower_refresh = Game_Follower.prototype.refresh;\\r\\n    Game_Follower.prototype.refresh = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            this.setImage('', 0);\\r\\n        } else {\\r\\n            _SRPG_Game_Follower_refresh.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// ●Game_Event\\r\\n//====================================================================\\r\\n    //初期化処理\\r\\n    var _SRPG_Game_Event_initMembers = Game_Event.prototype.initMembers;\\r\\n    Game_Event.prototype.initMembers = function() {\\r\\n        _SRPG_Game_Event_initMembers.call(this);\\r\\n        this._srpgForceRoute = [];\\r\\n        this._srpgEventType = '';\\r\\n    };\\r\\n\\r\\n    //ゲームページを返す\\r\\n    Game_Event.prototype.pageIndex = function() {\\r\\n        return this._pageIndex;\\r\\n    };\\r\\n\\r\\n    //イベントかどうかを返す\\r\\n    Game_Event.prototype.isEvent = function() {\\r\\n        return true;\\r\\n    };\\r\\n\\r\\n    //消去済みかどうかを返す\\r\\n    Game_Event.prototype.isErased = function() {\\r\\n        return this._erased;\\r\\n    };\\r\\n\\r\\n    //消去済みフラグを消す\\r\\n    Game_Event.prototype.appear = function() {\\r\\n        this._erased = false;\\r\\n        this.refresh();\\r\\n    };\\r\\n\\r\\n    //タイプを設定する\\r\\n    Game_Event.prototype.setType = function(type) {\\r\\n        this._srpgEventType = type;\\r\\n    };\\r\\n\\r\\n    //タイプを返す\\r\\n    Game_Event.prototype.isType = function() {\\r\\n        return this._srpgEventType;\\r\\n    };\\r\\n\\r\\n    // アクター・エネミーデータを元にイベントのグラフィックを変更する＋戦闘以外では元に戻す\\r\\n    Game_Event.prototype.refreshImage = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            var battlerArray = $gameSystem.EventToUnit(this._eventId);\\r\\n            if (!battlerArray || this.isErased()) {\\r\\n                return ;\\r\\n            }\\r\\n            var type = battlerArray[0];\\r\\n            var unit = battlerArray[1];\\r\\n            if (type === 'actor') {\\r\\n\\t\\t\\t\\tvar mechClass;\\r\\n\\r\\n\\t\\t\\t\\tif(unit.SRWStats && unit.SRWStats.mech){\\r\\n\\t\\t\\t\\t\\tmechClass = unit.SRWStats.mech.id;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tmechClass = unit._classId;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tvar overworldSpriteData = $dataClasses[mechClass].meta.srpgOverworld.split(\\\",\\\");\\r\\n\\t\\t\\t\\tcharacterName = overworldSpriteData[0];\\r\\n\\t\\t\\t\\tcharacterIndex = overworldSpriteData[1];\\r\\n                this.setImage(characterName, characterIndex);\\r\\n            } else if (type === 'enemy') {\\r\\n\\t\\t\\t\\tvar characterName;\\r\\n\\t\\t\\t\\tvar characterIndex;        \\r\\n\\t\\t\\t\\tvar mechClass = unit._mechClass;\\r\\n\\t\\t\\t\\tif(mechClass){\\r\\n\\t\\t\\t\\t\\tvar overworldSpriteData = $dataClasses[mechClass].meta.srpgOverworld.split(\\\",\\\");\\r\\n\\t\\t\\t\\t\\tcharacterName = overworldSpriteData[0];\\r\\n\\t\\t\\t\\t\\tcharacterIndex = overworldSpriteData[1];\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tcharacterName = unit.enemy().meta.characterName;\\r\\n\\t\\t\\t\\t\\tcharacterIndex = unit.enemy().meta.characterIndex;\\r\\n\\t\\t\\t\\t\\tif (!characterName || !characterIndex) {\\r\\n\\t\\t\\t\\t\\t\\tcharacterName = 'monster.png';\\r\\n\\t\\t\\t\\t\\t\\tcharacterIndex = 0;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n                this.setImage(characterName, characterIndex);\\r\\n            } else if (type === 'null') {\\r\\n                this.erase();\\r\\n            }\\r\\n        } else {\\r\\n            if (this.isErased()) {\\r\\n                this.appear();\\r\\n            }\\r\\n            var page = this.page();\\r\\n\\t\\t\\tif(page){\\r\\n\\t\\t\\t\\tvar image = page.image;\\r\\n\\t\\t\\t\\tif (image.tileId > 0) {\\r\\n\\t\\t\\t\\t\\tthis.setTileImage(image.tileId);\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tthis.setImage(image.characterName, image.characterIndex);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tthis.setDirection(image.direction);\\r\\n\\t\\t\\t\\tthis.setPattern(image.pattern);\\r\\n\\t\\t\\t}\\r\\n            \\r\\n        }\\r\\n    };\\r\\n\\t\\r\\n\\tGame_Event.prototype.srpgMoveToPoint = function(targetPosition, ignoreMoveTable, ignoreObstacles) {\\r\\n\\t\\tthis._pendingMoveToPoint = true;\\r\\n\\t\\tthis._targetPosition = targetPosition;\\r\\n\\t\\t\\r\\n\\t\\tvar actor = $gameSystem.EventToUnit(this.eventId())[1];\\r\\n\\t\\t\\r\\n\\t\\tvar list = $gameTemp.moveList();\\r\\n\\t\\tvar moveListLookup = {};\\r\\n\\t\\tlist.forEach(function(entry){\\r\\n\\t\\t\\tif(!moveListLookup[entry[0]]){\\r\\n\\t\\t\\t\\tmoveListLookup[entry[0]] = [];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tmoveListLookup[entry[0]][entry[1]] = true;\\r\\n\\t\\t});\\r\\n\\t\\t//construct grid representation for pathfinding\\r\\n\\t\\tvar occupiedPositions = $statCalc.getOccupiedPositionsLookup(actor.isActor() ? \\\"enemy\\\" : \\\"actor\\\");\\r\\n\\t\\tvar pathfindingGrid = [];\\r\\n\\t\\tvar directionGrid = [];\\r\\n\\t\\tfor(var i = 0; i < $gameMap.width(); i++){\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tpathfindingGrid[i] = [];\\r\\n\\t\\t\\tdirectionGrid[i] = [];\\r\\n\\t\\t\\tfor(var j = 0; j < $gameMap.height(); j++){\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tvar weight = 1 ;\\r\\n\\t\\t\\t\\tif(i >= 0 && j >= 0){\\r\\n\\t\\t\\t\\t\\tif(!$statCalc.isFlying(actor)){\\r\\n\\t\\t\\t\\t\\t\\tweight+=$gameMap.SRPGTerrainTag(i, j);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tif(ignoreObstacles){\\r\\n\\t\\t\\t\\t\\t\\tpathfindingGrid[i][j] = 1;\\r\\n\\t\\t\\t\\t\\t\\tdirectionGrid[i][j] = {\\r\\n\\t\\t\\t\\t\\t\\t\\ttop: true,\\r\\n\\t\\t\\t\\t\\t\\t\\tbottom: true,\\r\\n\\t\\t\\t\\t\\t\\t\\tleft: true,\\r\\n\\t\\t\\t\\t\\t\\t\\tright: true\\r\\n\\t\\t\\t\\t\\t\\t};\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\tvar isCenterPassable = !(occupiedPositions[i] && occupiedPositions[i][j]) \\r\\n\\t\\t\\t\\t\\t\\t\\t&& $statCalc.canStandOnTile(actor, {x: i, y: j})\\r\\n\\t\\t\\t\\t\\t\\t\\t&& (ignoreMoveTable || (moveListLookup[i] && moveListLookup[i][j]));\\r\\n\\t\\t\\t\\t\\t\\tvar isTopPassable;\\r\\n\\t\\t\\t\\t\\t\\tvar isBottomPassable;\\r\\n\\t\\t\\t\\t\\t\\tvar isLeftPassable;\\r\\n\\t\\t\\t\\t\\t\\tvar isRightPassable;\\r\\n\\t\\t\\t\\t\\t\\tif(!isCenterPassable || $statCalc.isFlying(actor) || !ENGINE_SETTINGS.USE_TILE_PASSAGE){\\r\\n\\t\\t\\t\\t\\t\\t\\tisTopPassable = isCenterPassable;\\r\\n\\t\\t\\t\\t\\t\\t\\tisBottomPassable = isCenterPassable;\\r\\n\\t\\t\\t\\t\\t\\t\\tisLeftPassable = isCenterPassable;\\r\\n\\t\\t\\t\\t\\t\\t\\tisRightPassable = isCenterPassable;\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\t\\tisTopPassable = $gameMap.isPassable(i, j, 8);\\r\\n\\t\\t\\t\\t\\t\\t\\tisBottomPassable = $gameMap.isPassable(i, j, 2);\\r\\n\\t\\t\\t\\t\\t\\t\\tisLeftPassable = $gameMap.isPassable(i, j, 4);\\r\\n\\t\\t\\t\\t\\t\\t\\tisRightPassable = $gameMap.isPassable(i, j, 6);\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\tpathfindingGrid[i][j] = isCenterPassable ? weight : 0; \\t\\r\\n\\t\\t\\t\\t\\t\\tdirectionGrid[i][j] = {\\r\\n\\t\\t\\t\\t\\t\\t\\ttop: isTopPassable,\\r\\n\\t\\t\\t\\t\\t\\t\\tbottom: isBottomPassable,\\r\\n\\t\\t\\t\\t\\t\\t\\tleft: isLeftPassable,\\r\\n\\t\\t\\t\\t\\t\\t\\tright: isRightPassable\\r\\n\\t\\t\\t\\t\\t\\t};\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tpathfindingGrid[i][j] = 0;\\r\\n\\t\\t\\t\\t\\tdirectionGrid[i][j] = {\\r\\n\\t\\t\\t\\t\\t\\ttop: false,\\r\\n\\t\\t\\t\\t\\t\\tbottom: false,\\r\\n\\t\\t\\t\\t\\t\\tleft: false,\\r\\n\\t\\t\\t\\t\\t\\tright: false\\r\\n\\t\\t\\t\\t\\t};\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tvar graph = new Graph(pathfindingGrid, directionGrid);\\r\\n\\t\\t\\r\\n\\t\\tvar startCoords = {x: this.posX(), y: this.posY()};\\r\\n\\t\\tvar startNode = graph.grid[startCoords.x][startCoords.y];\\r\\n\\t\\tvar endCoords = {x: this._targetPosition.x, y: this._targetPosition.y};\\r\\n\\t\\tvar endNode = graph.grid[endCoords.x][endCoords.y];\\r\\n\\r\\n\\t\\t\\r\\n\\t\\tvar path = astar.search(graph, startNode, endNode);\\r\\n\\t\\t\\r\\n\\t\\t$gamePlayer.followedEvent = this;\\r\\n\\t\\tthis._pathToCurrentTarget = path;\\t\\r\\n\\t}\\r\\n    //移動ルートを設定する\\r\\n    Game_Event.prototype.srpgMoveRouteForce = function(array) {\\r\\n        this._srpgForceRoute = [];\\r\\n        for (var i = 1; i < array.length; i++) {\\r\\n            this._srpgForceRoute.push(array[i]);\\r\\n        }\\r\\n        this._srpgForceRoute.push(0);\\r\\n    };\\r\\n\\r\\n    //設定されたルートに沿って移動する\\r\\n    var _SRPG_Game_Event_updateStop = Game_Event.prototype.updateStop;\\r\\n    Game_Event.prototype.updateStop = function() {\\r\\n\\t\\tvar battlerArray = $gameSystem.EventToUnit(this._eventId);\\r\\n\\t\\tvar isActor = false;\\r\\n\\t\\tif(battlerArray && battlerArray[1]){\\r\\n\\t\\t\\tvar isActor = battlerArray[1].isActor();\\r\\n\\t\\t}\\t\\r\\n\\t\\tvar followMove = !isActor || $gameTemp.followMove;\\r\\n\\t\\tif(battlerArray && battlerArray[1]){\\r\\n\\t\\t\\tvar regionId = $gameMap.regionId(this._x, this._y);\\r\\n\\t\\t\\t$statCalc.setCurrentTerrainFromRegionIndex(battlerArray[1], regionId);\\r\\n\\t\\t\\t$gameMap.initSRWTileProperties();\\r\\n\\t\\t\\tif($gameSystem.regionAttributes && $gameSystem.regionAttributes[regionId]){\\r\\n\\t\\t\\t\\tvar def = $gameSystem.regionAttributes[regionId];\\r\\n\\t\\t\\t\\t$statCalc.setCurrentTerrainModsFromTilePropertyString(battlerArray[1], def.defense+\\\",\\\"+def.evasion+\\\",\\\"+def.hp_regen+\\\",\\\"+def.en_regen+\\\",\\\");\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t$statCalc.setCurrentTerrainModsFromTilePropertyString(battlerArray[1], $gameMap.getTileProperties({x: this._x, y: this._y}));\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}\\t\\t\\r\\n        if ($gameSystem.isSRPGMode() == true && this._srpgForceRoute.length > 0) {\\r\\n            if (!this.isMoving()) {\\r\\n                var command = this._srpgForceRoute[0];\\r\\n                this._srpgForceRoute.shift();\\r\\n                if (command == 0) {\\r\\n                    this._srpgForceRoute = [];\\r\\n                    $gameSystem.setSrpgWaitMoving(false);\\r\\n                } else {\\r\\n                    this.moveStraight(command);\\r\\n                }\\r\\n            }\\r\\n        } else if(this._pendingMoveToPoint){\\r\\n\\t\\t\\tif (!this.isMoving()) {\\r\\n\\t\\t\\t\\tInput.update();\\r\\n\\t\\t\\t\\tif(Input.isPressed(\\\"pagedown\\\") || Input.isLongPressed(\\\"pagedown\\\") || $gameSystem.optionSkipUnitMoving){\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tif(this._pathToCurrentTarget && this._pathToCurrentTarget.length){//avoid rare crash where this functional is called when the path has already been cleared\\r\\n\\t\\t\\t\\t\\t\\tvar targetPosition = this._pathToCurrentTarget[this._pathToCurrentTarget.length-1];\\r\\n\\t\\t\\t\\t\\t\\tthis._pathToCurrentTarget = [];\\r\\n\\t\\t\\t\\t\\t\\tthis.locate(targetPosition.x, targetPosition.y);\\r\\n\\t\\t\\t\\t\\t\\tif(followMove){\\r\\n\\t\\t\\t\\t\\t\\t\\t$gamePlayer.locate(targetPosition.x, targetPosition.y);\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\r\\n\\t\\t\\t\\t\\t$gamePlayer.clearFollowSpeed();\\r\\n\\t\\t\\t\\t\\t$gamePlayer.followedEvent = null;\\r\\n\\t\\t\\t\\t\\tthis._targetPosition = null;\\r\\n\\t\\t\\t\\t\\tthis._pathToCurrentTarget = null;\\r\\n\\t\\t\\t\\t\\tthis._pendingMoveToPoint = false;\\r\\n\\t\\t\\t\\t\\t$gameTemp.followMove = false;\\r\\n\\t\\t\\t\\t\\t$gameSystem.setSrpgWaitMoving(false);\\r\\n\\t\\t\\t\\t\\t$statCalc.invalidateAbilityCache();\\t\\t\\r\\n\\t\\t\\t\\t} else {\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tthis.setMoveSpeed(6);\\r\\n\\t\\t\\t\\t\\tif(followMove){\\r\\n\\t\\t\\t\\t\\t\\t$gamePlayer.setFollowSpeed(6);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tvar nextPosition = this._pathToCurrentTarget.shift();\\r\\n\\t\\t\\t\\t\\tif(nextPosition && (this._x != nextPosition.x || this._y != nextPosition.y)) {\\r\\n\\t\\t\\t\\t\\t\\tvar deltaX = nextPosition.x - this._x;\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\tvar deltaY = nextPosition.y - this._y;\\r\\n\\t\\t\\t\\t\\t\\tif(deltaX != 0){\\r\\n\\t\\t\\t\\t\\t\\t\\tif(Math.sign(deltaX) == 1){\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tthis.moveStraight(6); //right\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif(followMove){\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t$gamePlayer.moveStraight(6);\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tthis.moveStraight(4); //left\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif(followMove){\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t$gamePlayer.moveStraight(4);\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\tif(deltaY != 0){\\r\\n\\t\\t\\t\\t\\t\\t\\tif(Math.sign(deltaY) == 1){\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tthis.moveStraight(2); //down\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif(followMove){\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t$gamePlayer.moveStraight(2);\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tthis.moveStraight(8); //up\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif(followMove){\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t$gamePlayer.moveStraight(8);\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\t$gamePlayer.clearFollowSpeed();\\r\\n\\t\\t\\t\\t\\t\\tthis._targetPosition = null;\\r\\n\\t\\t\\t\\t\\t\\tthis._pathToCurrentTarget = null;\\r\\n\\t\\t\\t\\t\\t\\tthis._pendingMoveToPoint = false;\\r\\n\\t\\t\\t\\t\\t\\t$gameTemp.followMove = false;\\r\\n\\t\\t\\t\\t\\t\\t$gamePlayer.followedEvent = null;\\r\\n\\t\\t\\t\\t\\t\\t$gameSystem.setSrpgWaitMoving(false);\\r\\n\\t\\t\\t\\t\\t\\t$statCalc.invalidateAbilityCache();\\r\\n\\t\\t\\t\\t\\t}\\t\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n            _SRPG_Game_Event_updateStop.call(this);\\r\\n        }\\r\\n    };\\r\\n\\t\\r\\n\\tGame_Event.prototype.event = function() {\\r\\n\\t\\tif(!$dataMap.events[this._eventId]){\\r\\n\\t\\t\\treturn JSON.parse('{\\\"id\\\":1,\\\"name\\\":\\\"ACTOR_0\\\",\\\"note\\\":\\\"<type:actor>\\\",\\\"pages\\\":[{\\\"conditions\\\":{\\\"actorId\\\":1,\\\"actorValid\\\":false,\\\"itemId\\\":1,\\\"itemValid\\\":false,\\\"selfSwitchCh\\\":\\\"A\\\",\\\"selfSwitchValid\\\":false,\\\"switch1Id\\\":1,\\\"switch1Valid\\\":false,\\\"switch2Id\\\":1,\\\"switch2Valid\\\":false,\\\"variableId\\\":1,\\\"variableValid\\\":false,\\\"variableValue\\\":0},\\\"directionFix\\\":false,\\\"image\\\":{\\\"tileId\\\":0,\\\"characterName\\\":\\\"\\\",\\\"direction\\\":2,\\\"pattern\\\":0,\\\"characterIndex\\\":0},\\\"list\\\":[{\\\"code\\\":0,\\\"indent\\\":0,\\\"parameters\\\":[]}],\\\"moveFrequency\\\":3,\\\"moveRoute\\\":{\\\"list\\\":[{\\\"code\\\":0,\\\"parameters\\\":[]}],\\\"repeat\\\":true,\\\"skippable\\\":false,\\\"wait\\\":false},\\\"moveSpeed\\\":3,\\\"moveType\\\":0,\\\"priorityType\\\":0,\\\"stepAnime\\\":false,\\\"through\\\":false,\\\"trigger\\\":0,\\\"walkAnime\\\":true}],\\\"x\\\":17,\\\"y\\\":7,\\\"meta\\\":{\\\"type\\\":\\\"actor\\\"}}');\\r\\n\\t\\t}\\r\\n\\t\\treturn $dataMap.events[this._eventId];\\r\\n\\t};\\r\\n\\r\\n//====================================================================\\r\\n// ●Game_Map\\r\\n//====================================================================\\r\\n    //アクター・エネミーデータに合わせてグラフィックを変更する\\r\\n\\t\\r\\n\\tvar Game_Map_prototype_initialize = Game_Map.prototype.initialize;\\r\\n\\tGame_Map.prototype.initialize = function() {\\r\\n\\t\\tGame_Map_prototype_initialize.call(this);\\t\\t\\r\\n\\t\\t\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_Map.prototype.setupEvents = function() {\\r\\n\\t\\tthis._events = [];\\r\\n\\t\\tfor (var i = 0; i < $dataMap.events.length; i++) {\\r\\n\\t\\t\\tif ($dataMap.events[i]) {\\r\\n\\t\\t\\t\\tthis._events[i] = new Game_Event(this._mapId, i);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tthis._startOfDynamicEvents = this._events.length;\\r\\n\\t\\tfor (var i = this._startOfDynamicEvents; i < this._startOfDynamicEvents + 100; i++) {\\r\\n\\t\\t\\tvar event = new Game_Event(this._mapId, i);\\r\\n\\t\\t\\tevent.isUnused = true;\\r\\n\\t\\t\\tthis._events[i] = event;\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\tthis._commonEvents = this.parallelCommonEvents().map(function(commonEvent) {\\r\\n\\t\\t\\treturn new Game_CommonEvent(commonEvent.id);\\r\\n\\t\\t});\\r\\n\\t\\tthis.refreshTileEvents();\\r\\n\\t};\\r\\n\\t\\r\\n\\tGame_Map.prototype.getRegionTiles = function(id) {\\r\\n\\t\\tif(!this._regionTilesLookup){\\r\\n\\t\\t\\tthis._regionTilesLookup = {};\\r\\n\\t\\t\\tfor(var i = 0; i < this.width(); i++){\\r\\n\\t\\t\\t\\tfor(var j = 0; j < this.width(); j++){\\r\\n\\t\\t\\t\\t\\tvar region = this.regionId(i, j);\\r\\n\\t\\t\\t\\t\\tif(!this._regionTilesLookup[region]){\\r\\n\\t\\t\\t\\t\\t\\tthis._regionTilesLookup[region] = [];\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tthis._regionTilesLookup[region].push({x: i, y: j});\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn this._regionTilesLookup[id] || [];\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_Map.prototype.initSRWTileProperties = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tif(!this._SRWTileProperties){\\r\\n\\t\\t\\tthis._SRWTileProperties = {};\\r\\n\\t\\t}\\r\\n\\t\\tif(!this._SRWTileProperties[this._tilesetId]){\\r\\n\\t\\t\\tvar regex = new RegExp(\\\"srwTileAttributes([0-9]+)\\\");\\r\\n\\t\\t\\tvar rangeRegex = new RegExp(\\\"srwTileAttributes([0-9]+)\\\\-([0-9]+)\\\");\\r\\n\\t\\t\\tthis._SRWTileProperties[this._tilesetId] = {};\\r\\n\\t\\t\\tvar tileSetMeta = $dataTilesets[this._tilesetId].meta;\\r\\n\\t\\t\\tObject.keys(tileSetMeta).forEach(function(key){\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tvar matches = key.match(regex);\\r\\n\\t\\t\\t\\tif(matches.length){\\r\\n\\t\\t\\t\\t\\t_this._SRWTileProperties[_this._tilesetId][matches[1]] = tileSetMeta[key];\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tvar matches = key.match(rangeRegex);\\r\\n\\t\\t\\t\\tif(matches.length){\\r\\n\\t\\t\\t\\t\\tvar startId = matches[1];\\r\\n\\t\\t\\t\\t\\tvar endId = matches[2];\\r\\n\\t\\t\\t\\t\\tfor(var i = startId; i < endId; i++){\\r\\n\\t\\t\\t\\t\\t\\t_this._SRWTileProperties[_this._tilesetId][i] = tileSetMeta[key];\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t});\\r\\n\\t\\t}\\r\\n    };\\r\\n\\t\\r\\n\\tGame_Map.prototype.getTileProperties = function(tileCoords) {\\r\\n\\t\\tif(this._SRWTileProperties && this._SRWTileProperties[this._tilesetId]){\\r\\n\\t\\t\\tvar bTileId = $gameMap.tileId(tileCoords.x, tileCoords.y, 3);\\r\\n\\t\\t\\tvar autoTileId = $gameMap.tileId(tileCoords.x, tileCoords.y, 1);\\r\\n\\t\\t\\tvar groundTileId = $gameMap.tileId(tileCoords.x, tileCoords.y, 0);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif(this._SRWTileProperties[this._tilesetId][bTileId]){\\r\\n\\t\\t\\t\\treturn this._SRWTileProperties[this._tilesetId][bTileId];\\r\\n\\t\\t\\t} else if(this._SRWTileProperties[this._tilesetId][autoTileId]){\\r\\n\\t\\t\\t \\treturn this._SRWTileProperties[this._tilesetId][autoTileId];\\r\\n\\t\\t\\t} else if(this._SRWTileProperties[this._tilesetId][groundTileId]){\\r\\n\\t\\t\\t\\treturn this._SRWTileProperties[this._tilesetId][groundTileId];\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn null;\\r\\n\\t\\t}\\t\\t\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_Map.prototype.getTilePropertiesAsObject = function(tileCoords) {\\r\\n\\t\\tvar result;\\r\\n\\t\\tvar string = this.getTileProperties(tileCoords);\\r\\n\\t\\tif(string){\\r\\n\\t\\t\\tvar parts = string.split(\\\",\\\");\\t\\t\\r\\n\\t\\t\\tresult = {\\r\\n\\t\\t\\t\\tdefense: String(parts[0]).trim()*1,\\r\\n\\t\\t\\t\\tevasion: String(parts[1]).trim()*1,\\r\\n\\t\\t\\t\\thp_regen: String(parts[2]).trim()*1,\\r\\n\\t\\t\\t\\ten_regen: String(parts[3]).trim()*1\\r\\n\\t\\t\\t};\\r\\n\\t\\t}\\t\\r\\n\\t\\treturn result;\\r\\n\\t}\\r\\n\\t\\r\\n\\tGame_Map.prototype.requestDynamicEvent = function() {\\r\\n\\t\\tvar event;\\r\\n\\t\\tvar ctr = this._startOfDynamicEvents;\\r\\n\\t\\twhile(ctr < this._events.length && !event){\\r\\n\\t\\t\\tif(this._events[ctr].isUnused){\\r\\n\\t\\t\\t\\tevent = this._events[ctr];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tctr++;\\r\\n\\t\\t}\\r\\n\\t\\tif(event){\\r\\n\\t\\t\\tevent.isUnused = false;\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\treturn event;\\r\\n\\t};\\t\\r\\n\\t\\r\\n    Game_Map.prototype.setEventImages = function() {\\r\\n        this.events().forEach(function(event) {\\r\\n            event.refreshImage();\\r\\n        });\\r\\n    };\\r\\n\\r\\n    //最大のイベントＩＤを返す\\r\\n    Game_Map.prototype.isMaxEventId = function() {\\r\\n        var maxId = 0;\\r\\n        this.events().forEach(function(event) {\\r\\n            if (event.eventId() > maxId) {\\r\\n                maxId = event.eventId();\\r\\n            }\\r\\n        });\\r\\n        return maxId;\\r\\n    };\\r\\n\\r\\n    //イベントの実行順序を変更する（実行待ちのイベントを優先する）\\r\\n    var _SRPG_Game_Map_setupStartingMapEvent = Game_Map.prototype.setupStartingMapEvent;\\r\\n    Game_Map.prototype.setupStartingMapEvent = function() {\\r\\n        if ($gameTemp.isSrpgEventList()) {\\r\\n            var event = $gameTemp.shiftSrpgEventList();\\r\\n            if (event.isStarting()) {\\r\\n                event.clearStartingFlag();\\r\\n                this._interpreter.setup(event.list(), event.eventId());\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return _SRPG_Game_Map_setupStartingMapEvent.call(this);\\r\\n    };\\r\\n\\t\\r\\n\\tGame_Map.prototype.SRPGTerrainTag = function(x, y) {\\r\\n\\t\\tif (this.isValid(x, y)) {\\r\\n\\t\\t\\tvar flags = this.tilesetFlags();\\r\\n\\t\\t\\tvar tiles = this.layeredTiles(x, y);\\r\\n\\t\\t\\tfor (var i = 0; i < tiles.length; i++) {\\r\\n\\t\\t\\t\\tvar tag = flags[tiles[i]] >> 12;\\r\\n\\t\\t\\t\\tif (tiles[i] != 0) {\\r\\n\\t\\t\\t\\t\\treturn tag;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn 0;\\r\\n\\t};\\r\\n\\t\\r\\n\\tGame_Map.prototype.hasStarTile = function(x, y) {\\r\\n\\t\\tvar flags = this.tilesetFlags();\\r\\n\\t\\tvar tile = this.allTiles(x, y)[0];\\r\\n\\t\\tif(tile != 0){\\r\\n\\t\\t\\tvar flag = flags[tile];\\r\\n\\t\\t\\tif ((flag & 0x10) !== 0){\\r\\n\\t\\t\\t\\treturn true;\\r\\n\\t\\t\\t} \\r\\n\\t\\t}\\r\\n\\t\\treturn false;\\r\\n\\t};\\r\\n\\r\\n//====================================================================\\r\\n// ●Game_Interpreter\\r\\n//====================================================================\\r\\n// イベントＩＤをもとに、ユニット間の距離をとる\\r\\n\\r\\nGame_Interpreter.prototype.initialize = function(depth) {\\r\\n    this._depth = depth || 0;\\r\\n    this.checkOverflow();\\r\\n    this.clear();\\r\\n    this._branch = {};\\r\\n    this._params = [];\\r\\n    this._indent = 0;\\r\\n    this._frameCount = 0;\\r\\n    this._freezeChecker = 0;\\r\\n\\t\\r\\n\\tthis._lastFadeState = -1;\\r\\n\\tthis._haltingCommands = {\\r\\n\\t\\t\\r\\n\\t};\\r\\n};\\r\\n\\r\\nGame_Interpreter.prototype.isHaltingCommand = function(command) {\\r\\n\\tif(command.code == 355){ // script call\\r\\n\\t\\t//loose checking for halting custom commands \\r\\n\\t\\tvar haltingScriptCommands = [\\r\\n\\t\\t\\t\\\"showStageConditions\\\",\\r\\n\\t\\t\\t\\\"showEnemyPhaseText\\\",\\r\\n\\t\\t\\t\\\"awardSRPoint\\\",\\r\\n\\t\\t\\t\\\"showMapAttackText\\\",\\r\\n\\t\\t\\t\\\"destroyEvent\\\",\\r\\n\\t\\t\\t\\\"destroyEvents\\\",\\r\\n\\t\\t\\t\\\"applyActorSpirits\\\",\\r\\n\\t\\t\\t\\\"applyEventSpirits\\\",\\r\\n\\t\\t\\t\\\"processEnemyAppearQueue\\\",\\r\\n\\t\\t\\t\\\"processUnitAppearQueue\\\",\\r\\n\\t\\t\\t\\\"processDisappearQueue\\\",\\r\\n\\t\\t\\t\\\"manualDeploy\\\",\\r\\n\\t\\t\\t\\\"manualShipDeploy\\\",\\r\\n\\t\\t\\t\\\"playBattleScene\\\",\\t\\t\\t\\r\\n\\t\\t];\\r\\n\\t\\t\\r\\n\\t\\tvar hasHalting = false;\\r\\n\\t\\thaltingScriptCommands.forEach(function(entry){\\r\\n\\t\\t\\tvar re = new RegExp(\\\".*\\\"+entry+\\\".*\\\",\\\"g\\\");\\r\\n\\t\\t\\tif(command.parameters[0].match(re)){\\r\\n\\t\\t\\t\\thasHalting = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\treturn hasHalting;\\r\\n\\t}\\r\\n\\t\\r\\n\\tif(command.code == 356){ // plugin command\\r\\n\\t\\tvar haltingPluginCommands = {\\r\\n\\t\\t\\t\\\"stopSkipping\\\": true,\\r\\n\\t\\t\\t\\\"Intermission\\\": true\\r\\n\\t\\t}\\r\\n\\t\\tvar args = command.parameters[0].split(\\\" \\\");\\r\\n\\t\\tvar entry = args.shift();\\r\\n\\t\\treturn !!haltingPluginCommands[entry];\\r\\n\\t}\\r\\n\\t\\r\\n\\treturn !!this._haltingCommands[command.code];\\r\\n}\\r\\n\\r\\n// Script\\r\\nGame_Interpreter.prototype.command355 = function() {\\r\\n    var script = this.currentCommand().parameters[0] + '\\\\n';\\r\\n    while (this.nextEventCode() === 655) {\\r\\n        this._index++;\\r\\n        script += this.currentCommand().parameters[0] + '\\\\n';\\r\\n    }\\r\\n    var result = eval(script);\\r\\n\\tif(result == null){\\r\\n\\t\\treturn true;\\r\\n\\t} else {\\r\\n\\t\\treturn result;\\r\\n\\t}\\r\\n};\\r\\n\\r\\nGame_Interpreter.prototype.EventDistance = function(variableId, eventId1, eventId2) {\\r\\n    var event1 = $gameMap.event(eventId1);\\r\\n    var event2 = $gameMap.event(eventId2);\\r\\n    if (event1 && event2 && !event1.isErased() && !event2.isErased()) {\\r\\n        var value = $gameSystem.unitDistance(event1, event2);\\r\\n        $gameVariables.setValue(variableId, value);\\r\\n    } else {\\r\\n        $gameVariables.setValue(variableId, 999);\\r\\n    }\\r\\n    return true;\\r\\n};\\r\\n\\r\\n// アクターＩＤをもとに、ユニット間の距離をとる\\r\\nGame_Interpreter.prototype.ActorDistance = function(variableId, actorId1, actorId2) {\\r\\n    var eventId1 = $gameSystem.ActorToEvent(actorId1);\\r\\n    var eventId2 = $gameSystem.ActorToEvent(actorId2);\\r\\n    this.EventDistance(variableId, eventId1, eventId2);\\r\\n    return true;\\r\\n};\\r\\n\\r\\n// 特定のＩＤのイベントと全アクターの中で最短の距離をとる\\r\\nGame_Interpreter.prototype.fromActorMinimumDistance = function(variableId, eventId) {\\r\\n    var minDistance = 999;\\r\\n    var event1 = $gameMap.event(eventId);\\r\\n    $gameMap.events().forEach(function(event) {\\r\\n        if (event.isType() === 'actor' || event.isType() === 'ship' || event.isType() === 'ship_event') {\\r\\n            var event2 = $gameMap.event(event.eventId());\\r\\n            if (event1 && event2 && !event1.isErased() && !event2.isErased()) {\\r\\n                var value = $gameSystem.unitDistance(event1, event2);\\r\\n                if (value < minDistance) {\\r\\n                    minDistance = value;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    });\\r\\n    $gameVariables.setValue(variableId, minDistance);\\r\\n    return true;\\r\\n};\\r\\n\\r\\n// 新規アクターを追加する（増援）\\r\\nGame_Interpreter.prototype.addActor = function(eventId, actorId) {\\r\\n    var actor_unit = $gameActors.actor(actorId);\\r\\n    var event = $gameMap.event(eventId);\\r\\n    if (actor_unit && event) {\\r\\n        $gameSystem.pushSrpgAllActors(event.eventId());\\r\\n        actor_unit.initTp(); //TPを初期化\\r\\n        var bitmap = ImageManager.loadFace(actor_unit.faceName()); //顔グラフィックをプリロードする\\r\\n        var oldValue = $gameVariables.value(_existActorVarID);\\r\\n        $gameVariables.setValue(_existActorVarID, oldValue + 1);\\r\\n        $gameSystem.setEventToUnit(event.eventId(), 'actor', actor_unit.actorId());\\r\\n        event.setType('actor');\\r\\n        var xy = event.makeAppearPoint(event, event.posX(), event.posY());\\r\\n        event.setPosition(xy[0], xy[1]);\\r\\n        $gameMap.setEventImages();\\r\\n    }\\r\\n    return true;\\r\\n};\\r\\n\\r\\nGame_Interpreter.prototype.setMasteryText = function(text){\\r\\n\\t$gameVariables.setValue(_masteryConditionText, text);\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.setVictoryText = function(text){\\r\\n\\t$gameVariables.setValue(_victoryConditionText, text);\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.setDefeatText = function(text){\\r\\n\\t$gameVariables.setValue(_defeatConditionText, text);\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.showStageConditions = function(){\\r\\n\\tif (!$gameMessage.isBusy()) {\\r\\n\\t\\t$gameMessage.setFaceImage(\\\"\\\", \\\"\\\");\\r\\n\\t\\t$gameMessage.setBackground(0);\\r\\n        $gameMessage.setPositionType(1);\\r\\n\\t\\t$gameMessage.add(APPSTRINGS.GENERAL.label_victory_condition + \\\": \\\"+($gameVariables.value(_victoryConditionText) || \\\"\\\"));\\r\\n\\t\\t$gameMessage.add(APPSTRINGS.GENERAL.label_defeat_condition + \\\": \\\"+($gameVariables.value(_defeatConditionText) || \\\"\\\"));\\r\\n\\t\\tvar masteryText = $gameVariables.value(_masteryConditionText);\\r\\n\\t\\tif($SRWSaveManager.isMapSRPointLocked($gameMap.mapId())){\\r\\n\\t\\t\\tmasteryText = APPSTRINGS.GENERAL.label_mastery_locked;\\r\\n\\t\\t}\\r\\n\\t\\t$gameMessage.add(APPSTRINGS.GENERAL.label_mastery_condition + \\\": \\\"+(masteryText || \\\"\\\"));\\r\\n\\t\\t\\r\\n\\t\\tthis._index++;\\r\\n        this.setWaitMode('message');\\r\\n\\t}\\r\\n\\treturn false;\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.showEnemyPhaseText = function(){\\r\\n\\tif (!$gameMessage.isBusy()) {\\r\\n\\t\\t$gameMessage.setFaceImage(\\\"\\\", \\\"\\\");\\r\\n\\t\\t$gameMessage.setBackground(1);\\r\\n        $gameMessage.setPositionType(1);\\r\\n\\t\\tvar text;\\r\\n\\t\\tif($gameSystem.isEnemyPhase()){\\r\\n\\t\\t\\ttext =  APPSTRINGS.GENERAL.label_enemy_phase;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\ttext =  APPSTRINGS.GENERAL.label_ally_phase;\\r\\n\\t\\t}\\r\\n\\t\\tvar colorId;\\r\\n\\t\\tif($gameTemp.currentFaction == 0){\\r\\n\\t\\t\\tcolorId = 18;\\r\\n\\t\\t}\\r\\n\\t\\tif($gameTemp.currentFaction == 1){\\r\\n\\t\\t\\tcolorId = 3;\\r\\n\\t\\t}\\r\\n\\t\\tif($gameTemp.currentFaction == 2){\\r\\n\\t\\t\\tcolorId = 14;\\r\\n\\t\\t}\\r\\n\\t\\t$gameMessage.add(\\\"\\\\\\\\TA[1]\\\\n\\\\\\\\>\\\\\\\\C[\\\"+colorId+\\\"]\\\\\\\\{\\\"+text+\\\"\\\\n\\\\\\\\.\\\\\\\\.\\\\\\\\^\\\");\\t//\\\\\\\\|\\t\\t\\t\\r\\n\\t\\tthis._index++;\\r\\n        this.setWaitMode('message');\\r\\n\\t}\\r\\n\\treturn false;\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.awardSRPoint = function(){\\t\\r\\n\\tvar mapId = $gameMap.mapId();\\r\\n\\tvar isNewlyAwarded = $SRWSaveManager.awardMapSRPoint(mapId);\\t\\r\\n\\tif(isNewlyAwarded){\\r\\n\\t\\tif(ENGINE_SETTINGS.MASTERY_REWARDS){\\r\\n\\t\\t\\tif(ENGINE_SETTINGS.MASTERY_REWARDS.PP){\\r\\n\\t\\t\\t\\tvar scope = ENGINE_SETTINGS.MASTERY_REWARDS.PP.SCOPE;\\r\\n\\t\\t\\t\\tvar actors = [];\\r\\n\\t\\t\\t\\tif(scope == \\\"deployed\\\"){\\r\\n\\t\\t\\t\\t\\tactors = $statCalc.getAllActors(\\\"actor\\\");\\r\\n\\t\\t\\t\\t} else if(scope == \\\"unlocked\\\"){\\r\\n\\t\\t\\t\\t\\tactors = $gameParty.allMembers();\\r\\n\\t\\t\\t\\t} else if(scope == \\\"all\\\"){\\r\\n\\t\\t\\t\\t\\tfor(var i = 0; i < $dataActors.length; i++){\\r\\n\\t\\t\\t\\t\\t\\tvar actor = $gameActors.actor(i);\\r\\n\\t\\t\\t\\t\\t\\tactors.push(actor);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\t\\r\\n\\t\\t\\t\\tactors.forEach(function(actor){\\r\\n\\t\\t\\t\\t\\tif(actor && actor.isActor()){\\r\\n\\t\\t\\t\\t\\t\\t$statCalc.addPP(actor, ENGINE_SETTINGS.MASTERY_REWARDS.PP.AMOUNT);\\t\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t});\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(ENGINE_SETTINGS.MASTERY_REWARDS.FUNDS){\\r\\n\\t\\t\\t\\t$gameParty.gainGold(ENGINE_SETTINGS.MASTERY_REWARDS.FUNDS);\\t\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tvar se = {};\\r\\n\\t\\tse.name = 'SRWMastery';\\r\\n\\t\\tse.pan = 0;\\r\\n\\t\\tse.pitch = 100;\\r\\n\\t\\tse.volume = 80;\\r\\n\\t\\tAudioManager.playSe(se);\\r\\n\\t\\t$gameVariables.setValue(_masteryConditionText, APPSTRINGS.GENERAL.label_mastery_completed);\\t\\r\\n\\t\\t\\r\\n\\t\\tif (!$gameMessage.isBusy()) {\\r\\n\\t\\t\\t$gameMessage.setFaceImage(\\\"\\\", \\\"\\\");\\r\\n\\t\\t\\t$gameMessage.setBackground(1);\\r\\n\\t\\t\\t$gameMessage.setPositionType(1);\\r\\n\\t\\t\\t$gameMessage.add(\\\"\\\\\\\\TA[1]\\\\n\\\" + APPSTRINGS.GENERAL.label_mastery_completed_message);\\t\\t\\t\\t\\r\\n\\t\\t\\tthis._index++;\\r\\n\\t\\t\\tthis.setWaitMode('message');\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\treturn false;\\r\\n\\t}\\r\\n\\treturn true;\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.showMapAttackText = function(faceName, faceIdx, text){\\r\\n\\tif (!$gameMessage.isBusy()) {\\r\\n\\t\\t$gameMessage.setFaceImage(faceName, faceIdx);\\r\\n        $gameMessage.setPositionType(2);\\r\\n\\t\\t$gameMessage.setBackground(0);\\r\\n\\t\\t$gameMessage.add(text);\\t\\t\\t\\t\\r\\n\\t\\tthis._index++;\\r\\n        this.setWaitMode('message');\\r\\n\\t}\\r\\n\\treturn false;\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.isActorDestructionQueued  = function(id){\\r\\n\\tvar result = false;\\r\\n\\tif($gameTemp.deathQueue && $gameTemp.deathQueue.length){\\r\\n\\t\\t$gameTemp.deathQueue.forEach(function(queuedDeath){\\r\\n\\t\\t\\tif(queuedDeath.actor.isActor() && queuedDeath.actor.actorId() == id && (!$gameTemp.preventedDeathQuotes || !$gameTemp.preventedDeathQuotes[id])){\\r\\n\\t\\t\\t\\tresult = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t}\\r\\n\\treturn result;\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.isEnemyDestructionQueued  = function(id){\\r\\n\\tvar result = false;\\r\\n\\tif($gameTemp.deathQueue && $gameTemp.deathQueue.length){\\r\\n\\t\\t$gameTemp.deathQueue.forEach(function(queuedDeath){\\r\\n\\t\\t\\tif(!queuedDeath.actor.isActor() && queuedDeath.actor.enemyId() == id){\\r\\n\\t\\t\\t\\tresult = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t}\\r\\n\\treturn result;\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.isEventDestructionQueued  = function(id){\\r\\n\\tvar result = false;\\r\\n\\tif($gameTemp.deathQueue && $gameTemp.deathQueue.length){\\r\\n\\t\\t$gameTemp.deathQueue.forEach(function(queuedDeath){\\r\\n\\t\\t\\tif(!queuedDeath.actor.isActor() && queuedDeath.actor.event.eventId() == id){\\r\\n\\t\\t\\t\\tresult = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t}\\r\\n\\treturn result;\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.isActorBelowHP  = function(id, hp){\\r\\n\\treturn $statCalc.isActorBelowHP(id, hp);\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.isEnemyBelowHP  = function(id, hp){\\r\\n\\treturn $statCalc.isEnemyBelowHP(id, hp);\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.isEventBelowHP  = function(id, hp){\\r\\n\\treturn $statCalc.isEventBelowHP(id, hp);\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.cancelActorDestruction  = function(id){\\r\\n\\tvar tmp = [];\\r\\n\\tif($gameTemp.deathQueue && $gameTemp.deathQueue.length){\\t\\t\\r\\n\\t\\t$gameTemp.deathQueue.forEach(function(queuedDeath){\\r\\n\\t\\t\\tif(!queuedDeath.actor.isActor() || queuedDeath.actor.actorId() != id){\\r\\n\\t\\t\\t\\ttmp.push(queuedDeath);\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\t$gameTemp.deathQueue = tmp;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.cancelEnemyDestruction  = function(id){\\r\\n\\tvar tmp = [];\\r\\n\\tif($gameTemp.deathQueue && $gameTemp.deathQueue.length){\\t\\t\\r\\n\\t\\t$gameTemp.deathQueue.forEach(function(queuedDeath){\\r\\n\\t\\t\\tif(queuedDeath.actor.isActor() || queuedDeath.actor.enemyId() != id){\\r\\n\\t\\t\\t\\ttmp.push(queuedDeath);\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\t$gameTemp.deathQueue = tmp;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.cancelEventDestruction  = function(id){\\r\\n\\tvar tmp = [];\\r\\n\\tif($gameTemp.deathQueue && $gameTemp.deathQueue.length){\\t\\t\\r\\n\\t\\t$gameTemp.deathQueue.forEach(function(queuedDeath){\\r\\n\\t\\t\\tif(!queuedDeath.actor.event && queuedDeath.actor.event.eventId() != id){\\r\\n\\t\\t\\t\\ttmp.push(queuedDeath);\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\t$gameTemp.deathQueue = tmp;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.addEnemiesFromObj = function(params) {\\r\\n\\tfor(var i = startId; i <= endId; i++){\\r\\n\\t\\tthis.addEnemy(\\r\\n\\t\\t\\tparams.toAnimQueue, \\r\\n\\t\\t\\ti, \\r\\n\\t\\t\\tparams.enemyId, \\r\\n\\t\\t\\tparams.mechClass, \\r\\n\\t\\t\\tparams.level, \\r\\n\\t\\t\\tparams.mode, \\r\\n\\t\\t\\tparams.targetId, \\r\\n\\t\\t\\tparams.items, \\r\\n\\t\\t\\tparams.squadId, \\r\\n\\t\\t\\tparams.targetRegion,\\r\\n\\t\\t\\tparams.factionId\\r\\n\\t\\t);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.addEnemies = function(toAnimQueue, startId, endId, enemyId, mechClass, level, mode, targetId, items, squadId, targetRegion, factionId) {\\r\\n\\tfor(var i = startId; i <= endId; i++){\\r\\n\\t\\tthis.addEnemy(toAnimQueue, i, enemyId, mechClass, level, mode, targetId, items, squadId, targetRegion, factionId);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.addEnemyFromObj = function(params){\\r\\n\\tthis.addEnemy(\\r\\n\\t\\tparams.toAnimQueue, \\r\\n\\t\\tparams.eventId, \\r\\n\\t\\tparams.enemyId, \\r\\n\\t\\tparams.mechClass, \\r\\n\\t\\tparams.level, \\r\\n\\t\\tparams.mode, \\r\\n\\t\\tparams.targetId, \\r\\n\\t\\tparams.items, \\r\\n\\t\\tparams.squadId, \\r\\n\\t\\tparams.targetRegion,\\r\\n\\t\\tparams.factionId,\\r\\n\\t\\tparams.counterBehavior\\r\\n\\t);\\r\\n}\\r\\n\\r\\n// 新規エネミーを追加する（増援）\\r\\nGame_Interpreter.prototype.addEnemy = function(toAnimQueue, eventId, enemyId, mechClass, level, mode, targetId, items, squadId, targetRegion, factionId, counterBehavior, attackBehavior) {\\r\\n    var enemy_unit = new Game_Enemy(enemyId, 0, 0);\\r\\n    var event = $gameMap.event(eventId);\\r\\n\\tif(typeof squadId == \\\"undefined\\\" || squadId == \\\"\\\"){\\r\\n\\t\\tsquadId = -1;\\r\\n\\t}\\r\\n\\tif(typeof targetRegion == \\\"undefined\\\"|| targetRegion == \\\"\\\"){\\r\\n\\t\\ttargetRegion = -1;\\r\\n\\t}\\r\\n\\tif(typeof factionId == \\\"undefined\\\"|| factionId == \\\"\\\"){\\r\\n\\t\\tfactionId = 0;\\r\\n\\t}\\r\\n    if (enemy_unit && event) { \\t\\r\\n\\t\\tenemy_unit._mechClass = mechClass;\\t\\r\\n\\t\\tenemy_unit.squadId = squadId;\\t\\r\\n\\t\\tenemy_unit.targetRegion = targetRegion;\\t\\r\\n\\t\\tenemy_unit.factionId = factionId;\\t\\r\\n\\t\\tenemy_unit.targetUnitId = targetId || \\\"\\\";\\r\\n\\t\\tenemy_unit.counterBehavior = counterBehavior || \\\"attack\\\";\\r\\n\\t\\tenemy_unit.attackBehavior = attackBehavior || \\\"attack\\\";\\r\\n\\t\\tif (enemy_unit) {\\r\\n\\t\\t\\tenemy_unit.event = event;\\r\\n\\t\\t\\tif (mode) {\\r\\n\\t\\t\\t\\tenemy_unit.setBattleMode(mode);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tenemy_unit.initTp(); //TPを初期化\\r\\n\\t\\t\\tvar faceName = enemy_unit.enemy().meta.faceName; //顔グラフィックをプリロードする\\r\\n\\t\\t\\tif (faceName) {\\r\\n\\t\\t\\t\\tvar bitmap = ImageManager.loadFace(faceName);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tif ($gameSystem.isSideView()) {\\r\\n\\t\\t\\t\\t\\tvar bitmap = ImageManager.loadSvEnemy(enemy_unit.battlerName(), enemy_unit.battlerHue());\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tvar bitmap = ImageManager.loadEnemy(enemy_unit.battlerName(), enemy_unit.battlerHue());\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tvar oldValue = $gameVariables.value(_existEnemyVarID);\\r\\n\\t\\t\\t$gameVariables.setValue(_existEnemyVarID, oldValue + 1);\\r\\n\\t\\t\\t$gameSystem.setEventToUnit(event.eventId(), 'enemy', enemy_unit);\\r\\n\\t\\t\\t$statCalc.initSRWStats(enemy_unit, level, items);\\r\\n\\t\\t\\t$statCalc.applyBattleStartWill(enemy_unit);\\r\\n\\t\\t\\t$statCalc.updateFlightState(enemy_unit);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tevent.setType('enemy');\\r\\n\\t\\t\\t/*var xy = event.makeAppearPoint(event, event.posX(), event.posY())\\r\\n\\t\\t\\tevent.setPosition(xy[0], xy[1]);\\t*/\\r\\n\\t\\t\\tvar position = $statCalc.getAdjacentFreeSpace({x: event.posX(), y: event.posY()}, null, event.eventId());\\r\\n\\t\\t\\tevent.locate(position.x, position.y);\\r\\n\\t\\t\\tif(!$gameTemp.enemyAppearQueue){\\r\\n\\t\\t\\t\\t$gameTemp.enemyAppearQueue = [];\\r\\n\\t\\t\\t}\\t\\r\\n\\t\\t\\tif(toAnimQueue){\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tevent.erase();\\r\\n\\t\\t\\t\\t$gameTemp.enemyAppearQueue.push(event);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t$gameMap.setEventImages();\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n    }\\r\\n\\t$statCalc.invalidateAbilityCache();\\r\\n    return true;\\r\\n};\\r\\n\\r\\nGame_Interpreter.prototype.addSubTwinEnemy = function(eventId, enemyId, mechClass, level, mode, targetId, items, squadId, targetRegion, factionId, counterBehavior) {\\r\\n\\tvar enemy_unit = new Game_Enemy(enemyId, 0, 0);\\r\\n    var event = $gameMap.event(eventId);\\r\\n\\tif(typeof squadId == \\\"undefined\\\" || squadId == \\\"\\\"){\\r\\n\\t\\tsquadId = -1;\\r\\n\\t}\\r\\n\\tif(typeof targetRegion == \\\"undefined\\\"|| targetRegion == \\\"\\\"){\\r\\n\\t\\ttargetRegion = -1;\\r\\n\\t}\\r\\n\\tif(typeof factionId == \\\"undefined\\\"|| factionId == \\\"\\\"){\\r\\n\\t\\tfactionId = 0;\\r\\n\\t}\\r\\n    if (enemy_unit && event) { \\t\\r\\n\\t\\tvar mainEnemy = $gameSystem.EventToUnit(eventId)[1];\\r\\n\\t\\t\\r\\n\\t\\tenemy_unit._mechClass = mechClass;\\t\\r\\n\\t\\tenemy_unit.squadId = squadId;\\t\\r\\n\\t\\tenemy_unit.targetRegion = targetRegion;\\t\\r\\n\\t\\tenemy_unit.factionId = factionId;\\t\\r\\n\\t\\tenemy_unit.targetUnitId = targetId || \\\"\\\";\\r\\n\\t\\tenemy_unit.counterBehavior = counterBehavior || \\\"attack\\\";\\r\\n\\t\\tif (enemy_unit) {\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif (mode) {\\r\\n\\t\\t\\t\\tenemy_unit.setBattleMode(mode);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tenemy_unit.initTp(); //TPを初期化\\r\\n\\t\\t\\tvar faceName = enemy_unit.enemy().meta.faceName; //顔グラフィックをプリロードする\\r\\n\\t\\t\\tif (faceName) {\\r\\n\\t\\t\\t\\tvar bitmap = ImageManager.loadFace(faceName);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tif ($gameSystem.isSideView()) {\\r\\n\\t\\t\\t\\t\\tvar bitmap = ImageManager.loadSvEnemy(enemy_unit.battlerName(), enemy_unit.battlerHue());\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tvar bitmap = ImageManager.loadEnemy(enemy_unit.battlerName(), enemy_unit.battlerHue());\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tvar oldValue = $gameVariables.value(_existEnemyVarID);\\r\\n\\t\\t\\t$gameVariables.setValue(_existEnemyVarID, oldValue + 1);\\t\\t\\t\\r\\n\\t\\t\\t$statCalc.initSRWStats(enemy_unit, level, items);\\r\\n\\t\\t\\t$statCalc.applyBattleStartWill(enemy_unit);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tenemy_unit.isSubTwin = true;\\t\\t\\t\\r\\n\\t\\t\\tmainEnemy.subTwin = enemy_unit;\\r\\n\\t\\t\\tmainEnemy.subTwinId = enemy_unit.enemyId();\\r\\n\\t\\t}\\r\\n    }\\r\\n\\t$statCalc.invalidateAbilityCache();\\r\\n    return true;\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.destroyEvents = function(startId, endId) {\\r\\n\\tfor(var i = startId; i <= endId; i++){\\r\\n\\t\\tthis.destroyEvent(i);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.destroyEvent = function(eventId) {\\r\\n\\t$gameMap.event(eventId).isDoingDeathAnim = true;\\r\\n\\tvar actor = $gameSystem.EventToUnit(eventId)[1];\\r\\n\\tif(actor.isActor()){\\r\\n\\t\\tvar oldValue = $gameVariables.value(_existActorVarID);\\r\\n\\t\\t$gameVariables.setValue(_existActorVarID, oldValue - 1);\\r\\n\\t} else {\\r\\n\\t\\tvar oldValue = $gameVariables.value(_existEnemyVarID);\\r\\n\\t\\t$gameVariables.setValue(_existEnemyVarID, oldValue - 1);\\r\\n\\t}\\r\\n\\t\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.eraseEventsOfType = function(type, omitted, toQueue) {\\r\\n\\tvar _this = this;\\r\\n\\tvar candidates = $statCalc.getAllCandidateActors(type);\\r\\n\\tcandidates.forEach(function(candidate){\\r\\n\\t\\tif(candidate.event){\\r\\n\\t\\t\\tif(omitted.indexOf(candidate.event.eventId()) == -1){\\r\\n\\t\\t\\t\\t_this.eraseEvent(candidate.event.eventId(), toQueue);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t});\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.eraseEvents = function(startId, endId, toQueue) {\\r\\n\\tfor(var i = startId; i <= endId; i++){\\r\\n\\t\\tthis.eraseEvent(i, toQueue);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.eraseEvent = function(eventId, toQueue) {\\r\\n\\tvar event = $gameMap.event(eventId);\\r\\n\\tif(event){\\r\\n\\t\\tif(toQueue){\\r\\n\\t\\t\\tif(!$gameTemp.disappearQueue){\\r\\n\\t\\t\\t\\t$gameTemp.disappearQueue = [];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$gameTemp.disappearQueue.push(event);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tevent.erase();\\r\\n\\t\\t}\\t\\r\\n\\t\\tevent.manuallyErased = true;\\r\\n\\t\\tvar actor = $gameSystem.EventToUnit(eventId)[1];\\r\\n\\t\\tif(actor.isActor()){\\r\\n\\t\\t\\tvar oldValue = $gameVariables.value(_existActorVarID);\\r\\n\\t\\t\\t$gameVariables.setValue(_existActorVarID, oldValue - 1);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tvar oldValue = $gameVariables.value(_existEnemyVarID);\\r\\n\\t\\t\\t$gameVariables.setValue(_existEnemyVarID, oldValue - 1);\\r\\n\\t\\t}\\r\\n\\t}\\t\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.updateWaitMode = function() {\\r\\n    var waiting = false;\\r\\n    switch (this._waitMode) {\\r\\n    case 'message':\\r\\n        waiting = $gameMessage.isBusy();\\r\\n        break;\\r\\n    case 'transfer':\\r\\n        waiting = $gamePlayer.isTransferring();\\r\\n        break;\\r\\n    case 'scroll':\\r\\n        waiting = $gameMap.isScrolling();\\r\\n        break;\\r\\n    case 'route':\\r\\n        waiting = this._character.isMoveRouteForcing();\\r\\n        break;\\r\\n    case 'animation':\\r\\n        waiting = this._character.isAnimationPlaying();\\r\\n        break;\\r\\n    case 'balloon':\\r\\n        waiting = this._character.isBalloonPlaying();\\r\\n        break;\\r\\n    case 'gather':\\r\\n        waiting = $gamePlayer.areFollowersGathering();\\r\\n        break;\\r\\n    case 'action':\\r\\n        waiting = BattleManager.isActionForced();\\r\\n        break;\\r\\n    case 'video':\\r\\n        waiting = Graphics.isVideoPlaying();\\r\\n        break;\\r\\n    case 'image':\\r\\n        waiting = !ImageManager.isReady();\\r\\n        break;\\r\\n\\tcase 'enemy_appear':\\r\\n        waiting = $gameTemp.enemyAppearQueueIsProcessing || $gameTemp.disappearQueueIsProcessing;\\r\\n        break;\\t\\r\\n\\tcase 'manual_deploy':\\r\\n\\t\\twaiting = $gameTemp.doingManualDeploy;\\r\\n\\t\\tbreak;\\t\\r\\n\\tcase 'move_to_point':\\r\\n\\t\\twaiting = $gameSystem.srpgWaitMoving();\\r\\n\\t\\tbreak;\\t\\r\\n\\tcase 'battle_demo':\\r\\n\\t\\twaiting = $gameTemp.playingBattleDemo;\\r\\n\\t\\tbreak;\\r\\n\\tcase 'spirit_activation':\\r\\n\\t\\twaiting = $gameTemp.playingSpiritAnimations;\\r\\n\\t\\tbreak;\\t\\t\\r\\n    }\\r\\n\\t\\r\\n    if (!waiting) {\\r\\n        this._waitMode = '';\\r\\n    }\\r\\n    return waiting;\\r\\n};\\r\\n\\r\\nGame_Interpreter.prototype.applyActorSpirits = function(actorId, spiritIds){\\r\\n\\tthis.applyEventSpirits($gameActors.actor(actorId).event.eventId(), spiritIds);\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.applyEventSpirits = function(eventId, spiritIds){\\r\\n\\tvar spirits = [];\\r\\n\\tvar event = $gameMap.event(eventId);\\r\\n\\t$gamePlayer.locate(event.posX(), event.posY());\\r\\n\\tvar actor = $gameSystem.EventToUnit(eventId)[1];\\r\\n\\tspiritIds.forEach(function(spiritId){\\r\\n\\t\\tspirits.push({\\r\\n\\t\\t\\tidx: spiritId,\\r\\n\\t\\t\\tlevel: 1,\\r\\n\\t\\t\\tcost: 0,\\r\\n\\t\\t\\tcaster: actor,\\r\\n\\t\\t\\ttarget: actor\\r\\n\\t\\t});\\r\\n\\t});\\r\\n\\t$gameTemp.playingSpiritAnimations = true;\\r\\n\\tthis.setWaitMode(\\\"spirit_activation\\\");\\r\\n\\t$gameTemp.eventSpirits = spirits;\\r\\n\\t$gameSystem.setSubBattlePhase(\\\"event_spirits\\\");\\r\\n\\tthis._index++;\\r\\n\\treturn false;\\r\\n}\\r\\n\\r\\nGame_Interpreter.requestImages = function(list, commonList){\\r\\n    if(!list) return;\\r\\n\\r\\n    list.forEach(function(command){\\r\\n        var params = command.parameters;\\r\\n        switch(command.code){\\r\\n            // Show Text\\r\\n            case 101:\\r\\n                ImageManager.requestFace(params[0]);\\r\\n                break;\\r\\n\\r\\n            // Common Event\\r\\n            case 117:\\r\\n                var commonEvent = $dataCommonEvents[params[0]];\\r\\n                if (commonEvent) {\\r\\n                    if (!commonList) {\\r\\n                        commonList = [];\\r\\n                    }\\r\\n                    if (!commonList.contains(params[0])) {\\r\\n                        commonList.push(params[0]);\\r\\n                        Game_Interpreter.requestImages(commonEvent.list, commonList);\\r\\n                    }\\r\\n                }\\r\\n                break;\\r\\n\\r\\n            // Change Party Member\\r\\n            case 129:\\r\\n                var actor = $gameActors.actor(params[0]);\\r\\n                if (actor && params[1] === 0) {\\r\\n                    var name = actor.characterName();\\r\\n                    ImageManager.requestCharacter(name);\\r\\n                }\\r\\n                break;\\r\\n\\r\\n            // Set Movement Route\\r\\n            case 205:\\r\\n                if(params[1]){\\r\\n                    params[1].list.forEach(function(command){\\r\\n                        var params = command.parameters;\\r\\n                        if(command.code === Game_Character.ROUTE_CHANGE_IMAGE){\\r\\n                            ImageManager.requestCharacter(params[0]);\\r\\n                        }\\r\\n                    });\\r\\n                }\\r\\n                break;\\r\\n\\r\\n            // Show Animation, Show Battle Animation\\r\\n            case 212: case 337:\\r\\n                if(params[1]) {\\r\\n                    var animation = $dataAnimations[params[1]];\\r\\n                    var name1 = animation.animation1Name;\\r\\n                    var name2 = animation.animation2Name;\\r\\n                    var hue1 = animation.animation1Hue;\\r\\n                    var hue2 = animation.animation2Hue;\\r\\n                    ImageManager.requestAnimation(name1, hue1);\\r\\n                    ImageManager.requestAnimation(name2, hue2);\\r\\n                }\\r\\n                break;\\r\\n\\r\\n            // Change Player Followers\\r\\n            case 216:\\r\\n                if (params[0] === 0) {\\r\\n                    $gamePlayer.followers().forEach(function(follower) {\\r\\n                        var name = follower.characterName();\\r\\n                        ImageManager.requestCharacter(name);\\r\\n                    });\\r\\n                }\\r\\n                break;\\r\\n\\r\\n            // Show Picture\\r\\n            case 231:\\r\\n                ImageManager.loadPicture(params[1]); //make show picture awaitable by the interpreter\\r\\n                break;\\r\\n\\r\\n            // Change Tileset\\r\\n            case 282:\\r\\n                var tileset = $dataTilesets[params[0]];\\r\\n                tileset.tilesetNames.forEach(function(tilesetName){\\r\\n                    ImageManager.requestTileset(tilesetName);\\r\\n                });\\r\\n                break;\\r\\n\\r\\n            // Change Battle Back\\r\\n            case 283:\\r\\n                if ($gameParty.inBattle()) {\\r\\n                    ImageManager.requestBattleback1(params[0]);\\r\\n                    ImageManager.requestBattleback2(params[1]);\\r\\n                }\\r\\n                break;\\r\\n\\r\\n            // Change Parallax\\r\\n            case 284:\\r\\n                if (!$gameParty.inBattle()) {\\r\\n                    ImageManager.requestParallax(params[0]);\\r\\n                }\\r\\n                break;\\r\\n\\r\\n            // Change Actor Images\\r\\n            case 322:\\r\\n                ImageManager.requestCharacter(params[1]);\\r\\n                ImageManager.requestFace(params[3]);\\r\\n                ImageManager.requestSvActor(params[5]);\\r\\n                break;\\r\\n\\r\\n            // Change Vehicle Image\\r\\n            case 323:\\r\\n                var vehicle = $gameMap.vehicle(params[0]);\\r\\n                if(vehicle){\\r\\n                    ImageManager.requestCharacter(params[1]);\\r\\n                }\\r\\n                break;\\r\\n\\r\\n            // Enemy Transform\\r\\n            case 336:\\r\\n                var enemy = $dataEnemies[params[1]];\\r\\n                var name = enemy.battlerName;\\r\\n                var hue = enemy.battlerHue;\\r\\n                if ($gameSystem.isSideView()) {\\r\\n                    ImageManager.requestSvEnemy(name, hue);\\r\\n                } else {\\r\\n                    ImageManager.requestEnemy(name, hue);\\r\\n                }\\r\\n                break;\\r\\n        }\\r\\n    });\\r\\n};\\r\\n\\r\\nGame_Interpreter.prototype.processEnemyAppearQueue = function(){\\r\\n\\tthis.setWaitMode(\\\"enemy_appear\\\");\\r\\n\\t$gameTemp.enemyAppearQueueIsProcessing = true;\\r\\n\\t$gameTemp.unitAppearTimer = 0;\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.processUnitAppearQueue = function(){\\r\\n\\tthis.setWaitMode(\\\"enemy_appear\\\");\\r\\n\\t$gameTemp.enemyAppearQueueIsProcessing = true;\\r\\n\\t$gameTemp.unitAppearTimer = 0;\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.processDisappearQueue = function(){\\r\\n\\tthis.setWaitMode(\\\"enemy_appear\\\");\\r\\n\\t$gameTemp.disappearQueueIsProcessing = true;\\r\\n\\t$gameTemp.unitAppearTimer = 0;\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.manualDeploy = function(unlockedOnly){\\r\\n\\tthis.setWaitMode(\\\"manual_deploy\\\");\\r\\n\\t$gameTemp.deployMode = \\\"\\\";\\r\\n\\t$gameTemp.manualDeployType = unlockedOnly ? \\\"unlocked\\\" : \\\"all\\\";\\r\\n\\t$gameTemp.doingManualDeploy = true;\\r\\n\\t$gameTemp.disableHighlightGlow = true;\\r\\n\\t$gameSystem.setSubBattlePhase(\\\"deploy_selection_window\\\");\\r\\n\\t$gameTemp.pushMenu = \\\"in_stage_deploy\\\";\\r\\n\\t$gameTemp.originalDeployInfo = JSON.parse(JSON.stringify($gameSystem.getDeployList()));\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.manualShipDeploy = function(){\\r\\n\\tthis.setWaitMode(\\\"manual_deploy\\\");\\r\\n\\t$gameTemp.deployMode = \\\"ships\\\";\\r\\n\\t$gameTemp.doingManualDeploy = true;\\r\\n\\t$gameTemp.disableHighlightGlow = true;\\r\\n\\t$gameSystem.setSubBattlePhase(\\\"deploy_selection_window\\\");\\r\\n\\t$gameTemp.pushMenu = \\\"in_stage_deploy\\\";\\r\\n\\t$gameTemp.originalDeployInfo = JSON.parse(JSON.stringify($gameSystem.getDeployList()));\\r\\n}\\r\\n\\r\\n// 指定した座標にプレイヤーを移動する\\r\\nGame_Interpreter.prototype.playerMoveTo = function(x, y) {\\r\\n    $gameTemp.setAutoMoveDestinationValid(true);\\r\\n    $gameTemp.setAutoMoveDestination(x, y);\\r\\n    return true;\\r\\n};\\r\\n\\r\\nGame_Interpreter.prototype.cursorMoveTo = function(x, y) {\\r\\n\\t$gamePlayer.locate(x, y);\\r\\n    return true;\\r\\n};\\r\\n\\r\\nGame_Interpreter.prototype.isActorInRegion = function(actorId, regionId) {\\r\\n\\treturn $statCalc.isActorInRegion(actorId, regionId);\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.isEnemyInRegion = function(enemyId, regionId) {\\r\\n\\treturn $statCalc.isEnemyInRegion(enemyId, regionId);\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.getActorKillCount = function(actorId) {\\r\\n\\treturn $statCalc.getKills($gameActors.actor(actorId));\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.setBattleModes = function(startId, endId, mode) {\\r\\n\\tfor(var i = startId; i <= endId; i++){\\r\\n\\t\\tthis.setBattleMode(i, mode);\\r\\n\\t}\\r\\n}\\r\\n\\r\\n// 指定したイベントの戦闘モードを設定する\\r\\nGame_Interpreter.prototype.setBattleMode = function(eventId, mode) {\\r\\n    var battlerArray = $gameSystem.EventToUnit(eventId);\\r\\n    if (battlerArray && (battlerArray[0] === 'actor' || battlerArray[0] === 'enemy')) {\\r\\n        battlerArray[1].setBattleMode(mode, true);\\t\\t\\t\\r\\n    }\\r\\n\\tif(battlerArray[0] === 'enemy'){\\r\\n\\t\\tif(battlerArray[1].squadId != -1){\\r\\n\\t\\t\\tthis.setSquadMode(squadId, mode);\\r\\n\\t\\t}\\r\\n\\t}\\t\\r\\n    return true;\\r\\n};\\r\\n\\r\\nGame_Interpreter.prototype.setTargetRegion = function(eventId, targetRegion) {\\r\\n    var battlerArray = $gameSystem.EventToUnit(eventId);\\r\\n    if (battlerArray && (battlerArray[0] === 'actor' || battlerArray[0] === 'enemy')) {\\r\\n        battlerArray[1].targetRegion = targetRegion;\\t\\t\\t\\t\\r\\n    }\\r\\n\\t\\r\\n    return true;\\r\\n};\\r\\n\\r\\nGame_Interpreter.prototype.setActorTargetRegion = function(actorId, targetRegion) {\\t\\r\\n\\treturn this.setTargetRegion($gameActors.actor(actorId).event.eventId(), targetRegion);\\r\\n};\\r\\n\\r\\n// 指定したイベントの戦闘モードを設定する\\r\\nGame_Interpreter.prototype.setActorBattleMode = function(actorId, mode) {  \\r\\n    $gameActors.actor(actorId).setBattleMode(mode, true);\\t\\t\\r\\n    return true;\\r\\n};\\r\\n\\r\\nGame_Interpreter.prototype.setSquadMode = function(squadId, mode) {\\r\\n\\t$gameMap.events().forEach(function(event) {\\r\\n\\t\\tif (event.isType() === 'enemy') {\\r\\n\\t\\t\\tvar enemy = $gameSystem.EventToUnit(event.eventId())[1];\\t\\r\\n\\t\\t\\tif(enemy.squadId == squadId){\\r\\n\\t\\t\\t\\tenemy.setBattleMode(mode, true);\\r\\n\\t\\t\\t}\\t\\r\\n\\t\\t}\\r\\n\\t});\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.isDeployed = function(actorId) {\\r\\n\\tvar isDeployed = false;\\r\\n\\t$gameMap.events().forEach(function(event) {\\r\\n\\t\\tif (event.isType() === 'actor') {\\r\\n\\t\\t\\tvar battlerArray = $gameSystem.EventToUnit(event.eventId());\\r\\n\\t\\t\\tif(battlerArray){\\r\\n\\t\\t\\t\\tvar actor = battlerArray[1];\\r\\n\\t\\t\\t\\tif(actor.actorId() == actorId){\\r\\n\\t\\t\\t\\t\\tisDeployed = true;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t});\\r\\n\\treturn isDeployed;\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.isSquadWiped = function(squadId) {\\r\\n\\tvar isWiped = true;\\r\\n\\t$gameMap.events().forEach(function(event) {\\r\\n\\t\\tif (event.isType() === 'enemy') {\\r\\n\\t\\t\\tvar enemy = $gameSystem.EventToUnit(event.eventId())[1];\\t\\r\\n\\t\\t\\tif(enemy.squadId == squadId && !event.isErased()){\\r\\n\\t\\t\\t\\tisWiped = false;\\r\\n\\t\\t\\t}\\t\\r\\n\\t\\t}\\r\\n\\t});\\r\\n\\treturn isWiped;\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.canObtainSRPoint = function() {\\r\\n\\treturn !$SRWSaveManager.isMapSRPointLocked($gameMap.mapId());\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.activeFaction = function() {\\r\\n\\treturn $gameTemp.currentFaction;\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.lastActorAttack = function() {\\r\\n\\treturn $gameTemp.lastActorAttack;\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.isActorHitBy = function(actorId, weaponId, includeSupport) {\\r\\n\\tvar result = false;\\r\\n\\tif($gameTemp.unitHitInfo && $gameTemp.unitHitInfo.actor){\\r\\n\\t\\tif($gameTemp.unitHitInfo.actor[actorId] && $gameTemp.unitHitInfo.actor[actorId][weaponId]){\\r\\n\\t\\t\\tvar hitInfo = $gameTemp.unitHitInfo.actor[actorId][weaponId];\\r\\n\\t\\t\\tif(includeSupport || !hitInfo.isSupport) {\\r\\n\\t\\t\\t\\tresult = true;\\r\\n\\t\\t\\t} \\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn result;\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.isEnemyHitBy = function(enemyId, weaponId, includeSupport) {\\r\\n\\tvar result = false;\\r\\n\\tif($gameTemp.unitHitInfo && $gameTemp.unitHitInfo.enemy){\\r\\n\\t\\tif($gameTemp.unitHitInfo.enemy[enemyId] && $gameTemp.unitHitInfo.enemy[enemyId][weaponId]){\\r\\n\\t\\t\\tvar hitInfo = $gameTemp.unitHitInfo.enemy[enemyId][weaponId];\\r\\n\\t\\t\\tif(includeSupport || !hitInfo.isSupport) {\\r\\n\\t\\t\\t\\tresult = true;\\r\\n\\t\\t\\t} \\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn result;\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.isEventHitBy = function(eventId, weaponId, includeSupport) {\\r\\n\\tvar result = false;\\r\\n\\tif($gameTemp.unitHitInfo && $gameTemp.unitHitInfo.event){\\r\\n\\t\\tif($gameTemp.unitHitInfo.event[eventId] && $gameTemp.unitHitInfo.event[eventId][weaponId]){\\r\\n\\t\\t\\tvar hitInfo = $gameTemp.unitHitInfo.event[eventId][weaponId];\\r\\n\\t\\t\\tif(includeSupport || !hitInfo.isSupport) {\\r\\n\\t\\t\\t\\tresult = true;\\r\\n\\t\\t\\t} \\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn result;\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.isActorInBattle = function(actorId) {\\r\\n\\tvar result = false;\\r\\n\\tif($gameTemp.currentBattleActor && $gameTemp.currentBattleActor.isActor()){\\r\\n\\t\\tif($gameTemp.currentBattleActor.actorId() == actorId){\\r\\n\\t\\t\\tresult = true;\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\tif($gameTemp.currentBattleActor.subTwin && $gameTemp.currentBattleActor.subTwin.actorId() == actorId){\\r\\n\\t\\t\\tresult = true;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tif($gameTemp.currentBattleEnemy && $gameTemp.currentBattleEnemy.isActor()){\\r\\n\\t\\tif($gameTemp.currentBattleEnemy.actorId() == actorId){\\r\\n\\t\\t\\tresult = true;\\r\\n\\t\\t}\\r\\n\\t\\tif($gameTemp.currentBattleEnemy.subTwin && $gameTemp.currentBattleEnemy.subTwin.actorId() == actorId){\\r\\n\\t\\t\\tresult = true;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn result;\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.isEnemyInBattle = function(enemyId) {\\r\\n\\tvar result = false;\\r\\n\\tif($gameTemp.currentBattleActor && $gameTemp.currentBattleActor.isEnemy()){\\r\\n\\t\\tif($gameTemp.currentBattleActor.enemyId() == enemyId){\\r\\n\\t\\t\\tresult = true;\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\tif($gameTemp.currentBattleActor.subTwin && $gameTemp.currentBattleActor.subTwin.enemyId() == enemyId){\\r\\n\\t\\t\\tresult = true;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tif($gameTemp.currentBattleEnemy && $gameTemp.currentBattleEnemy.isEnemy()){\\r\\n\\t\\tif($gameTemp.currentBattleEnemy.enemyId() == enemyId){\\r\\n\\t\\t\\tresult = true;\\r\\n\\t\\t}\\r\\n\\t\\tif($gameTemp.currentBattleEnemy.subTwin && $gameTemp.currentBattleEnemy.subTwin.enemyId() == enemyId){\\r\\n\\t\\t\\tresult = true;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn result;\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.isEventInBattle = function(eventId) {\\r\\n\\tvar result = false;\\r\\n\\tif($gameTemp.currentBattleActor && $gameTemp.currentBattleActor.event && $gameTemp.currentBattleActor.event.eventId() == eventId){\\r\\n\\t\\tresult = true;\\r\\n\\t}\\r\\n\\tif($gameTemp.currentBattleEnemy && $gameTemp.currentBattleEnemy.event && $gameTemp.currentBattleEnemy.event.eventId() == eventId){\\r\\n\\t\\tresult = true;\\r\\n\\t\\t\\r\\n\\t}\\r\\n\\treturn result;\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.applyFadeState = function() {\\r\\n\\tif(this.isTextSkipMode){\\r\\n\\t\\tif(this._lastFadeState == 0){\\r\\n\\t\\t\\t$gameScreen.startFadeOut(this.fadeSpeed());\\r\\n\\t\\t\\tthis.wait(this.fadeSpeed());\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t$gameScreen.startFadeIn(this.fadeSpeed());\\r\\n\\t\\t\\tthis.wait(this.fadeSpeed());\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.executeCommand = function() {\\r\\n    var command = this.currentCommand();\\r\\n\\t\\r\\n    if (command) {\\r\\n\\t\\t//Input.update();\\r\\n\\t\\tif(!this.isHaltingCommand(command) && Input.isPressed(\\\"ok\\\") && Input.isPressed(\\\"menu\\\")){\\r\\n\\t\\t\\tif(!this.isTextSkipMode){\\r\\n\\t\\t\\t\\t$gameScreen.startFadeOut(this.fadeSpeed());\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthis.isTextSkipMode = true;\\t\\t\\r\\n\\t\\t\\t$gameTemp.isSkippingEvents = true;\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif(this.isHaltingCommand(command)){\\r\\n\\t\\t\\tthis.applyFadeState();\\r\\n\\t\\t\\tthis.isTextSkipMode = false;\\t\\t\\r\\n\\t\\t\\t$gameTemp.isSkippingEvents = false;\\t\\r\\n\\t\\t}\\r\\n        this._params = command.parameters;\\r\\n        this._indent = command.indent;\\r\\n        var methodName = 'command' + command.code;\\r\\n        if (typeof this[methodName] === 'function') {\\r\\n            if (!this[methodName]()) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        this._index++;\\r\\n    } else {\\r\\n\\t\\tthis.applyFadeState();\\r\\n\\t\\tthis.isTextSkipMode = false;\\t\\t\\r\\n\\t\\t$gameTemp.isSkippingEvents = false;\\t\\r\\n        this.terminate();\\r\\n    }\\r\\n    return true;\\r\\n};\\r\\n\\r\\n// Fadeout Screen\\r\\nGame_Interpreter.prototype.command221 = function() {\\r\\n    if (!$gameMessage.isBusy()) {\\r\\n\\t\\tthis._lastFadeState = 0;\\r\\n\\t\\tif(!this.isTextSkipMode){\\r\\n\\t\\t\\t$gameScreen.startFadeOut(this.fadeSpeed());\\r\\n\\t\\t\\tthis.wait(this.fadeSpeed());\\r\\n\\t\\t}\\r\\n        this._index++;\\r\\n    }\\r\\n    return false;\\r\\n};\\r\\n\\r\\n// Fadein Screen\\r\\nGame_Interpreter.prototype.command222 = function() {\\r\\n    if (!$gameMessage.isBusy()) {\\r\\n\\t\\tthis._lastFadeState = 1;\\r\\n\\t\\tif(!this.isTextSkipMode){\\r\\n\\t\\t\\t$gameScreen.startFadeIn(this.fadeSpeed());\\r\\n\\t\\t\\tthis.wait(this.fadeSpeed());\\r\\n\\t\\t}\\r\\n        this._index++;\\r\\n    }\\r\\n    return false;\\r\\n};\\r\\n\\r\\n//Wait\\r\\nGame_Interpreter.prototype.command230 = function() {\\r\\n\\tif(!this.isTextSkipMode){\\r\\n\\t\\tthis.wait(this._params[0]);\\r\\n\\t}\\r\\n    return true;\\r\\n};\\r\\n\\r\\n// Show Animation\\r\\nGame_Interpreter.prototype.command212 = function() {\\r\\n    this._character = this.character(this._params[0]);\\r\\n    if (this._character && !this.isTextSkipMode) {\\r\\n        this._character.requestAnimation(this._params[1]);\\r\\n        if (this._params[2]) {\\r\\n            this.setWaitMode('animation');\\r\\n        }\\r\\n    }\\r\\n    return true;\\r\\n};\\r\\n\\r\\nGame_Interpreter.prototype.command101 = function() {\\r\\n    if (!$gameMessage.isBusy()) {\\r\\n        $gameMessage.setFaceImage(this._params[0], this._params[1]);\\r\\n        $gameMessage.setBackground(this._params[2]);\\r\\n        $gameMessage.setPositionType(this._params[3]);\\r\\n        while (this.nextEventCode() === 401) {  // Text data\\r\\n            this._index++;\\r\\n            $gameMessage.add(this.currentCommand().parameters[0]);\\r\\n        }\\r\\n        switch (this.nextEventCode()) {\\r\\n        case 102:  // Show Choices\\r\\n            this._index++;\\r\\n            this.setupChoices(this.currentCommand().parameters);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tthis.applyFadeState();\\r\\n\\t\\t\\tthis.isTextSkipMode = false;\\r\\n\\t\\t\\t$gameTemp.isSkippingEvents = false;\\t\\r\\n            break;\\r\\n        case 103:  // Input Number\\r\\n            this._index++;\\r\\n            this.setupNumInput(this.currentCommand().parameters);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tthis.applyFadeState();\\r\\n\\t\\t\\tthis.isTextSkipMode = false;\\r\\n\\t\\t\\t$gameTemp.isSkippingEvents = false;\\t\\r\\n            break;\\r\\n        case 104:  // Select Item\\r\\n            this._index++;\\r\\n            this.setupItemChoice(this.currentCommand().parameters);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tthis.applyFadeState();\\r\\n\\t\\t\\tthis.isTextSkipMode = false;\\r\\n\\t\\t\\t$gameTemp.isSkippingEvents = false;\\t\\r\\n            break;\\r\\n\\t\\tdefault: // Regular text \\r\\n\\t\\t\\tif(this.isTextSkipMode){\\r\\n\\t\\t\\t\\t$gameMessage.clear();\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\tbreak;\\r\\n        }\\r\\n        this._index++;\\r\\n        this.setWaitMode('message');\\r\\n    }\\r\\n    return false;\\r\\n};\\r\\n\\r\\n/**************************************\\r\\nSample:\\r\\n\\tthis.playBattleScene({\\r\\n\\t\\teventId: 0, // if included the matching event text will be used for the scene(see BattleText.conf.js).\\r\\n\\t\\tenemyFirst: 0, // if 0 the actor will move first, if 1 the enemy will move first. This also affects the supports. If 0, the actor support will be attacking otherwise defending. If 1, the enemy support will be attacking otherwise defending.\\r\\n\\t\\tsongId: \\\"Battle1\\\", // the id of the song that should be played during the battle scene\\r\\n\\t\\tactor: {\\r\\n\\t\\t\\tid: 1, // the id of the actor pilot\\r\\n\\t\\t\\taction: \\\"attack\\\", // the action the actor will take: \\\"attack\\\", \\\"defend\\\", \\\"evade\\\". \\r\\n\\t\\t\\tweapon: 1, // the id of the attack the actor will use. Only used if the action is \\\"attack\\\".\\r\\n\\t\\t\\thits: 1, // if 0 the attack performed by this unit will miss, if 1 the attack will hit \\r\\n\\t\\t\\tstartHP: 20, // the start HP of the actor in percent\\r\\n\\t\\t\\ttargetEndHP: 5, // the end HP of the target in percent\\r\\n\\t\\t\\tposX: 0, // the x coordinate of the position on the map where this unit stands(optional)\\r\\n\\t\\t\\tposY: 0, // the y coordinate of the position on the map where this unit stands(optional)\\r\\n\\t\\t\\treferenceEventId: 21 // if provided posX, posY and startHP will be derived from this event instead\\r\\n\\t\\t},\\r\\n\\t\\tactorTwin: {\\r\\n\\t\\t\\tid: 2, // the id of the actor pilot\\r\\n\\t\\t\\taction: \\\"attack\\\", // the action the actor will take: \\\"attack\\\", \\\"defend\\\", \\\"evade\\\". \\r\\n\\t\\t\\tweapon: 3, // the id of the attack the actor will use. Only used if the action is \\\"attack\\\".\\r\\n\\t\\t\\thits: 1, // if 0 the attack performed by this unit will miss, if 1 the attack will hit \\r\\n\\t\\t\\tstartHP: 20, // the start HP of the actor in percent\\r\\n\\t\\t\\ttargetEndHP: 5, // the end HP of the target in percent\\r\\n\\t\\t\\tposX: 0, // the x coordinate of the position on the map where this unit stands(optional)\\r\\n\\t\\t\\tposY: 0, // the y coordinate of the position on the map where this unit stands(optional)\\r\\n\\t\\t\\treferenceEventId: 21 // if provided posX, posY and startHP will be derived from this event instead\\r\\n\\t\\t},\\r\\n\\t\\tactorSupport: { // ommit this section if there is no actor supporter\\r\\n\\t\\t\\tid: 3, // the id of the actor pilot\\r\\n\\t\\t\\taction: \\\"attack\\\", // the action the actor will take: \\\"attack\\\", \\\"defend\\\", \\\"evade\\\". \\r\\n\\t\\t\\tweapon: 5, // the id of the attack the actor will use. Only used if the action is \\\"attack\\\".\\r\\n\\t\\t\\thits: 1, // if 0 the attack performed by this unit will miss, if 1 the attack will hit \\r\\n\\t\\t\\tstartHP: 100, // the start HP of the actor in percent\\r\\n\\t\\t\\ttargetEndHP: 0, // the end HP of the target in percent\\r\\n\\t\\t},\\r\\n\\t\\tenemy: {\\r\\n\\t\\t\\tid: 1, // the id of the enemy pilot\\r\\n\\t\\t\\tmechId: 10, // the id of the enemy mech\\r\\n\\t\\t\\tweapon: 6, // the id of the attack the actor will use. Only used if the action is \\\"attack\\\".\\r\\n\\t\\t\\taction: \\\"attack\\\", // the action the enemy will take: \\\"attack\\\", \\\"defend\\\", \\\"evade\\\". \\r\\n\\t\\t\\thits: 1, // if 0 the attack performed by this unit will miss, if 1 the attack will hit \\r\\n\\t\\t\\tstartHP: 80, // the start HP of the enemy in percent\\r\\n\\t\\t\\ttargetEndHP: 5, // the end HP of the target in percent\\r\\n\\t\\t},\\r\\n\\t\\tenemyTwin: {\\r\\n\\t\\t\\tid: 1, // the id of the enemy pilot\\r\\n\\t\\t\\tmechId: 10, // the id of the enemy mech\\r\\n\\t\\t\\tweapon: 6, // the id of the attack the actor will use. Only used if the action is \\\"attack\\\".\\r\\n\\t\\t\\taction: \\\"attack\\\", // the action the enemy will take: \\\"attack\\\", \\\"defend\\\", \\\"evade\\\". \\r\\n\\t\\t\\thits: 1, // if 0 the attack performed by this unit will miss, if 1 the attack will hit \\r\\n\\t\\t\\tstartHP: 80, // the start HP of the enemy in percent\\r\\n\\t\\t\\ttargetEndHP: 5, // the end HP of the target in percent\\r\\n\\t\\t},\\r\\n\\t\\tenemySupport: { // ommit this section if there is no enemy supporter\\r\\n\\t\\t\\tid: 3, // the id of the enemy pilot\\r\\n\\t\\t\\tmechId: 11,\\r\\n\\t\\t\\taction: \\\"defend\\\", // the action the enemy will take: \\\"attack\\\", \\\"defend\\\", \\\"evade\\\". \\r\\n\\t\\t\\thits: 1, // if 0 the attack performed by this unit will miss, if 1 the attack will hit \\r\\n\\t\\t\\tweapon: -1, // the id of the attack the actor will use. Only used if the action is \\\"attack\\\".\\r\\n\\t\\t\\tstartHP: 100, // the start HP of the enemy in percent\\r\\n\\t\\t\\ttargetEndHP: 0, // the end HP of the target in percent\\r\\n\\t\\t}\\t\\t\\t\\r\\n\\t});\\r\\n\\r\\n**************************************/\\r\\nGame_Interpreter.prototype.prepareBattleSceneActor = function(params) {\\r\\n\\tvar actor = new Game_Actor(params.id, 0, 0);\\r\\n\\t$statCalc.initSRWStats(actor);\\r\\n\\tif(params.mechId){\\r\\n\\t\\tactor._mechClass = params.mechId;\\t\\r\\n\\t\\t$statCalc.initSRWStats(actor);\\r\\n\\t}\\r\\n\\tparams.unit = actor;\\r\\n\\tactor.event = {\\r\\n\\t\\teventId: function(){return 1;}, \\r\\n\\t\\tposX: function(){return params.posX || 0},\\r\\n\\t\\tposY: function(){return params.posY || 0},\\r\\n\\t};\\r\\n\\t\\r\\n\\treturn {actor: actor, action: this.prepareBattleSceneAction(params), params: params};\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.prepareBattleSceneSupportActor = function(params) {\\r\\n\\tvar actor = new Game_Actor(params.id, 0, 0);\\r\\n\\t$statCalc.initSRWStats(actor);\\r\\n\\tif(params.mechId){\\r\\n\\t\\tactor._mechClass = params.mechId;\\t\\r\\n\\t\\t$statCalc.initSRWStats(actor);\\r\\n\\t}\\r\\n\\tparams.unit = actor;\\r\\n\\tactor.event = {\\r\\n\\t\\teventId: function(){return 3;},\\r\\n\\t\\tposX: function(){return params.posX || 0},\\r\\n\\t\\tposY: function(){return params.posY || 0},\\r\\n\\t};\\r\\n\\t\\r\\n\\treturn {actor: actor, action: this.prepareBattleSceneAction(params), params: params};\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.prepareBattleSceneActorTwin = function(params) {\\r\\n\\tvar actor = new Game_Actor(params.id, 0, 0);\\r\\n\\t$statCalc.initSRWStats(actor);\\r\\n\\tactor.isEventSubTwin = true;\\r\\n\\tactor.isSubTwin = true;\\r\\n\\tif(params.mechId){\\r\\n\\t\\tactor._mechClass = params.mechId;\\t\\r\\n\\t\\t$statCalc.initSRWStats(actor);\\r\\n\\t}\\r\\n\\tparams.unit = actor;\\r\\n\\tactor.event = {\\r\\n\\t\\teventId: function(){return 5;},\\r\\n\\t\\tposX: function(){return params.posX || 0},\\r\\n\\t\\tposY: function(){return params.posY || 0},\\r\\n\\t};\\r\\n\\t\\r\\n\\treturn {actor: actor, action: this.prepareBattleSceneAction(params), params: params};\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.prepareBattleSceneEnemy = function(params) {\\r\\n\\tvar enemy = new Game_Enemy(params.id, 0, 0);\\r\\n\\t$statCalc.initSRWStats(enemy);\\r\\n\\tparams.unit = enemy;\\r\\n\\tenemy._mechClass = params.mechId;\\t\\r\\n\\t$statCalc.initSRWStats(enemy);\\r\\n\\tenemy.event = {\\r\\n\\t\\teventId: function(){return 2;},\\r\\n\\t\\tposX: function(){return params.posX || 0},\\r\\n\\t\\tposY: function(){return params.posY || 0},\\r\\n\\t};\\r\\n\\treturn {actor: enemy, action: this.prepareBattleSceneAction(params), params: params};\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.prepareBattleSceneSupportEnemy = function(params) {\\r\\n\\tvar enemy = new Game_Enemy(params.id, 0, 0);\\r\\n\\t$statCalc.initSRWStats(enemy);\\r\\n\\tparams.unit = enemy;\\r\\n\\tenemy._mechClass = params.mechId;\\t\\r\\n\\t$statCalc.initSRWStats(enemy);\\r\\n\\tenemy.event = {\\r\\n\\t\\teventId: function(){return 4;},\\r\\n\\t\\tposX: function(){return params.posX || 0},\\r\\n\\t\\tposY: function(){return params.posY || 0},\\r\\n\\t};\\r\\n\\treturn {actor: enemy, action: this.prepareBattleSceneAction(params), params: params};\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.prepareBattleSceneEnemyTwin = function(params) {\\r\\n\\tvar enemy = new Game_Enemy(params.id, 0, 0);\\r\\n\\t$statCalc.initSRWStats(enemy);\\r\\n\\tenemy.isEventSubTwin = true;\\r\\n\\tenemy.isSubTwin = true;\\r\\n\\tparams.unit = enemy;\\r\\n\\tenemy._mechClass = params.mechId;\\t\\r\\n\\t$statCalc.initSRWStats(enemy);\\r\\n\\tenemy.event = {\\r\\n\\t\\teventId: function(){return 6;},\\r\\n\\t\\tposX: function(){return params.posX || 0},\\r\\n\\t\\tposY: function(){return params.posY || 0},\\r\\n\\t};\\r\\n\\treturn {actor: enemy, action: this.prepareBattleSceneAction(params), params: params};\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.prepareBattleSceneAction = function(params) {\\r\\n\\tvar unit = params.unit;\\r\\n\\t\\r\\n\\tvar weapon;\\r\\n\\tif(typeof params.weapon == \\\"object\\\"){\\r\\n\\t\\tweapon = params.weapon;\\r\\n\\t} else {\\r\\n\\t\\tweapon = $statCalc.getActorMechWeapon(unit, params.weapon)\\r\\n\\t}\\r\\n\\t\\r\\n\\tvar action;\\r\\n\\tif(params.action == \\\"attack\\\"){\\t\\t\\r\\n\\t\\taction = {\\r\\n\\t\\t\\ttype: \\\"attack\\\",\\r\\n\\t\\t\\tattack: weapon,\\r\\n\\t\\t\\ttarget: 0\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tif(params.action == \\\"defend\\\"){\\t\\t\\r\\n\\t\\taction = {\\r\\n\\t\\t\\ttype: \\\"defend\\\",\\r\\n\\t\\t\\tattack: -1,\\r\\n\\t\\t\\ttarget: 0\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tif(params.action == \\\"evade\\\"){\\t\\t\\r\\n\\t\\taction = {\\r\\n\\t\\t\\ttype: \\\"evade\\\",\\r\\n\\t\\t\\tattack: -1,\\r\\n\\t\\t\\ttarget: 0\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn action;\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.setBattleSceneHP = function(actor, params) {\\r\\n\\tif(actor && params){\\r\\n\\t\\tvar mechStats = $statCalc.getCalculatedMechStats(actor);\\r\\n\\t\\tmechStats.currentHP = Math.floor(mechStats.maxHP * (params.startHP / 100));\\r\\n\\t}\\t\\r\\n}\\r\\n\\r\\nGame_Interpreter.prototype.playBattleScene = function(params) {\\r\\n\\tthis.setWaitMode(\\\"battle_demo\\\");\\r\\n\\t$gameTemp.playingBattleDemo = true;\\r\\n\\t$gameTemp.battleEffectCache = {};\\r\\n\\t\\r\\n\\tvar actorInfo = this.prepareBattleSceneActor(params.actor);\\r\\n\\tvar enemyInfo = this.prepareBattleSceneEnemy(params.enemy);\\r\\n\\t\\t\\r\\n\\tvar actorTwinInfo;\\r\\n\\tif(params.actorTwin){\\r\\n\\t\\tactorTwinInfo = this.prepareBattleSceneActorTwin(params.actorTwin);\\r\\n\\t}\\r\\n\\t\\r\\n\\tvar enemyTwinInfo;\\r\\n\\tif(params.enemyTwin){\\r\\n\\t\\tenemyTwinInfo = this.prepareBattleSceneEnemyTwin(params.enemyTwin);\\r\\n\\t}\\r\\n\\t\\r\\n\\tvar actor = actorInfo.actor;\\r\\n\\tvar enemy = enemyInfo.actor;\\r\\n\\t\\r\\n\\tvar attacker;\\r\\n\\tvar attackerTwin;\\r\\n\\tvar defender;\\r\\n\\tvar defenderTwin;\\r\\n\\tvar attackerSide;\\r\\n\\tvar defenderSide;\\r\\n\\tif(params.enemyFirst){\\r\\n\\t\\tattackerSide = \\\"enemy\\\";\\r\\n\\t\\tdefenderSide = \\\"actor\\\";\\r\\n\\t\\tattacker = enemyInfo;\\r\\n\\t\\tdefender = actorInfo;\\r\\n\\t\\tattackerTwin = enemyTwinInfo;\\r\\n\\t\\tdefenderTwin = actorTwinInfo;\\r\\n\\t} else {\\r\\n\\t\\tattackerSide = \\\"actor\\\";\\r\\n\\t\\tdefenderSide = \\\"enemy\\\";\\r\\n\\t\\tattacker = actorInfo;\\r\\n\\t\\tdefender = enemyInfo;\\r\\n\\t\\tattackerTwin = actorTwinInfo;\\r\\n\\t\\tdefenderTwin = enemyTwinInfo;\\r\\n\\t}\\r\\n\\t\\r\\n\\t$battleCalc.prepareBattleCache(attacker, \\\"initiator\\\");\\r\\n\\t$battleCalc.prepareBattleCache(defender, \\\"defender\\\");\\r\\n\\t\\r\\n\\tif(attackerTwin){\\r\\n\\t\\t$battleCalc.prepareBattleCache(attackerTwin, \\\"twin attack\\\");\\r\\n\\t}\\r\\n\\t\\r\\n\\tif(defenderTwin){\\r\\n\\t\\t$battleCalc.prepareBattleCache(defenderTwin, \\\"twin defend\\\");\\r\\n\\t}\\r\\n\\t\\t\\r\\n\\t\\r\\n\\tvar actorCacheEntry = $gameTemp.battleEffectCache[actor._cacheReference];\\r\\n\\tvar enemyCacheEntry = $gameTemp.battleEffectCache[enemy._cacheReference];\\r\\n\\t\\r\\n\\tvar supportAttacker;\\r\\n\\tvar supportDefender;\\r\\n\\t\\r\\n\\tvar actorSupportInfo;\\t\\r\\n\\tif(params.actorSupport){\\r\\n\\t\\tactorSupportInfo = this.prepareBattleSceneSupportActor(params.actorSupport);\\t\\t\\r\\n\\t}\\r\\n\\tvar actorSupport;\\r\\n\\tvar actorSupportCacheEntry;\\r\\n\\tif(actorSupportInfo){\\r\\n\\t\\tactorSupport = actorSupportInfo.actor;\\r\\n\\t\\tif(params.enemyFirst){\\r\\n\\t\\t\\tsupportDefender = actorSupportInfo;\\r\\n\\t\\t\\t$battleCalc.prepareBattleCache(actorSupportInfo, \\\"support defend\\\");\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tsupportAttacker = actorSupportInfo;\\r\\n\\t\\t\\t$battleCalc.prepareBattleCache(actorSupportInfo, \\\"support attack\\\");\\r\\n\\t\\t}\\t\\r\\n\\t\\tactorSupportCacheEntry = $gameTemp.battleEffectCache[actorSupport._cacheReference];\\t\\r\\n\\t}\\r\\n\\t\\r\\n\\tvar enemySupportInfo;\\t\\r\\n\\tif(params.enemySupport){\\r\\n\\t\\tenemySupportInfo = this.prepareBattleSceneSupportEnemy(params.enemySupport);\\t\\t\\r\\n\\t}\\r\\n\\tvar enemySupport;\\r\\n\\tvar enemySupportCacheEntry;\\r\\n\\tif(enemySupportInfo){\\r\\n\\t\\tenemySupport = enemySupportInfo.actor;\\r\\n\\t\\tif(params.enemyFirst){\\r\\n\\t\\t\\tsupportAttacker = enemySupportInfo;\\r\\n\\t\\t\\t$battleCalc.prepareBattleCache(enemySupportInfo, \\\"support attack\\\");\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tsupportDefender = enemySupportInfo;\\r\\n\\t\\t\\t$battleCalc.prepareBattleCache(enemySupportInfo, \\\"support defend\\\");\\r\\n\\t\\t}\\t\\r\\n\\t\\tenemySupportCacheEntry = $gameTemp.battleEffectCache[enemySupport._cacheReference];\\t\\r\\n\\t}\\t\\r\\n\\t\\r\\n\\t\\t\\r\\n\\tthis.setBattleSceneHP(actor, params.actor);\\r\\n\\tthis.setBattleSceneHP(enemy, params.enemy);\\r\\n\\tthis.setBattleSceneHP(actorSupport, params.actorSupport);\\r\\n\\tthis.setBattleSceneHP(enemySupport, params.enemySupport);\\r\\n\\r\\n\\tfunction BattleAction(attacker, defender, supportDefender, side, isSupportAttack){\\r\\n\\t\\tthis._attacker = attacker;\\r\\n\\t\\tthis._defender = defender;\\r\\n\\t\\tthis._supportDefender = supportDefender;\\r\\n\\t\\tthis._side = side;\\r\\n\\t\\tthis._isSupportAttack = isSupportAttack;\\r\\n\\t}\\r\\n\\t\\r\\n\\tBattleAction.prototype.execute = function(orderIdx){\\r\\n\\t\\tvar aCache = $gameTemp.battleEffectCache[this._attacker.actor._cacheReference];\\r\\n\\t\\tif(this._isSupportAttack){\\r\\n\\t\\t\\taCache =  $gameTemp.battleEffectCache[this._attacker.actor._supportCacheReference];\\r\\n\\t\\t}\\r\\n\\t\\taCache.damageInflicted = 0;\\r\\n\\t\\taCache.side = this._side;\\r\\n\\t\\t\\r\\n\\t\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tvar defenders = [this._defender];\\r\\n\\t\\tif(this._attacker.action.attack && this._attacker.action.attack.isAll){\\r\\n\\t\\t\\tif(this._side == \\\"actor\\\"){ \\r\\n\\t\\t\\t\\tif(this._attacker.actor.isSubTwin && params.enemyTwin){\\r\\n\\t\\t\\t\\t\\tdefenders.push(enemyInfo);\\r\\n\\t\\t\\t\\t} else if(params.enemy){\\r\\n\\t\\t\\t\\t\\tdefenders.push(enemyTwinInfo);\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(this._side == \\\"enemy\\\"){\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tif(this._attacker.actor.isSubTwin && params.actorTwin){\\r\\n\\t\\t\\t\\t\\tdefenders.push(actorInfo);\\r\\n\\t\\t\\t\\t} else if(params.actor){\\r\\n\\t\\t\\t\\t\\tdefenders.push(actorTwinInfo);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tfor(var i = 0; i < defenders.length; i++){\\t\\r\\n\\t\\t\\tvar attackedRef = \\\"\\\";\\r\\n\\t\\t\\tif(i == 1){\\r\\n\\t\\t\\t\\tattackedRef = \\\"_all_sub\\\";\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tvar dCache = $gameTemp.battleEffectCache[defenders[i].actor._cacheReference];\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tvar activeDefender = this._defender;\\r\\n\\t\\t\\tif(this._supportDefender) {\\r\\n\\t\\t\\t\\tvar sCache = $gameTemp.battleEffectCache[this._supportDefender.actor._supportCacheReference];\\r\\n\\t\\t\\t\\tif(!sCache.hasActed){\\r\\n\\t\\t\\t\\t\\tactiveDefender = this._supportDefender;\\r\\n\\t\\t\\t\\t\\tdCache = sCache;\\r\\n\\t\\t\\t\\t\\tdCache.defended = defenders[i].actor;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\t\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tdCache.damageTaken = 0;\\r\\n\\t\\t\\tif(!aCache.isDestroyed && !dCache.isDestroyed){\\t\\t\\r\\n\\t\\t\\t\\taCache.actionOrder = orderIdx;\\r\\n\\t\\t\\t\\taCache[\\\"attacked\\\"+attackedRef] = dCache;\\r\\n\\t\\t\\t\\taCache.originalTarget = dCache;\\r\\n\\t\\t\\t\\taCache.hasActed = true;\\r\\n\\t\\t\\t\\tdCache.hasActed = true;\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tif(this._side == \\\"actor\\\"){\\r\\n\\t\\t\\t\\t\\tdCache.side = \\\"enemy\\\";\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tdCache.side = \\\"actor\\\";\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tvar isHit = this._attacker.params.hits;\\r\\n\\t\\t\\t\\tif(isHit){\\r\\n\\t\\t\\t\\t\\taCache[\\\"hits\\\"+attackedRef] = isHit;\\r\\n\\t\\t\\t\\t\\taCache.inflictedCritical = this._attacker.params.isCrit;\\r\\n\\t\\t\\t\\t\\tdCache.isHit = isHit;\\r\\n\\t\\t\\t\\t\\tdCache.tookCritical = this._attacker.params.isCrit;\\r\\n\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tvar mechStats = $statCalc.getCalculatedMechStats(activeDefender.actor);\\r\\n\\t\\t\\t\\t\\tvar damagePercent = activeDefender.params.startHP - this._attacker.params.targetEndHP;\\r\\n\\t\\t\\t\\t\\tvar damage = Math.floor(mechStats.maxHP * (damagePercent / 100));\\r\\n\\t\\t\\t\\t\\taCache[\\\"damageInflicted\\\"+attackedRef] = damage;\\r\\n\\t\\t\\t\\t\\tdCache.damageTaken+= damage;\\r\\n\\t\\t\\t\\t\\tif(this._attacker.params.targetEndHP <= 0){\\r\\n\\t\\t\\t\\t\\t\\tdCache.isDestroyed = true;\\r\\n\\t\\t\\t\\t\\t\\tdCache.destroyer = aCache.ref;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t} \\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\tvar currentTargetingSettings = {\\r\\n\\t\\tattacker: defender,\\r\\n\\t\\tattackerTwin: defenderTwin,\\r\\n\\t\\tdefender: attacker,\\r\\n\\t\\tdefenderTwin: attackerTwin\\r\\n\\t};\\r\\n\\t\\r\\n\\tif(params.actor){\\r\\n\\t\\tvar target;\\r\\n\\t\\tif(params.actor.target == \\\"twin\\\" && params.enemyTwin){\\r\\n\\t\\t\\ttarget = \\\"twin\\\";\\r\\n\\t\\t} else {\\r\\n\\t\\t\\ttarget = \\\"main\\\";\\r\\n\\t\\t}\\r\\n\\t\\tif(params.enemyFirst){\\r\\n\\t\\t\\tif(target == \\\"twin\\\"){\\r\\n\\t\\t\\t\\tcurrentTargetingSettings.defender = attackerTwin;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tcurrentTargetingSettings.defender = attacker;\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif(target == \\\"twin\\\"){\\r\\n\\t\\t\\t\\tcurrentTargetingSettings.attacker = defenderTwin;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tcurrentTargetingSettings.attacker = defender;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t} \\r\\n\\t\\r\\n\\tif(params.actorTwin){\\r\\n\\t\\tvar target;\\r\\n\\t\\tif(params.actorTwin.target == \\\"twin\\\" && params.enemyTwin){\\r\\n\\t\\t\\ttarget = \\\"twin\\\";\\r\\n\\t\\t} else {\\r\\n\\t\\t\\ttarget = \\\"main\\\";\\r\\n\\t\\t}\\r\\n\\t\\tif(params.enemyFirst){\\r\\n\\t\\t\\tif(target == \\\"twin\\\"){\\r\\n\\t\\t\\t\\tcurrentTargetingSettings.defenderTwin = attackerTwin;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tcurrentTargetingSettings.defenderTwin = attacker;\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif(target == \\\"twin\\\"){\\r\\n\\t\\t\\t\\tcurrentTargetingSettings.attackerTwin = defenderTwin;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tcurrentTargetingSettings.attackerTwin = defender;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\tif(params.enemy){\\r\\n\\t\\tvar target;\\r\\n\\t\\tif(params.enemy.target == \\\"twin\\\" && params.actorTwin){\\r\\n\\t\\t\\ttarget = \\\"twin\\\";\\r\\n\\t\\t} else {\\r\\n\\t\\t\\ttarget = \\\"main\\\";\\r\\n\\t\\t}\\r\\n\\t\\tif(params.enemyFirst){\\r\\n\\t\\t\\tif(target == \\\"twin\\\"){\\r\\n\\t\\t\\t\\tcurrentTargetingSettings.attacker = defenderTwin;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tcurrentTargetingSettings.attacker = defender;\\r\\n\\t\\t\\t}\\t\\t\\r\\n\\t\\t} else {\\t\\t\\t\\r\\n\\t\\t\\tif(target == \\\"twin\\\"){\\r\\n\\t\\t\\t\\tcurrentTargetingSettings.defender = attackerTwin;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tcurrentTargetingSettings.defender = attacker;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t} \\r\\n\\t\\r\\n\\tif(params.enemyTwin){\\r\\n\\t\\tvar target;\\r\\n\\t\\tif(params.enemyTwin.target == \\\"twin\\\" && params.actorTwin){\\r\\n\\t\\t\\ttarget = \\\"twin\\\";\\r\\n\\t\\t} else {\\r\\n\\t\\t\\ttarget = \\\"main\\\";\\r\\n\\t\\t}\\r\\n\\t\\tif(params.enemyFirst){\\r\\n\\t\\t\\tif(target == \\\"twin\\\"){\\r\\n\\t\\t\\t\\tcurrentTargetingSettings.attackerTwin = defenderTwin;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tcurrentTargetingSettings.attackerTwin = defender;\\r\\n\\t\\t\\t}\\t\\t\\r\\n\\t\\t} else {\\t\\t\\t\\r\\n\\t\\t\\tif(target == \\\"twin\\\"){\\r\\n\\t\\t\\t\\tcurrentTargetingSettings.defenderTwin = attackerTwin;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tcurrentTargetingSettings.defenderTwin = attacker;\\r\\n\\t\\t\\t}\\t\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\t\\r\\n\\t\\r\\n\\tvar actions = [];\\r\\n\\tif(!ENGINE_SETTINGS.USE_SRW_SUPPORT_ORDER && supportAttacker){\\t\\t\\t\\r\\n\\t\\tactions.push(new BattleAction(supportAttacker, currentTargetingSettings.attacker, supportDefender, attackerSide, true));\\t\\t\\t\\t\\t\\t\\t\\t\\r\\n\\t}\\t\\r\\n\\tif(attackerTwin){\\r\\n\\t\\tactions.push(new BattleAction(attackerTwin, currentTargetingSettings.attackerTwin, supportDefender, attackerSide));\\t\\r\\n\\t}\\r\\n\\tactions.push(new BattleAction(attacker, currentTargetingSettings.attacker, supportDefender, attackerSide));\\t\\r\\n\\t\\r\\n\\tif(ENGINE_SETTINGS.USE_SRW_SUPPORT_ORDER && supportAttacker){\\t\\t\\t\\r\\n\\t\\tactions.push(new BattleAction(supportAttacker, currentTargetingSettings.attacker, supportDefender, attackerSide, true));\\t\\t\\t\\t\\t\\t\\t\\t\\r\\n\\t}\\t\\r\\n\\t\\r\\n\\tif(defenderTwin){\\r\\n\\t\\tactions.push(new BattleAction(defenderTwin, currentTargetingSettings.defenderTwin, supportDefender, defenderSide));\\t\\r\\n\\t}\\r\\n\\tactions.push(new BattleAction(defender, currentTargetingSettings.defender, null, defenderSide));\\t\\t\\t\\r\\n\\t\\r\\n\\t\\r\\n\\tfor(var i = 0; i < actions.length; i++){\\r\\n\\t\\tactions[i].execute(i);\\r\\n\\t}\\r\\n\\tif(params.eventId != null){\\r\\n\\t\\t$gameTemp.scriptedBattleDemoId = params.eventId;\\r\\n\\t}\\r\\n\\t\\r\\n\\t$gameSystem.setSubBattlePhase('halt');\\r\\n\\t//SceneManager.stop();\\t\\r\\n\\t$battleSceneManager.playBattleScene();\\r\\n\\tif(params.songId){\\r\\n\\t\\t$songManager.playSong(params.songId);\\r\\n\\t}\\t\\r\\n}\\r\\n\\r\\n// 指定したイベントのターゲットＩＤを設定する（戦闘モードが'aimingEvent'または'aimingActor'でのみ機能する）\\r\\nGame_Interpreter.prototype.setTargetId = function(eventId, targetId) {\\r\\n    var battlerArray = $gameSystem.EventToUnit(eventId);\\r\\n    if (battlerArray && (battlerArray[0] === 'actor' || battlerArray[0] === 'enemy')) {\\r\\n        battlerArray[1].setTargetId(targetId);\\r\\n    }\\r\\n    return true;\\r\\n};\\r\\n\\r\\n// 指定したイベントが戦闘不能か指定したスイッチに返す\\r\\nGame_Interpreter.prototype.isUnitDead = function(switchId, eventId) {\\r\\n    $gameSwitches.setValue(switchId, false);\\r\\n    var battlerArray = $gameSystem.EventToUnit(eventId);\\r\\n    if (battlerArray && (battlerArray[0] === 'actor' || battlerArray[0] === 'enemy')) {\\r\\n        $gameSwitches.setValue(switchId, battlerArray[1].isDead());\\r\\n    }\\r\\n    return true;\\r\\n};\\r\\n\\r\\n// 指定した座標のイベントＩＤを取得する\\r\\nGame_Interpreter.prototype.isEventIdXy = function(variableId, x, y) {\\r\\n    $gameVariables.setValue(variableId, 0);\\r\\n    $gameMap.eventsXy(x, y).forEach(function(event) {\\r\\n        var battlerArray = $gameSystem.EventToUnit(event.eventId());\\r\\n        if (battlerArray && (battlerArray[0] === 'actor' || battlerArray[0] === 'enemy')) {\\r\\n            $gameVariables.setValue(variableId, event.eventId());\\r\\n        }\\r\\n    });\\r\\n    return true;\\r\\n};\\r\\n\\r\\n// 指定したイベントＩＤのユニットを全回復する\\r\\nGame_Interpreter.prototype.unitRecoverAll = function(eventId) {\\r\\n    var battlerArray = $gameSystem.EventToUnit(eventId);\\r\\n    if (battlerArray && (battlerArray[0] === 'actor' || battlerArray[0] === 'enemy')) {\\r\\n        if (battlerArray[1].isAlive()) {\\r\\n            battlerArray[1].recoverAll();\\r\\n        }\\r\\n    }\\r\\n    return true;\\r\\n};\\r\\n\\r\\n// 指定したイベントＩＤのユニットを復活する\\r\\nGame_Interpreter.prototype.unitRevive = function(eventId) {\\r\\n    var battlerArray = $gameSystem.EventToUnit(eventId);\\r\\n    var event = $gameMap.event(eventId);\\r\\n    if (battlerArray && (battlerArray[0] === 'actor' || battlerArray[0] === 'enemy')) {\\r\\n        if (battlerArray[1].isAlive()) {\\r\\n            return;\\r\\n        }\\r\\n        battlerArray[1].removeState(battlerArray[1].deathStateId());\\r\\n        var oldValue = $gameVariables.value(_existEnemyVarID);\\r\\n        $gameVariables.setValue(_existEnemyVarID, oldValue + 1);\\r\\n        var xy = event.makeAppearPoint(event, event.posX(), event.posY())\\r\\n        event.setPosition(xy[0], xy[1]);\\r\\n        event.appear();\\r\\n        $gameMap.setEventImages();\\r\\n    }\\r\\n};\\r\\n\\r\\n// 指定したイベントＩＤのユニットを指定したステートにする\\r\\nGame_Interpreter.prototype.unitAddState = function(eventId, stateId) {\\r\\n    var battlerArray = $gameSystem.EventToUnit(eventId);\\r\\n    var event = $gameMap.event(eventId);\\r\\n    if (battlerArray && event && (battlerArray[0] === 'actor' || battlerArray[0] === 'enemy')) {\\r\\n        var alreadyDead = battlerArray[1].isDead();\\r\\n        battlerArray[1].addState(stateId);\\r\\n        if (battlerArray[1].isDead() && !alreadyDead) {\\r\\n            if (!event.isErased()) {\\r\\n                event.erase();\\r\\n                if (battlerArray[0] === 'actor') {\\r\\n                    var oldValue = $gameVariables.value(_existActorVarID);\\r\\n                    $gameVariables.setValue(_existActorVarID, oldValue - 1);\\r\\n\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tvar oldValue = $gameVariables.value(_actorsDestroyed);\\r\\n                    $gameVariables.setValue(_actorsDestroyed, oldValue + 1);\\r\\n\\t\\t\\r\\n                } else if (battlerArray[0] === 'enemy') {\\r\\n                    var oldValue = $gameVariables.value(_existEnemyVarID);\\r\\n                    $gameVariables.setValue(_existEnemyVarID, oldValue - 1);\\r\\n\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tvar oldValue = $gameVariables.value(_enemiesDestroyed);\\r\\n                    $gameVariables.setValue(_enemiesDestroyed, oldValue + 1);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        battlerArray[1].clearResult();\\r\\n    }\\r\\n    return true;\\r\\n};\\r\\n\\r\\n// ターン終了を行う（メニューの「ターン終了」と同じ）\\r\\n    Game_Interpreter.prototype.turnEnd = function() {\\r\\n        $gameTemp.setTurnEndFlag(true);\\r\\n        return true;\\r\\n    };\\r\\n\\r\\n// プレイヤーの操作を受け付けるかの判定（操作できるサブフェーズか？）\\r\\n    Game_Interpreter.prototype.isSubPhaseNormal = function(id) {\\r\\n        if ($gameSystem.isBattlePhase() === 'actor_phase' && $gameSystem.isSubBattlePhase() === 'normal') {\\r\\n            $gameSwitches.setValue(id, true);\\r\\n        } else {\\r\\n            $gameSwitches.setValue(id, false);\\r\\n        }\\r\\n        return true;\\r\\n    };\\r\\n\\t\\r\\n\\t\\r\\n\\tGame_Interpreter.prototype.runSubEvent = function(id) {\\r\\n        $gameMap.events().forEach(function(event) {\\r\\n            if (event.event().meta.function == id) {\\r\\n\\t\\t\\t\\tif (event.pageIndex() >= 0){\\r\\n\\t\\t\\t\\t\\t$gameMap._interpreter.setupChild(event.list(), 0);\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n            }\\r\\n        });\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// ●Sprite_Actor\\r\\n//====================================================================\\r\\n    //アクタースプライトの基準位置\\r\\n    var _SRPG_Sprite_Actor_setActorHome = Sprite_Actor.prototype.setActorHome;\\r\\n    Sprite_Actor.prototype.setActorHome = function(index) {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            this.setHome(Graphics.width - 216 - index * 240, Graphics.height / 2 + 48);\\r\\n        } else {\\r\\n            _SRPG_Sprite_Actor_setActorHome.call(this, index);\\r\\n        }\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// ●Sprite_Character\\r\\n//====================================================================\\r\\n\\t\\r\\n\\t\\r\\n\\tGame_CharacterBase.prototype.characterIndex = function() {\\r\\n\\t\\tvar filename = this.characterName();\\r\\n\\t\\tvar index = this._characterIndex;\\r\\n\\t\\tif($gameSystem.characterIdexAliases && $gameSystem.characterIdexAliases[filename]){\\r\\n\\t\\t\\t index = $gameSystem.characterIdexAliases[filename];\\r\\n\\t\\t}\\r\\n\\t\\treturn index;\\r\\n\\t};\\r\\n\\t\\r\\n\\tGame_CharacterBase.prototype.moveStraight = function(d) {\\r\\n    this.setMovementSuccess(this.canPass(this._x, this._y, d));\\r\\n    if (this.isMovementSucceeded()) {\\r\\n        this.setDirection(d);\\r\\n\\t\\tthis._prevX = this._x;\\r\\n        this._prevY = this._y;\\r\\n        this._x = $gameMap.roundXWithDirection(this._x, d);\\r\\n        this._y = $gameMap.roundYWithDirection(this._y, d);\\r\\n        this._realX = $gameMap.xWithDirection(this._x, this.reverseDir(d));\\r\\n        this._realY = $gameMap.yWithDirection(this._y, this.reverseDir(d));\\r\\n        this.increaseSteps();\\r\\n    } else {\\r\\n        this.setDirection(d);\\r\\n        this.checkEventTriggerTouchFront(d);\\r\\n    }\\r\\n};\\r\\n\\t\\r\\n\\tfunction Sprite_Player() {\\r\\n        this.initialize.apply(this, arguments);\\r\\n    }\\r\\n\\r\\n    Sprite_Player.prototype = Object.create(Sprite_Character.prototype);\\r\\n    Sprite_Player.prototype.constructor = Sprite_Player;\\r\\n\\t\\r\\n\\tSprite_Player.prototype.updatePosition = function() {\\r\\n\\t\\tthis.x = this._character.screenX();\\r\\n\\t\\tthis.y = this._character.screenY();\\r\\n\\t\\tthis.z = this._character.screenZ();\\r\\n\\t\\t\\r\\n\\t\\tif($gamePlayer.followedEvent && $gameTemp.followMove){\\t\\t\\t\\r\\n\\t\\t\\tthis.y = this.y + ($gamePlayer.followedEvent._floatOffset);\\t\\t\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tvar prevUnit = $statCalc.activeUnitAtPosition({x: this._character._prevX, y: this._character._prevY});\\r\\n\\t\\t\\tvar prevHoverState = prevUnit && $statCalc.isFlying(prevUnit);\\r\\n\\t\\t\\tvar newUnit = $statCalc.activeUnitAtPosition({x: this._character._x, y: this._character._y});\\r\\n\\t\\t\\tvar newHoverState = newUnit && $statCalc.isFlying(newUnit);\\r\\n\\t\\t\\tif(prevHoverState == newHoverState){\\r\\n\\t\\t\\t\\tif(prevHoverState){\\r\\n\\t\\t\\t\\t\\tthis.y = this.y + (newUnit.event._floatOffset);\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\t} else if(prevHoverState || newHoverState){\\r\\n\\t\\t\\t\\tvar floatOffset = 0;\\r\\n\\t\\t\\t\\tif(prevHoverState && prevUnit){\\r\\n\\t\\t\\t\\t\\tfloatOffset = prevUnit.event._floatOffset;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(newHoverState && newUnit){\\r\\n\\t\\t\\t\\t\\tfloatOffset = newUnit.event._floatOffset;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tvar delta = 0;\\r\\n\\t\\t\\t\\tif(this._character._x != this._character._realX || this._character._y != this._character._realY){\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tif(this._character._x != this._character._realX){\\r\\n\\t\\t\\t\\t\\t\\tdelta = Math.abs(this._character._x - this._character._realX);\\r\\n\\t\\t\\t\\t\\t} else if(this._character._y != this._character._realY){\\r\\n\\t\\t\\t\\t\\t\\tdelta = Math.abs(this._character._y - this._character._realY);\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tvar ratio;\\r\\n\\t\\t\\t\\tif(newHoverState){\\r\\n\\t\\t\\t\\t\\tratio = 1 - delta;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tratio = 0 + delta;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tthis.y = this.y + (floatOffset * ratio);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\t/*\\r\\n\\t\\tif(this._upperBody && this._lowerBody){\\r\\n\\t\\t\\tthis._upperBody.x = this.x;\\r\\n\\t\\t\\tthis._upperBody.y = this.y;\\r\\n\\t\\t\\tthis._upperBody.z = this.z + 1;\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tthis._lowerBody.x = this.x;\\r\\n\\t\\t\\tthis._lowerBody.y = this.y + 24;\\r\\n\\t\\t\\tthis._lowerBody.z = this.z;\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tthis._turnEndSprite.x = this.x - 20;\\r\\n\\t\\t\\tthis._turnEndSprite.y = this.y - this._character._floatOffset;\\r\\n\\t\\t\\tthis._turnEndSprite.z = this.z + 2;\\r\\n\\t\\t}*/\\r\\n\\t};\\r\\n\\t\\r\\n\\t//Character sprites are split into two a bottom and top part to improve overlap for units whose map icon goes outside their current tiles.\\r\\n\\t//This can happen for flying units for example.\\r\\n\\t//The base sprite is normally hidden, but is still available.\\r\\n\\t\\r\\n\\tSprite_Character.prototype.allBodyPartsAvailable = function(character) {\\r\\n\\t\\treturn this._upperBody && this._lowerBody && this._upperBodyTop && this._upperBodyOverlay && this._lowerBodyOverlay;\\r\\n\\t}\\r\\n\\t\\r\\n\\tSprite_Character.prototype.update = function(character) {\\r\\n\\t\\tSprite_Base.prototype.update.call(this);\\r\\n\\t\\tif(!this.visible) {\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\tthis.updateBitmap();\\r\\n\\t\\tthis.updateFrame();\\r\\n\\t\\tthis.updatePosition();\\r\\n\\t\\tthis.updateAnimation();\\r\\n\\t\\tthis.updateBalloon();\\r\\n\\t\\tthis.updateOther();\\r\\n\\t\\tif (this._character.isEvent() == true) {\\r\\n\\t\\t\\tvar battlerArray = $gameSystem.EventToUnit(this._character.eventId());\\r\\n\\t\\t\\tif (battlerArray) {\\r\\n\\t\\t\\t\\tif ($gameSystem.isEnemy(battlerArray[1]) && !ENGINE_SETTINGS.KEEP_ENEMY_SPRITE_ORIENTATION) {\\r\\n\\t\\t\\t\\t\\tthis.scale.x = -1;\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tif(this.allBodyPartsAvailable()){\\t\\r\\n\\t\\t\\t\\t\\t\\tthis._upperBody.scale.x = -1;\\r\\n\\t\\t\\t\\t\\t\\tthis._upperBodyOverlay.scale.x = -1;\\r\\n\\t\\t\\t\\t\\t\\tthis._upperBodyTop.scale.x = -1;\\r\\n\\t\\t\\t\\t\\t\\tthis._lowerBody.scale.x = -1;\\r\\n\\t\\t\\t\\t\\t\\tthis._lowerBodyOverlay.scale.x = -1;\\r\\n\\t\\t\\t\\t\\t}\\t\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tthis.scale.x = 1;\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tif(this.allBodyPartsAvailable()){\\t\\r\\n\\t\\t\\t\\t\\t\\tthis._upperBody.scale.x = 1;\\r\\n\\t\\t\\t\\t\\t\\tthis._upperBodyOverlay.scale.x = 1;\\r\\n\\t\\t\\t\\t\\t\\tthis._upperBodyTop.scale.x = 1;\\r\\n\\t\\t\\t\\t\\t\\tthis._lowerBody.scale.x = 1;\\r\\n\\t\\t\\t\\t\\t\\tthis._lowerBodyOverlay.scale.x = 1;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(this.allBodyPartsAvailable()){\\t\\r\\n\\t\\t\\t\\t\\tif(battlerArray[0] === 'actor' && $gameTemp.doingManualDeploy){\\r\\n\\t\\t\\t\\t\\t\\tthis._frameCount+=2;\\r\\n\\t\\t\\t\\t\\t\\tthis._frameCount %= 200;\\r\\n\\t\\t\\t\\t\\t\\tif(this._frameCount < 100){\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._upperBody.opacity = this._frameCount + 80;\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._upperBodyTop.opacity = this._frameCount + 80;\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._lowerBody.opacity = this._frameCount + 80;\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._upperBody.opacity = 200 + 80 - this._frameCount;\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._upperBodyTop.opacity = 200 + 80 - this._frameCount;\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._lowerBody.opacity = 200 + 80 - this._frameCount;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\tthis._upperBody.opacity = 255;\\r\\n\\t\\t\\t\\t\\t\\tthis._upperBodyTop.opacity = 255;\\r\\n\\t\\t\\t\\t\\t\\tthis._lowerBody.opacity = 255;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tthis._upperBodyOverlay.opacity = 0;\\r\\n\\t\\t\\t\\t\\tthis._lowerBodyOverlay.opacity = 0;\\r\\n\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tvar refX;\\r\\n\\t\\t\\t\\t\\tvar refY;\\r\\n\\t\\t\\t\\t\\tif(this._character._x != this._character._realX || this._character._y != this._character._realY){\\r\\n\\t\\t\\t\\t\\t\\tif($gameMap.hasStarTile(this._character._x,  this._character._y) || $gameMap.hasStarTile(this._character._prevX,  this._character._prevY)){\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._upperBodyTop.opacity = 0;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\t\\tif($gameSystem.foregroundSpriteToggleState == 0){\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tthis._upperBodyOverlay.opacity = 0;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tthis._lowerBodyOverlay.opacity = 0;\\r\\n\\t\\t\\t\\t\\t\\t\\t} else if($gameSystem.foregroundSpriteToggleState == 1){\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tthis._upperBodyOverlay.opacity = 128;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tthis._lowerBodyOverlay.opacity = 128;\\r\\n\\t\\t\\t\\t\\t\\t\\t} else if($gameSystem.foregroundSpriteToggleState == 2){\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tthis._upperBodyOverlay.opacity = 255;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tthis._lowerBodyOverlay.opacity = 255;\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t\\t//this._upperBodyOverlay.opacity = 128;\\r\\n\\t\\t\\t\\t\\t\\t\\t//this._lowerBodyOverlay.opacity = 128;\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._upperBodyTop.opacity = 255;\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._upperBody.opacity = 0;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\tif($gameMap.hasStarTile(this._character._x,  this._character._y)){\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._upperBodyTop.opacity = 0;\\r\\n\\t\\t\\t\\t\\t\\t\\tif($gameSystem.foregroundSpriteToggleState == 0){\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tthis._upperBodyOverlay.opacity = 0;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tthis._lowerBodyOverlay.opacity = 0;\\r\\n\\t\\t\\t\\t\\t\\t\\t} else if($gameSystem.foregroundSpriteToggleState == 1){\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tthis._upperBodyOverlay.opacity = 128;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tthis._lowerBodyOverlay.opacity = 128;\\r\\n\\t\\t\\t\\t\\t\\t\\t} else if($gameSystem.foregroundSpriteToggleState == 2){\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tthis._upperBodyOverlay.opacity = 255;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tthis._lowerBodyOverlay.opacity = 255;\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t\\t//this._upperBodyOverlay.opacity = 128;\\r\\n\\t\\t\\t\\t\\t\\t\\t//this._lowerBodyOverlay.opacity = 128;\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._upperBodyTop.opacity = 255;\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._upperBody.opacity = 0;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\t\\r\\n\\t\\t\\t\\t\\tif($gameTemp.activeEvent() == this._character || \\r\\n\\t\\t\\t\\t\\t\\t$gameTemp._TargetEvent == this._character ||\\r\\n\\t\\t\\t\\t\\t\\t$gameSystem.isSubBattlePhase() == \\\"actor_move\\\" || \\r\\n\\t\\t\\t\\t\\t\\t$gameSystem.isSubBattlePhase()== \\\"enemy_move\\\" || \\r\\n\\t\\t\\t\\t\\t\\t$gameSystem.isSubBattlePhase()== \\\"actor_target\\\" || \\r\\n\\t\\t\\t\\t\\t\\t$gameSystem.isSubBattlePhase() == \\\"enemy_targeting_display\\\" ||\\r\\n\\t\\t\\t\\t\\t\\t$gameSystem.isSubBattlePhase() == \\\"post_move_command_window\\\"\\r\\n\\t\\t\\t\\t\\t){\\r\\n\\t\\t\\t\\t\\t\\tthis._upperBodyOverlay.opacity = 255;\\r\\n\\t\\t\\t\\t\\t\\tthis._lowerBodyOverlay.opacity = 255;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tif(battlerArray && battlerArray[1] && $statCalc.getCurrentTerrain(battlerArray[1]) == \\\"water\\\"){\\r\\n\\t\\t\\t\\t\\t\\tthis._upperBody.opacity-=120;\\r\\n\\t\\t\\t\\t\\t\\tthis._upperBodyOverlay.opacity-=120;\\r\\n\\t\\t\\t\\t\\t\\tthis._upperBodyTop.opacity-=120;\\r\\n\\t\\t\\t\\t\\t\\tthis._lowerBody.opacity-=120;\\r\\n\\t\\t\\t\\t\\t\\tthis._lowerBodyOverlay.opacity-=120;\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}\\t\\t\\r\\n\\t}\\r\\n\\t\\r\\n    Sprite_Character.prototype.isTurnEndUnit = function() {\\r\\n        if (this._character.isEvent() == true) {\\r\\n            var battlerArray = $gameSystem.EventToUnit(this._character.eventId());\\r\\n            if (battlerArray) {\\r\\n                if (battlerArray[0] === 'actor' || battlerArray[0] === 'enemy') {\\r\\n                    return battlerArray[1].srpgTurnEnd();\\r\\n                }\\r\\n            } else {\\r\\n                return false;\\r\\n            }\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    };\\r\\n\\r\\n    //キャラクタービットマップの更新\\r\\n    var _SRPG_Sprite_Character_setCharacterBitmap = Sprite_Character.prototype.setCharacterBitmap;\\r\\n    Sprite_Character.prototype.setCharacterBitmap = function() {\\r\\n        _SRPG_Sprite_Character_setCharacterBitmap.call(this);\\r\\n        this._turnEndBitmap = ImageManager.loadCharacter('srpg_set');\\r\\n\\t\\tthis._frameCount = 0;\\r\\n    };\\r\\n\\t\\r\\n\\tSprite_Character.prototype.setUpperBodyTop = function(sprite) {\\r\\n\\t\\tthis._upperBodyTop = sprite;\\r\\n\\t\\tthis._upperBodyTop.anchor.x = 0.5;\\r\\n        this._upperBodyTop.anchor.y = 2;\\r\\n\\t}\\r\\n\\t\\r\\n\\tSprite_Character.prototype.setUpperBody = function(sprite) {\\r\\n\\t\\tthis._upperBody = sprite;\\r\\n\\t\\tthis._upperBody.anchor.x = 0.5;\\r\\n        this._upperBody.anchor.y = 2;\\r\\n\\t}\\r\\n\\r\\n\\tSprite_Character.prototype.setLowerBody = function(sprite) {\\r\\n\\t\\tthis._lowerBody = sprite;\\r\\n\\t\\tthis._lowerBody.anchor.x = 0.5;\\r\\n        this._lowerBody.anchor.y = 2;\\r\\n\\t}\\r\\n\\t\\r\\n\\tSprite_Character.prototype.setUpperBodyOverlay = function(sprite) {\\r\\n\\t\\tthis._upperBodyOverlay = sprite;\\r\\n\\t\\tthis._upperBodyOverlay.anchor.x = 0.5;\\r\\n        this._upperBodyOverlay.anchor.y = 2;\\r\\n\\t}\\r\\n\\r\\n\\tSprite_Character.prototype.setLowerBodyOverlay = function(sprite) {\\r\\n\\t\\tthis._lowerBodyOverlay = sprite;\\r\\n\\t\\tthis._lowerBodyOverlay.anchor.x = 0.5;\\r\\n        this._lowerBodyOverlay.anchor.y = 2;\\r\\n\\t}\\r\\n\\t\\r\\n\\tSprite_Character.prototype.setTurnEnd = function(sprite) {\\r\\n\\t\\tthis._turnEndSprite = sprite;\\r\\n\\t\\tthis._turnEndSprite.anchor.x = 0;\\r\\n        this._turnEndSprite.anchor.y = 1;\\r\\n\\t}\\r\\n\\r\\n\\t\\r\\n\\tSprite_Character.prototype.updateHalfBodySprites = function() {   \\r\\n\\t\\tif(this.allBodyPartsAvailable()){\\t\\t\\r\\n\\t\\t\\tthis._upperBody.bitmap = this.bitmap;\\r\\n\\t\\t\\tthis._upperBody.visible = true;\\r\\n\\t\\t\\tthis._upperBodyTop.bitmap = this.bitmap;\\r\\n\\t\\t\\tthis._upperBodyTop.visible = true;\\r\\n\\t\\t\\tthis._lowerBody.bitmap = this.bitmap;\\r\\n\\t\\t\\tthis._lowerBody.visible = true;\\t\\r\\n\\t\\t\\tthis._upperBodyOverlay.bitmap = this.bitmap;\\r\\n\\t\\t\\tthis._upperBodyOverlay.visible = true;\\r\\n\\t\\t\\tthis._lowerBodyOverlay.bitmap = this.bitmap;\\r\\n\\t\\t\\tthis._lowerBodyOverlay.visible = true;\\t\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\t\\r\\n\\tSprite_Character.prototype.updatePosition = function() {\\r\\n\\t\\tthis.x = this._character.screenX();\\r\\n\\t\\tthis.y = this._character.screenY();\\r\\n\\t\\tthis.z = this._character.screenZ();\\r\\n\\t\\t\\r\\n\\t\\tif(this.allBodyPartsAvailable()){\\r\\n\\t\\t\\tthis._upperBody.x = this.x;\\r\\n\\t\\t\\tthis._upperBody.y = this.y;\\r\\n\\t\\t\\tthis._upperBody.z = this.z + 1;\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tthis._upperBodyOverlay.x = this.x;\\r\\n\\t\\t\\tthis._upperBodyOverlay.y = this.y;\\r\\n\\t\\t\\tthis._upperBodyOverlay.z = this.z + 1;\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tthis._upperBodyTop.x = this.x;\\r\\n\\t\\t\\tthis._upperBodyTop.y = this.y;\\r\\n\\t\\t\\tthis._upperBodyTop.z = this.z + 1;\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tthis._lowerBody.x = this.x;\\r\\n\\t\\t\\tthis._lowerBody.y = this.y + 24;\\r\\n\\t\\t\\tthis._lowerBody.z = this.z;\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tthis._lowerBodyOverlay.x = this.x;\\r\\n\\t\\t\\tthis._lowerBodyOverlay.y = this.y + 24;\\r\\n\\t\\t\\tthis._lowerBodyOverlay.z = this.z;\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tthis._turnEndSprite.x = this.x - 20;\\r\\n\\t\\t\\tthis._turnEndSprite.y = this.y - this._character._floatOffset;\\r\\n\\t\\t\\tthis._turnEndSprite.z = this.z + 2;\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\t\\r\\n    //キャラクターフレームの更新\\r\\n    var _SRPG_Sprite_Character_updateCharacterFrame = Sprite_Character.prototype.updateCharacterFrame;\\r\\n    Sprite_Character.prototype.updateCharacterFrame = function() {\\r\\n\\t\\tvar pw = this.patternWidth();\\r\\n\\t\\tvar ph = this.patternHeight();\\r\\n\\t\\tvar sx = (this.characterBlockX() + this.characterPatternX()) * pw;\\r\\n\\t\\tvar sy = (this.characterBlockY() + this.characterPatternY()) * ph;\\r\\n\\t\\t\\r\\n\\t\\tif(this.allBodyPartsAvailable() && this._character.isEvent() == true){\\t\\r\\n\\t\\t\\tvar battlerArray = $gameSystem.EventToUnit(this._character.eventId());\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tthis.updateHalfBodySprites();\\r\\n\\t\\t\\r\\n\\t\\t\\tvar d = 24;\\r\\n\\t\\t\\tthis._upperBody.setFrame(sx, sy, pw, ph - d);\\r\\n\\t\\t\\tthis._upperBodyTop.setFrame(sx, sy, pw, ph - d);\\r\\n\\t\\t\\tthis._upperBodyOverlay.setFrame(sx, sy, pw, ph - d);\\r\\n\\t\\t\\tthis._lowerBody.setFrame(sx, sy + ph - d, pw, d);\\t\\r\\n\\t\\t\\tthis._lowerBodyOverlay.setFrame(sx, sy + ph - d, pw, d);\\t\\r\\n\\r\\n\\t\\t\\tif($gameSystem.isSubBattlePhase() !== 'actor_map_target_confirm' || $gameTemp.isMapTarget(this._character.eventId())){\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tif(battlerArray && battlerArray[1] && $statCalc.getCurrentTerrain(battlerArray[1]) == \\\"water\\\"){\\r\\n\\t\\t\\t\\t\\tthis._upperBody.setBlendColor([21, 87, 255, 64]);\\t\\r\\n\\t\\t\\t\\t\\tthis._upperBodyOverlay.setBlendColor([21, 87, 255, 64]);\\t\\r\\n\\t\\t\\t\\t\\tthis._upperBodyTop.setBlendColor([21, 87, 255, 64]);\\t\\r\\n\\t\\t\\t\\t\\tthis._lowerBody.setBlendColor([21, 87, 255, 64]);\\r\\n\\t\\t\\t\\t\\tthis._lowerBodyOverlay.setBlendColor([21, 87, 255, 64]);\\r\\n\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tthis._upperBody.setBlendColor([0, 0, 0, 0]);\\t\\r\\n\\t\\t\\t\\t\\tthis._upperBodyOverlay.setBlendColor([0, 0, 0, 0]);\\t\\r\\n\\t\\t\\t\\t\\tthis._upperBodyTop.setBlendColor([0, 0, 0, 0]);\\r\\n\\t\\t\\t\\t\\tthis._lowerBody.setBlendColor([0, 0, 0, 0]);\\r\\n\\t\\t\\t\\t\\tthis._lowerBodyOverlay.setBlendColor([0, 0, 0, 0]);\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tthis._upperBody.setBlendColor([0, 0, 0, 128]);\\t\\r\\n\\t\\t\\t\\tthis._upperBodyOverlay.setBlendColor([0, 0, 0, 128]);\\t\\r\\n\\t\\t\\t\\tthis._upperBodyTop.setBlendColor([0, 0, 0, 128]);\\t\\r\\n\\t\\t\\t\\tthis._lowerBody.setBlendColor([0, 0, 0, 128]);\\r\\n\\t\\t\\t\\tthis._lowerBodyOverlay.setBlendColor([0, 0, 0, 128]);\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tthis.visible = false;\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t//hack to ensure there's no weird overlap issues when deploying an actor from a ship\\r\\n\\t\\t\\tif($gameTemp.activeShip && $gameTemp.activeShip.event.eventId() != this._character.eventId()){\\r\\n\\t\\t\\t\\tif(this._character.posX() == $gameTemp.activeShip.position.x && this._character.posY() == $gameTemp.activeShip.position.y){\\r\\n\\t\\t\\t\\t\\tthis.visible = true;\\r\\n\\t\\t\\t\\t\\tthis.setFrame(sx, sy, pw, ph);\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t}\\t\\t\\r\\n\\t\\t\\tthis.setFrame(sx, sy, pw, ph);\\r\\n\\t\\t\\t//this.visible = false;\\r\\n\\t\\t\\tif ($gameSystem.isSRPGMode() == true && this._character.isEvent() == true) {\\r\\n\\t\\t\\t\\tvar battlerArray = $gameSystem.EventToUnit(this._character.eventId());\\r\\n\\t\\t\\t\\tif (battlerArray) {\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tvar pw = this._turnEndBitmap.width / 12;\\r\\n\\t\\t\\t\\t\\tvar ph = this._turnEndBitmap.height / 8;\\r\\n\\t\\t\\t\\t\\tif ((battlerArray[0] === 'actor' || battlerArray[0] === 'enemy') &&\\r\\n\\t\\t\\t\\t\\t\\tbattlerArray[1].isAlive() && !this._character.isErased()) {\\r\\n\\t\\t\\t\\t\\t\\tif (battlerArray[1].isRestricted()) {\\r\\n\\t\\t\\t\\t\\t\\t\\tvar sx = (6 + this.characterPatternX()) * pw;\\r\\n\\t\\t\\t\\t\\t\\t\\tvar sy = (0 + this.characterPatternY()) * ph;\\r\\n\\t\\t\\t\\t\\t\\t\\tthis.createTurnEndSprites();\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._turnEndSprite.bitmap = this._turnEndBitmap;\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._turnEndSprite.visible = true;\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._turnEndSprite.setFrame(sx, sy, pw, ph);\\r\\n\\t\\t\\t\\t\\t\\t} else if (this.isTurnEndUnit() == true) {\\r\\n\\t\\t\\t\\t\\t\\t\\tvar sx = (3 + this.characterPatternX()) * pw;\\r\\n\\t\\t\\t\\t\\t\\t\\tvar sy = (0 + this.characterPatternY()) * ph;\\r\\n\\t\\t\\t\\t\\t\\t\\tthis.createTurnEndSprites();\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._turnEndSprite.bitmap = this._turnEndBitmap;\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._turnEndSprite.visible = true;\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._turnEndSprite.setFrame(sx, sy, pw, ph);\\r\\n\\t\\t\\t\\t\\t\\t} else if (battlerArray[1].isAutoBattle()) {\\r\\n\\t\\t\\t\\t\\t\\t\\tvar sx = (9 + this.characterPatternX()) * pw;\\r\\n\\t\\t\\t\\t\\t\\t\\tvar sy = (0 + this.characterPatternY()) * ph;\\r\\n\\t\\t\\t\\t\\t\\t\\tthis.createTurnEndSprites();\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._turnEndSprite.bitmap = this._turnEndBitmap;\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._turnEndSprite.visible = true;\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._turnEndSprite.setFrame(sx, sy, pw, ph);\\r\\n\\t\\t\\t\\t\\t\\t} else if (this._turnEndSprite) {\\r\\n\\t\\t\\t\\t\\t\\t\\tthis._turnEndSprite.visible = false;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t} else if (this._turnEndSprite) {\\r\\n\\t\\t\\t\\t\\t\\tthis._turnEndSprite.visible = false;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis.setFrame(sx, sy, pw, ph);\\r\\n\\t\\t}\\r\\n    };\\r\\n\\t\\r\\n\\r\\n    //ターン終了の表示を作る\\r\\n    Sprite_Character.prototype.createTurnEndSprites = function() {\\r\\n        if (!this._turnEndSprite) {\\r\\n            this._turnEndSprite = new Sprite();\\r\\n            this._turnEndSprite.anchor.x = 0.5;\\r\\n            this._turnEndSprite.anchor.y = 1;\\r\\n\\t\\t\\t\\t\\t\\t\\r\\n            this.addChild(this._turnEndSprite);\\r\\n        }\\r\\n    };\\t\\r\\n\\t\\r\\n\\t\\r\\n\\tSprite_Animation.prototype.updatePosition = function() {\\r\\n\\t\\tif (this._animation.position === 3) {\\r\\n\\t\\t\\tthis.x = this.parent.width / 2;\\r\\n\\t\\t\\tthis.y = this.parent.height / 2;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tvar parent = this._target.parent;\\r\\n\\t\\t\\tvar grandparent = parent ? parent.parent : null;\\r\\n\\t\\t\\tthis.x = this._target.x;\\r\\n\\t\\t\\tthis.y = this._target.y;\\r\\n\\t\\t\\tif (this.parent === grandparent) {\\r\\n\\t\\t\\t\\tthis.x += parent.x;\\r\\n\\t\\t\\t\\tthis.y += parent.y;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (this._animation.position === 0) {\\r\\n\\t\\t\\t\\tthis.y -= this._target.height;\\r\\n\\t\\t\\t} else if (this._animation.position === 1) {\\r\\n\\t\\t\\t\\tthis.y -= this._target.height / 2 - 0;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\r\\n//====================================================================\\r\\n// ●Sprite_SrpgMoveTile\\r\\n//====================================================================\\r\\n    function Sprite_SrpgMoveTile() {\\r\\n        this.initialize.apply(this, arguments);\\r\\n    }\\r\\n\\r\\n    Sprite_SrpgMoveTile.prototype = Object.create(Sprite.prototype);\\r\\n    Sprite_SrpgMoveTile.prototype.constructor = Sprite_SrpgMoveTile;\\r\\n\\r\\n    Sprite_SrpgMoveTile.prototype.initialize = function() {\\r\\n        Sprite.prototype.initialize.call(this);\\r\\n        this.createBitmap();\\r\\n        this._frameCount = 0;\\r\\n        this._posX = -1;\\r\\n        this._posY = -1;\\r\\n        this.visible = false;\\r\\n    };\\r\\n\\r\\n    Sprite_SrpgMoveTile.prototype.isThisMoveTileValid = function() {\\r\\n        return this._posX >= 0 && this._posY >= 0;\\r\\n    }\\r\\n\\r\\n    Sprite_SrpgMoveTile.prototype.setThisMoveTile = function(x, y, attackFlag) {\\r\\n        this._frameCount = 0;\\r\\n        this._posX = x;\\r\\n        this._posY = y;\\r\\n        if (attackFlag == true) {\\r\\n            this.bitmap.fillAll('red');\\r\\n        } else {\\r\\n            this.bitmap.fillAll('blue');\\r\\n        }\\r\\n    }\\r\\n\\r\\n    Sprite_SrpgMoveTile.prototype.clearThisMoveTile = function() {\\r\\n        this._frameCount = 0;\\r\\n        this._posX = -1;\\r\\n        this._posY = -1;\\r\\n    }\\r\\n\\r\\n    Sprite_SrpgMoveTile.prototype.update = function() {\\r\\n        Sprite.prototype.update.call(this);\\r\\n        if (this.isThisMoveTileValid()){\\r\\n            this.updatePosition();\\r\\n            this.updateAnimation();\\r\\n            this.visible = true;\\r\\n        } else {\\r\\n            this.visible = false;\\r\\n        }\\r\\n    };\\r\\n\\r\\n    Sprite_SrpgMoveTile.prototype.createBitmap = function() {\\r\\n        var tileWidth = $gameMap.tileWidth();\\r\\n        var tileHeight = $gameMap.tileHeight();\\r\\n        this.bitmap = new Bitmap(tileWidth, tileHeight);\\r\\n        this.anchor.x = 0.5;\\r\\n        this.anchor.y = 0.5;\\r\\n        this.blendMode = Graphics.BLEND_ADD;\\r\\n    };\\r\\n\\r\\n    Sprite_SrpgMoveTile.prototype.updatePosition = function() {\\r\\n        var tileWidth = $gameMap.tileWidth();\\r\\n        var tileHeight = $gameMap.tileHeight();\\r\\n        this.x = ($gameMap.adjustX(this._posX) + 0.5) * tileWidth;\\r\\n        this.y = ($gameMap.adjustY(this._posY) + 0.5) * tileHeight;\\r\\n    };\\r\\n\\r\\n    Sprite_SrpgMoveTile.prototype.updateAnimation = function() {\\r\\n       /* this._frameCount++;\\r\\n        this._frameCount %= 40;\\r\\n        this.opacity = (40 - this._frameCount) * 3;*/\\r\\n    };\\r\\n\\t\\r\\n//====================================================================\\r\\n// ●Sprite_MapEffect\\r\\n//====================================================================\\t\\r\\n\\t\\r\\n\\tfunction Sprite_MapEffect() {\\r\\n\\t\\tthis.initialize.apply(this, arguments);\\r\\n\\t}\\r\\n\\r\\n\\tSprite_MapEffect.prototype = Object.create(Sprite_Base.prototype);\\r\\n\\tSprite_MapEffect.prototype.constructor = Sprite_MapEffect;\\r\\n\\r\\n\\tSprite_MapEffect.prototype.initialize = function(spriteInfo, position) {\\r\\n\\t\\tSprite_Base.prototype.initialize.call(this);\\t\\t\\r\\n\\t\\tthis.bitmap =  ImageManager.loadNormalBitmap('img/SRWMapEffects/'+spriteInfo.name+\\\".png\\\");\\r\\n\\t\\tthis.anchor.x = 0.5;\\r\\n\\t\\tthis.anchor.y = 0.5;\\r\\n\\t\\tthis._animationFrame = 0;\\r\\n\\t\\tthis.visible = false;\\r\\n\\t\\tthis._frameSize = spriteInfo.frameSize;\\r\\n\\t\\tthis._sheetHeight = spriteInfo.sheetHeight;\\r\\n\\t\\tthis._sheetWidth = spriteInfo.sheetWidth;\\r\\n\\t\\tthis._frames = spriteInfo.frames;\\r\\n\\t\\tthis._frameCounter = 0;\\r\\n\\t\\tthis._animationSpeed = spriteInfo.animationSpeed || 2;\\r\\n\\t\\tthis._position = position;\\r\\n\\t\\tthis._positionOffset = spriteInfo.offset || {x: 0, y: 0}\\r\\n\\t\\tthis.setFrame(0 * this._frameSize, 0 * this._frameSize, this._frameSize, this._frameSize);\\r\\n\\t};\\r\\n\\t\\r\\n\\tSprite_MapEffect.prototype.updatePosition = function() {\\r\\n\\t\\tthis.x = this._position.x + this._positionOffset.x;\\r\\n\\t\\tthis.y = this._position.y + this._positionOffset.y;\\r\\n\\t\\tthis.z = 999;\\r\\n\\t}\\r\\n\\t\\r\\n\\tSprite_MapEffect.prototype.update = function() {\\t\\r\\n\\t\\tthis.updatePosition();\\r\\n\\t\\tif(this._animationFrame > this._frames){\\r\\n\\t\\t\\tthis.visible = false;\\r\\n\\t\\t\\tthis.parent.removeChild(this);\\r\\n\\t\\t} else {\\t\\t\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\tthis.visible = true;\\r\\n\\t\\t\\tvar col = this._animationFrame % this._sheetWidth;\\r\\n\\t\\t\\tvar row = Math.floor(this._animationFrame / this._sheetWidth);\\r\\n\\t\\t\\tthis.setFrame(col * this._frameSize, row * this._frameSize, this._frameSize, this._frameSize);\\r\\n\\t\\t\\tthis._frameCounter++;\\r\\n\\t\\t\\tif(this._frameCounter >= this._animationSpeed){\\r\\n\\t\\t\\t\\tthis._animationFrame++;\\r\\n\\t\\t\\t\\tthis._frameCounter = 0;\\r\\n\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t}\\t\\t\\t\\r\\n\\t};\\t\\r\\n\\t\\r\\n\\tfunction Sprite_MapAttack() {\\r\\n\\t\\tthis.initialize.apply(this, arguments);\\r\\n\\t}\\r\\n\\r\\n\\tSprite_MapAttack.prototype = Object.create(Sprite_MapEffect.prototype);\\r\\n\\tSprite_MapAttack.prototype.constructor = Sprite_MapAttack;\\r\\n\\t\\r\\n\\tSprite_MapAttack.prototype.updatePosition = function() {\\r\\n\\t\\tthis.scale.x = 1;\\r\\n\\t\\tthis.scale.y = 1;\\t\\t\\r\\n\\t\\tvar offset = JSON.parse(JSON.stringify(this._positionOffset));\\r\\n\\t\\tif($gameTemp.mapTargetDirection == \\\"left\\\"){\\r\\n\\t\\t\\toffset.x*= -1;\\r\\n\\t\\t\\tthis.scale.x = -1;\\t\\r\\n\\t\\t}\\r\\n\\t\\tif($gameTemp.mapTargetDirection == \\\"up\\\" || $gameTemp.mapTargetDirection == \\\"down\\\"){\\r\\n\\t\\t\\tvar tmp = offset.x;\\r\\n\\t\\t\\toffset.x = offset.y;\\r\\n\\t\\t\\toffset.y = tmp;\\r\\n\\t\\t\\tthis.scale.y = -1;\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\tif($gameTemp.mapTargetDirection == \\\"up\\\"){\\r\\n\\t\\t\\toffset.y*= -1;\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\tthis.x = this._position.x + offset.x;\\r\\n\\t\\tthis.y = this._position.y + offset.y;\\r\\n\\t\\tthis.z = 999;\\r\\n\\t}\\r\\n\\t\\r\\n//====================================================================\\r\\n// ●Sprite_WillIndicator\\r\\n//====================================================================\\t\\r\\n\\t\\r\\n\\tfunction Sprite_WillIndicator() {\\r\\n\\t\\tthis.initialize.apply(this, arguments);\\r\\n\\t}\\r\\n\\r\\n\\tSprite_WillIndicator.prototype = Object.create(Sprite_Base.prototype);\\r\\n\\tSprite_WillIndicator.prototype.constructor = Sprite_WillIndicator;\\r\\n\\r\\n\\tSprite_WillIndicator.prototype.initialize = function(character) {\\r\\n\\t\\tSprite_Base.prototype.initialize.call(this);\\r\\n\\t\\tthis._character = character;\\t\\t\\r\\n\\t\\tthis.text = new PIXI.Text('',\\r\\n\\t\\t{\\r\\n\\t\\t  fontFamily : 'Arial',\\r\\n\\t\\t  fontSize: \\\"13px\\\",\\r\\n\\t\\t  fill : 0xffffff,\\r\\n\\t\\t  cacheAsBitmap: true, // for better performance\\r\\n\\t\\t  height: 30,\\r\\n\\t\\t  width: 20,\\r\\n\\t\\t});\\r\\n\\t\\tthis.addChild(this.text);\\r\\n\\t\\tthis._previousEventType = -1;\\r\\n\\t};\\r\\n\\r\\n\\tSprite_WillIndicator.prototype.update = function() {\\r\\n\\t\\tvar type = this._character.isType();\\r\\n\\t\\tthis._isEnemy = type === 'enemy'\\r\\n\\t\\tif(this._previousEventType != type){\\r\\n\\t\\t\\tthis._previousEventType = type;\\r\\n\\t\\t\\tif(this._isEnemy){\\r\\n\\t\\t\\t\\tthis.bitmap = ImageManager.loadSystem('WillIndicatorEnemy');\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tthis.bitmap = ImageManager.loadSystem('WillIndicator');\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tthis.anchor.x = 0.5;\\r\\n\\t\\tthis.anchor.y = 1;\\r\\n\\t\\t\\r\\n\\t\\t \\r\\n\\t\\tif(this._isEnemy){\\r\\n\\t\\t\\tthis.text.anchor.set(0); \\r\\n\\t\\t\\tthis.text.x = -23; \\r\\n\\t\\t\\tthis.text.y = -49.5\\t;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis.text.anchor.set(1); \\r\\n\\t\\t\\tthis.text.x = 23; \\r\\n\\t\\t\\tthis.text.y = -33.5\\t;\\r\\n\\t\\t}\\t\\r\\n\\t\\t\\r\\n\\t\\tthis.x = this._character.screenX();\\r\\n\\t\\tthis.y = this._character.screenY();\\r\\n\\t\\t//this.z = this._character.screenZ() - 1;\\r\\n\\t\\tvar eventId = this._character.eventId();\\r\\n\\t\\tvar battlerArray = $gameSystem.EventToUnit(eventId);\\r\\n\\t\\tif($gameSystem.showWillIndicator && battlerArray){\\r\\n\\t\\t\\tvar unit = battlerArray[1];\\r\\n\\t\\t\\tif(unit && !this._character.isErased()){\\r\\n\\t\\t\\t\\tthis.opacity = 255;\\r\\n\\t\\t\\t\\tvar maxWill = $statCalc.getMaxWill(unit);\\r\\n\\t\\t\\t\\tvar will = $statCalc.getCurrentWill(unit);\\r\\n\\t\\t\\t\\t//this.drawText(will, 0, 0, 20);\\r\\n\\t\\t\\t\\tthis.text.text = will;\\r\\n\\t\\t\\t\\tvar color = \\\"#ffffff\\\";\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tif(will < 100){\\r\\n\\t\\t\\t\\t\\tcolor = \\\"#f1de55\\\";\\r\\n\\t\\t\\t\\t} \\r\\n\\t\\t\\t\\tif(will <= 50){\\r\\n\\t\\t\\t\\t\\tcolor = \\\"#ff2222\\\";\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(will == maxWill){\\r\\n\\t\\t\\t\\t\\tcolor = \\\"#00f1ff\\\";\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tthis.text.style.fill = color;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tthis.opacity = 0;\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis.opacity = 0;\\r\\n\\t\\t}\\t\\t\\r\\n\\t};\\r\\n\\t\\r\\n//====================================================================\\r\\n// ●Sprite_BasicShadow\\r\\n//====================================================================\\t\\r\\n\\t\\r\\n\\tfunction Sprite_BasicShadow() {\\r\\n\\t\\tthis.initialize.apply(this, arguments);\\r\\n\\t}\\r\\n\\r\\n\\tSprite_BasicShadow.prototype = Object.create(Sprite_Base.prototype);\\r\\n\\tSprite_BasicShadow.prototype.constructor = Sprite_BasicShadow;\\r\\n\\r\\n\\tSprite_BasicShadow.prototype.initialize = function(character) {\\r\\n\\t\\tSprite_Base.prototype.initialize.call(this);\\r\\n\\t\\tthis._character = character;\\r\\n\\t\\tthis.bitmap =  ImageManager.loadPicture('flight_shadow');\\r\\n\\t\\tthis.anchor.x = 0.5;\\r\\n\\t\\tthis.anchor.y = 1;\\r\\n\\t};\\r\\n\\r\\n\\tSprite_BasicShadow.prototype.update = function() {\\r\\n\\t\\tthis.x = this._character.screenX();\\r\\n\\t\\tthis.y = this._character.screenY();\\r\\n\\t\\t//this.z = this._character.screenZ() - 1;\\r\\n\\t\\tvar eventId = this._character.eventId();\\r\\n\\t\\tvar battlerArray = $gameSystem.EventToUnit(eventId);\\r\\n\\t\\tif(battlerArray){\\r\\n\\t\\t\\tif (this._character._characterName == \\\"\\\" || this._character._transparent || !$statCalc.isFlying(battlerArray[1])) {\\r\\n\\t\\t\\t\\tthis.opacity = 0;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tthis.y-=this._character._floatOffset;\\r\\n\\t\\t\\t\\tthis.opacity = this._character._opacity - 128;\\r\\n\\t\\t\\t};\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis.opacity = 0;\\r\\n\\t\\t}\\t\\t\\r\\n\\t};\\r\\n\\r\\n//====================================================================\\r\\n// ●Sprite_DefendIndicator\\r\\n//====================================================================\\t\\r\\n\\t\\r\\n\\tfunction Sprite_DefendIndicator() {\\r\\n\\t\\tthis.initialize.apply(this, arguments);\\r\\n\\t}\\r\\n\\r\\n\\tSprite_DefendIndicator.prototype = Object.create(Sprite_Base.prototype);\\r\\n\\tSprite_DefendIndicator.prototype.constructor = Sprite_DefendIndicator;\\r\\n\\r\\n\\tSprite_DefendIndicator.prototype.initialize = function(character) {\\r\\n\\t\\tSprite_Base.prototype.initialize.call(this);\\r\\n\\t\\tthis._character = character;\\r\\n\\t\\tthis.bitmap =  ImageManager.loadSystem('shield');\\r\\n\\t\\tthis.anchor.x = 0.5;\\r\\n\\t\\tthis.anchor.y = 1;\\r\\n\\t\\tthis._frameCount = 0;\\r\\n\\t};\\r\\n\\r\\n\\tSprite_DefendIndicator.prototype.update = function() {\\r\\n\\t\\tthis.x = this._character.screenX();\\r\\n\\t\\t\\r\\n\\t\\tthis.y = this._character.screenY() - 2;\\r\\n\\t\\t//this.z = this._character.screenZ() - 1;\\r\\n\\t\\tvar eventId = this._character.eventId();\\r\\n\\t\\tvar battlerArray = $gameSystem.EventToUnit(eventId);\\r\\n\\t\\t\\r\\n\\t\\tif(battlerArray){\\r\\n\\t\\t\\tvar unit = battlerArray[1];\\r\\n\\t\\t\\tvar isShown = true;\\r\\n\\t\\t\\tif(!$gameSystem.isEnemy(unit)){\\r\\n\\t\\t\\t\\tif(!$gameTemp.showAllyDefendIndicator){\\r\\n\\t\\t\\t\\t\\tisShown = false;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tthis.x = this._character.screenX() + 15;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tif(!$gameTemp.showEnemyDefendIndicator){\\r\\n\\t\\t\\t\\t\\tisShown = false;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tthis.x = this._character.screenX() - 15;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif($gameSystem.isBattlePhase() === 'AI_phase' || $gameSystem.isSubBattlePhase() === 'actor_target'){\\r\\n\\t\\t\\t\\tvar activeEvent = $gameTemp.activeEvent();\\r\\n\\t\\t\\t\\tif(activeEvent){\\r\\n\\t\\t\\t\\t\\tvar actor = $gameSystem.EventToUnit(activeEvent.eventId())[1];\\r\\n\\t\\t\\t\\t\\tif($gameSystem.isFriendly(actor, $gameSystem.getFactionId(unit))){\\r\\n\\t\\t\\t\\t\\t\\tif(!actor || !$statCalc.canSupportDefend(actor, unit)){\\r\\n\\t\\t\\t\\t\\t\\t\\tisShown = false;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\tif(!$statCalc.hasSupportDefend(unit)){\\r\\n\\t\\t\\t\\t\\t\\t\\tisShown = false;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tisShown = false;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tif($gameTemp.summaryUnit && !$statCalc.canSupportDefend($gameTemp.summaryUnit, unit)){\\r\\n\\t\\t\\t\\t\\tisShown = false;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(isShown && unit && !this._character.isErased()){\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t\\tthis._frameCount+=2;\\r\\n\\t\\t\\t\\tthis._frameCount %= 200;\\r\\n\\t\\t\\t\\tif(this._frameCount < 100){\\r\\n\\t\\t\\t\\t\\tthis.opacity = this._frameCount + 120;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tthis.opacity = 200 + 120 - this._frameCount;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tthis.opacity = 0;\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis.opacity = 0;\\r\\n\\t\\t}\\t\\t\\r\\n\\t};\\r\\n\\t\\r\\n//====================================================================\\r\\n// ●Sprite_AttackIndicator\\r\\n//====================================================================\\t\\r\\n\\t\\r\\n\\tfunction Sprite_AttackIndicator() {\\r\\n\\t\\tthis.initialize.apply(this, arguments);\\r\\n\\t}\\r\\n\\r\\n\\tSprite_AttackIndicator.prototype = Object.create(Sprite_Base.prototype);\\r\\n\\tSprite_AttackIndicator.prototype.constructor = Sprite_AttackIndicator;\\r\\n\\r\\n\\tSprite_AttackIndicator.prototype.initialize = function(character) {\\r\\n\\t\\tSprite_Base.prototype.initialize.call(this);\\r\\n\\t\\tthis._character = character;\\r\\n\\t\\tthis.bitmap =  ImageManager.loadSystem('sword');\\r\\n\\t\\tthis.anchor.x = 0.5;\\r\\n\\t\\tthis.anchor.y = 1;\\r\\n\\t\\tthis._frameCount = 0;\\r\\n\\t};\\r\\n\\r\\n\\tSprite_AttackIndicator.prototype.update = function() {\\r\\n\\t\\tthis.x = this._character.screenX();\\r\\n\\t\\t\\r\\n\\t\\tthis.y = this._character.screenY() - 2;\\r\\n\\t\\t//this.z = this._character.screenZ() - 1;\\r\\n\\t\\tvar eventId = this._character.eventId();\\r\\n\\t\\tvar battlerArray = $gameSystem.EventToUnit(eventId);\\r\\n\\t\\t\\r\\n\\t\\tif(battlerArray){\\r\\n\\t\\t\\tvar unit = battlerArray[1];\\r\\n\\t\\t\\tvar isShown = true;\\r\\n\\t\\t\\tif(!$gameSystem.isEnemy(unit)){\\r\\n\\t\\t\\t\\tif(!$gameTemp.showAllyAttackIndicator){\\r\\n\\t\\t\\t\\t\\tisShown = false;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tthis.x = this._character.screenX() - 15;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tif(!$gameTemp.showEnemyAttackIndicator){\\r\\n\\t\\t\\t\\t\\tisShown = false;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tthis.x = this._character.screenX() + 15;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif($gameSystem.isBattlePhase() === 'AI_phase' || $gameSystem.isSubBattlePhase() === 'actor_target'){\\r\\n\\t\\t\\t\\tvar activeEvent = $gameTemp.activeEvent();\\r\\n\\t\\t\\t\\tif(activeEvent){\\r\\n\\t\\t\\t\\t\\tvar actor = $gameSystem.EventToUnit(activeEvent.eventId())[1];\\r\\n\\t\\t\\t\\t\\tif($gameSystem.isFriendly(actor, $gameSystem.getFactionId(unit))){\\r\\n\\t\\t\\t\\t\\t\\tif(!actor || !$statCalc.canSupportAttack(actor, unit)){\\r\\n\\t\\t\\t\\t\\t\\t\\tisShown = false;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\tif(!$statCalc.hasSupportAttack(unit)){\\r\\n\\t\\t\\t\\t\\t\\t\\tisShown = false;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tisShown = false;\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tif(!$gameTemp.summaryUnit || !$statCalc.canSupportAttack($gameTemp.summaryUnit, unit)){\\r\\n\\t\\t\\t\\t\\tisShown = false;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif(isShown && unit && !this._character.isErased()){\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t\\tthis._frameCount+=2;\\r\\n\\t\\t\\t\\tthis._frameCount %= 200;\\r\\n\\t\\t\\t\\tif(this._frameCount < 100){\\r\\n\\t\\t\\t\\t\\tthis.opacity = this._frameCount + 120;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tthis.opacity = 200 + 120 - this._frameCount;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tthis.opacity = 0;\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis.opacity = 0;\\r\\n\\t\\t}\\t\\t\\r\\n\\t};\\t\\r\\n\\t\\r\\n//====================================================================\\r\\n// ●Sprite_TwinIndicator\\r\\n//====================================================================\\t\\r\\n\\t\\r\\n\\tfunction Sprite_TwinIndicator() {\\r\\n\\t\\tthis.initialize.apply(this, arguments);\\r\\n\\t}\\r\\n\\r\\n\\tSprite_TwinIndicator.prototype = Object.create(Sprite_Base.prototype);\\r\\n\\tSprite_TwinIndicator.prototype.constructor = Sprite_TwinIndicator;\\r\\n\\r\\n\\tSprite_TwinIndicator.prototype.initialize = function(character) {\\r\\n\\t\\tSprite_Base.prototype.initialize.call(this);\\r\\n\\t\\tthis._character = character;\\r\\n\\t\\tthis.bitmap =  ImageManager.loadSystem('twin');\\r\\n\\t\\tthis.anchor.x = 0.5;\\r\\n\\t\\tthis.anchor.y = 1;\\r\\n\\t\\tthis._frameCount = 0;\\r\\n\\t};\\r\\n\\r\\n\\tSprite_TwinIndicator.prototype.update = function() {\\r\\n\\t\\tthis.x = this._character.screenX();\\r\\n\\t\\t\\r\\n\\t\\tthis.y = this._character.screenY() - 30;\\r\\n\\t\\t//this.z = this._character.screenZ() - 1;\\r\\n\\t\\tvar eventId = this._character.eventId();\\r\\n\\t\\tvar battlerArray = $gameSystem.EventToUnit(eventId);\\r\\n\\t\\t\\r\\n\\t\\tif(battlerArray){\\r\\n\\t\\t\\tvar unit = battlerArray[1];\\r\\n\\t\\t\\tif(!$gameSystem.isEnemy(unit)){\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tthis.x = this._character.screenX() - 15;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tthis.x = this._character.screenX() + 15;\\r\\n\\t\\t\\t}\\t\\t\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif($statCalc.isMainTwin(unit) && unit && !this._character.isErased()){\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t\\t/*this._frameCount+=2;\\r\\n\\t\\t\\t\\tthis._frameCount %= 200;\\r\\n\\t\\t\\t\\tif(this._frameCount < 100){\\r\\n\\t\\t\\t\\t\\tthis.opacity = this._frameCount + 120;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tthis.opacity = 200 + 120 - this._frameCount;\\r\\n\\t\\t\\t\\t}*/\\r\\n\\t\\t\\t\\tthis.opacity = 255;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tthis.opacity = 0;\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis.opacity = 0;\\r\\n\\t\\t}\\t\\t\\r\\n\\t};\\t\\r\\n\\t\\t\\r\\n\\t\\r\\n//====================================================================\\r\\n// Sprite_Destroyed\\r\\n//====================================================================\\t\\r\\n\\t\\r\\n\\tfunction Sprite_Destroyed() {\\r\\n\\t\\tthis.initialize.apply(this, arguments);\\r\\n\\t}\\r\\n\\r\\n\\tSprite_Destroyed.prototype = Object.create(Sprite_Base.prototype);\\r\\n\\tSprite_Destroyed.prototype.constructor = Sprite_Destroyed;\\r\\n\\r\\n\\tSprite_Destroyed.prototype.initialize = function(character) {\\r\\n\\t\\tSprite_Base.prototype.initialize.call(this);\\t\\t\\r\\n\\t\\tthis.bitmap =  ImageManager.loadAnimation('Explosion1');\\r\\n\\t\\tthis._character = character;\\r\\n\\t\\tthis.anchor.x = 0.5;\\r\\n\\t\\tthis.anchor.y = 0.6;\\r\\n\\t\\tthis._animationFrame = 0;\\r\\n\\t\\tthis.visible = false;\\r\\n\\t\\tthis._frameSize = 192;\\r\\n\\t\\tthis._sheetHeight = 3;\\r\\n\\t\\tthis._sheetWidth = 5;\\r\\n\\t\\tthis._frames = 11;\\r\\n\\t\\tthis._frameCounter = 0;\\r\\n\\t\\tthis._animationSpeed = 2;\\r\\n\\t\\tthis.setFrame(0 * this._frameSize, 0 * this._frameSize, this._frameSize, this._frameSize);\\r\\n\\t};\\r\\n\\t\\r\\n\\tSprite_Destroyed.prototype.setCharacter = function(character){\\r\\n\\t\\tthis._character = character;\\r\\n\\t}\\r\\n\\r\\n\\tSprite_Destroyed.prototype.update = function() {\\r\\n\\t\\tif(this._character.manuallyErased){\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\tif(this._animationFrame > this._frames){\\r\\n\\t\\t\\tthis.visible = false;\\r\\n\\t\\t\\tthis._character.isDoingDeathAnim = false;\\r\\n\\t\\t\\tthis._processedDeath = false;\\r\\n\\t\\t\\tthis._animationFrame = 0;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tvar eventId = this._character.eventId();\\r\\n\\t\\t\\tvar battlerArray = $gameSystem.EventToUnit(eventId);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif(this._animationFrame == 3 && !this._processedDeath){\\r\\n\\t\\t\\t\\tthis._processedDeath = true;\\r\\n\\t\\t\\t\\tif(this._character.isDoingSubTwinDeath){\\r\\n\\t\\t\\t\\t\\t$statCalc.swapEvent(this._character, true);\\r\\n\\t\\t\\t\\t\\t//_this._currentDeath.event.appear();\\r\\n\\t\\t\\t\\t\\t//this._character.refreshImage();\\r\\n\\t\\t\\t\\t\\t$statCalc.getMainTwin(battlerArray[1]).subTwin = null;\\r\\n\\t\\t\\t\\t} else if(this._character.isDoingMainTwinDeath){\\t\\r\\n\\t\\t\\t\\t\\t$statCalc.swapEvent(this._character, true);\\r\\n\\t\\t\\t\\t\\t$statCalc.getMainTwin(battlerArray[1]).subTwin = null;\\r\\n\\t\\t\\t\\t\\t//battlerArray[1].subTwin.isSubTwin = false;\\r\\n\\t\\t\\t\\t\\t//battlerArray[1].subTwin = null;\\r\\n\\t\\t\\t\\t} else {\\t\\r\\n\\t\\t\\t\\t\\tthis._character.erase();\\t\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\tthis.x = this._character.screenX();\\r\\n\\t\\t\\tthis.y = this._character.screenY();\\r\\n\\t\\t\\tthis.z = this._character.screenZ() + 1;\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif(battlerArray && battlerArray[1]){\\r\\n\\t\\t\\t\\tif (this._character.isDoingDeathAnim) {\\r\\n\\t\\t\\t\\t\\tif(this._animationFrame == 1){\\r\\n\\t\\t\\t\\t\\t\\tvar se = {};\\r\\n\\t\\t\\t\\t\\t\\tse.name = 'SRWExplosion';\\r\\n\\t\\t\\t\\t\\t\\tse.pan = 0;\\r\\n\\t\\t\\t\\t\\t\\tse.pitch = 100;\\r\\n\\t\\t\\t\\t\\t\\tse.volume = 80;\\r\\n\\t\\t\\t\\t\\t\\tAudioManager.playSe(se);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tthis.visible = true;\\r\\n\\t\\t\\t\\t\\tvar col = this._animationFrame % this._sheetWidth;\\r\\n\\t\\t\\t\\t\\tvar row = Math.floor(this._animationFrame / this._sheetWidth);\\r\\n\\t\\t\\t\\t\\tthis.setFrame(col * this._frameSize, row * this._frameSize, this._frameSize, this._frameSize);\\r\\n\\t\\t\\t\\t\\tthis._frameCounter++;\\r\\n\\t\\t\\t\\t\\tif(this._frameCounter >= this._animationSpeed){\\r\\n\\t\\t\\t\\t\\t\\tthis._animationFrame++;\\r\\n\\t\\t\\t\\t\\t\\tthis._frameCounter = 0;\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t} \\r\\n\\t\\t\\t}\\t\\r\\n\\t\\t}\\t\\t\\t\\r\\n\\t};\\t\\r\\n\\t\\r\\n//====================================================================\\r\\n// Sprite_Appear\\r\\n//====================================================================\\t\\r\\n\\t\\r\\n\\tfunction Sprite_Appear() {\\r\\n\\t\\tthis.initialize.apply(this, arguments);\\r\\n\\t}\\r\\n\\r\\n\\tSprite_Appear.prototype = Object.create(Sprite_Base.prototype);\\r\\n\\tSprite_Appear.prototype.constructor = Sprite_Appear;\\r\\n\\r\\n\\tSprite_Appear.prototype.initialize = function(character) {\\r\\n\\t\\tSprite_Base.prototype.initialize.call(this);\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tthis._character = character;\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tthis._initialized = false;\\r\\n\\t\\t\\r\\n\\t\\tthis.anchor.x = 0.5;\\r\\n\\t\\tthis.anchor.y = 0.6;\\r\\n\\t\\tthis._animationFrame = 0;\\r\\n\\t\\tthis.visible = false;\\r\\n\\t\\t\\r\\n\\t\\tthis._sheetHeight = 3;\\r\\n\\t\\t\\r\\n\\t\\tthis._frameCounter = 0;\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tthis.setFrame(0 * this._frameSize, 0 * this._frameSize, this._frameSize, this._frameSize);\\r\\n\\t};\\r\\n\\t\\r\\n\\tSprite_Appear.prototype.setCharacter = function(character){\\r\\n\\t\\tthis._character = character;\\r\\n\\t}\\r\\n\\t\\r\\n\\tSprite_Appear.prototype.erase = function() {\\r\\n\\t\\tthis._initialized = false;\\r\\n\\t\\tthis._erased = true;\\r\\n\\t\\tthis.refresh();\\r\\n\\t};\\r\\n\\r\\n\\tSprite_Appear.prototype.update = function() {\\r\\n\\t\\tvar eventId = this._character.eventId();\\r\\n\\t\\tvar battlerArray = $gameSystem.EventToUnit(eventId);\\r\\n\\t\\tif(!this._initialized && battlerArray && battlerArray[1]){\\r\\n\\t\\t\\tthis._initialized = true;\\r\\n\\t\\t\\tvar animInfo = $statCalc.getSpawnAnimInfo(battlerArray[1]);\\r\\n\\t\\t\\tthis.bitmap =  ImageManager.loadAnimation(animInfo.name);\\r\\n\\t\\t\\tthis._frameSize = animInfo.frameSize;\\r\\n\\t\\t\\tthis._sheetWidth = animInfo.sheetWidth;\\r\\n\\t\\t\\tthis._frames = animInfo.frames;\\r\\n\\t\\t\\tthis._animationSpeed = animInfo.speed;\\r\\n\\t\\t\\tthis._appearFrame = animInfo.appearFrame;\\r\\n\\t\\t\\tthis._se = animInfo.se;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tif(this._animationFrame > this._frames){\\r\\n\\t\\t\\tthis.visible = false;\\r\\n\\t\\t\\tthis._character.isDoingAppearAnim = false;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif(this._animationFrame == this._appearFrame){\\r\\n\\t\\t\\t\\tthis._character.appear();\\r\\n\\t\\t\\t\\tthis._character.refreshImage();\\r\\n\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\tthis.x = this._character.screenX();\\r\\n\\t\\t\\tthis.y = this._character.screenY();\\r\\n\\t\\t\\tthis.z = this._character.screenZ() + 1;\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif(battlerArray && battlerArray[1]){\\r\\n\\t\\t\\t\\tif (this._character.isDoingAppearAnim) {\\r\\n\\t\\t\\t\\t\\tif(this._animationFrame == 0){\\r\\n\\t\\t\\t\\t\\t\\tvar se = {};\\r\\n\\t\\t\\t\\t\\t\\tse.name = this._se;\\r\\n\\t\\t\\t\\t\\t\\tse.pan = 0;\\r\\n\\t\\t\\t\\t\\t\\tse.pitch = 100;\\r\\n\\t\\t\\t\\t\\t\\tse.volume = 60;\\r\\n\\t\\t\\t\\t\\t\\tAudioManager.playSe(se);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tthis.visible = true;\\r\\n\\t\\t\\t\\t\\tvar col = this._animationFrame % this._sheetWidth;\\r\\n\\t\\t\\t\\t\\tvar row = Math.floor(this._animationFrame / this._sheetWidth);\\r\\n\\t\\t\\t\\t\\tthis.setFrame(col * this._frameSize, row * this._frameSize, this._frameSize, this._frameSize);\\r\\n\\t\\t\\t\\t\\tthis._frameCounter++;\\r\\n\\t\\t\\t\\t\\tif(this._frameCounter >= this._animationSpeed){\\r\\n\\t\\t\\t\\t\\t\\tthis._animationFrame++;\\r\\n\\t\\t\\t\\t\\t\\tthis._frameCounter = 0;\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t} \\r\\n\\t\\t\\t}\\t\\r\\n\\t\\t}\\t\\t\\t\\r\\n\\t};\\t\\r\\n\\r\\n//====================================================================\\r\\n// Sprite_Disappear\\r\\n//====================================================================\\t\\r\\n\\t\\r\\n\\tfunction Sprite_Disappear() {\\r\\n\\t\\tthis.initialize.apply(this, arguments);\\r\\n\\t}\\r\\n\\r\\n\\tSprite_Disappear.prototype = Object.create(Sprite_Base.prototype);\\r\\n\\tSprite_Disappear.prototype.constructor = Sprite_Disappear;\\r\\n\\r\\n\\tSprite_Disappear.prototype.initialize = function(character) {\\r\\n\\t\\tSprite_Base.prototype.initialize.call(this);\\t\\t\\r\\n\\t\\tthis.bitmap =  ImageManager.loadAnimation('SRWDisappear');\\r\\n\\t\\tthis._character = character;\\r\\n\\t\\tthis.anchor.x = 0.5;\\r\\n\\t\\tthis.anchor.y = 0.6;\\r\\n\\t\\tthis._animationFrame = 0;\\r\\n\\t\\tthis.visible = false;\\r\\n\\t\\tthis._frameSize = 192;\\r\\n\\t\\tthis._sheetHeight = 3;\\r\\n\\t\\tthis._sheetWidth = 5;\\r\\n\\t\\tthis._frames = 8;\\r\\n\\t\\tthis._frameCounter = 0;\\r\\n\\t\\tthis._animationSpeed = 2;\\r\\n\\t\\tthis.setFrame(0 * this._frameSize, 0 * this._frameSize, this._frameSize, this._frameSize);\\r\\n\\t};\\r\\n\\t\\r\\n\\tSprite_Disappear.prototype.setCharacter = function(character){\\r\\n\\t\\tthis._character = character;\\r\\n\\t}\\r\\n\\r\\n\\tSprite_Disappear.prototype.update = function() {\\r\\n\\t\\tif(this._animationFrame > this._frames){\\r\\n\\t\\t\\tthis.visible = false;\\r\\n\\t\\t\\tthis._character.isDoingDisappearAnim = false;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif(this._animationFrame == 3){\\r\\n\\t\\t\\t\\tthis._character.erase();\\r\\n\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\tthis.x = this._character.screenX();\\r\\n\\t\\t\\tthis.y = this._character.screenY();\\r\\n\\t\\t\\tthis.z = this._character.screenZ() + 1;\\r\\n\\t\\t\\tvar eventId = this._character.eventId();\\r\\n\\t\\t\\tvar battlerArray = $gameSystem.EventToUnit(eventId);\\r\\n\\t\\t\\tif(battlerArray && battlerArray[1]){\\r\\n\\t\\t\\t\\tif (this._character.isDoingDisappearAnim) {\\r\\n\\t\\t\\t\\t\\tif(this._animationFrame == 0){\\r\\n\\t\\t\\t\\t\\t\\tvar se = {};\\r\\n\\t\\t\\t\\t\\t\\tse.name = 'SRWDisappear';\\r\\n\\t\\t\\t\\t\\t\\tse.pan = 0;\\r\\n\\t\\t\\t\\t\\t\\tse.pitch = 100;\\r\\n\\t\\t\\t\\t\\t\\tse.volume = 60;\\r\\n\\t\\t\\t\\t\\t\\tAudioManager.playSe(se);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tthis.visible = true;\\r\\n\\t\\t\\t\\t\\tvar col = this._animationFrame % this._sheetWidth;\\r\\n\\t\\t\\t\\t\\tvar row = Math.floor(this._animationFrame / this._sheetWidth);\\r\\n\\t\\t\\t\\t\\tthis.setFrame(col * this._frameSize, row * this._frameSize, this._frameSize, this._frameSize);\\r\\n\\t\\t\\t\\t\\tthis._frameCounter++;\\r\\n\\t\\t\\t\\t\\tif(this._frameCounter >= this._animationSpeed){\\r\\n\\t\\t\\t\\t\\t\\tthis._animationFrame++;\\r\\n\\t\\t\\t\\t\\t\\tthis._frameCounter = 0;\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t} \\r\\n\\t\\t\\t}\\t\\r\\n\\t\\t}\\t\\t\\t\\r\\n\\t};\\t\\t\\r\\n\\t\\r\\n\\t\\r\\n//====================================================================\\r\\n// Sprite_SrpgGrid\\r\\n//====================================================================\\t\\r\\n\\t\\r\\n\\tfunction Sprite_Reticule() {\\r\\n\\t\\tthis.initialize.apply(this, arguments);\\r\\n\\t}\\r\\n\\r\\n\\tSprite_Reticule.prototype = Object.create(Sprite_Base.prototype);\\r\\n\\tSprite_Reticule.prototype.constructor = Sprite_Reticule;\\r\\n\\r\\n\\tSprite_Reticule.prototype.initialize = function() {\\r\\n\\t\\tSprite_Base.prototype.initialize.call(this);\\r\\n\\t\\tthis.bitmap =  ImageManager.loadPicture('reticule');\\r\\n\\t\\tthis.anchor.x = 0.5;\\r\\n\\t\\tthis.anchor.y = 0.5;\\r\\n\\t\\tthis._duration = 10;\\r\\n\\t\\tthis._holdDuration = 20;\\r\\n\\t};\\r\\n\\t\\r\\n\\tSprite_Reticule.prototype.start = function(info) {\\r\\n\\t\\tthis._time = 0;\\r\\n\\t\\tthis._actor = info.actor;\\r\\n\\t\\tthis._targetActor = info.targetActor;\\r\\n\\t}\\r\\n\\r\\n\\tSprite_Reticule.prototype.update = function() {\\r\\n\\t\\tfunction lerp(start, end, t){\\r\\n\\t\\t//\\tt => 1-(--t)*t*t*t;\\r\\n\\t\\t\\treturn start + (end - start) * t;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif(this._time > this._duration){\\r\\n\\t\\t\\tif(this._time < this._duration + this._holdDuration){\\r\\n\\t\\t\\t\\tvar scaleFactor = 1.05 + (Math.sin((this._time - this._duration) / 2) / 15);\\r\\n\\t\\t\\t\\tthis.scale.x = scaleFactor;\\r\\n\\t\\t\\t\\tthis.scale.y = scaleFactor;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t$gameTemp.reticuleInfo = null;\\r\\n\\t\\t\\t\\tthis._actor = null;\\r\\n\\t\\t\\t\\tthis._targetActor = null;\\r\\n\\t\\t\\t\\tthis._time = 0;\\r\\n\\t\\t\\t\\tthis.scale.x = 1;\\r\\n\\t\\t\\t\\tthis.scale.y = 1;\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\tif(this._actor && this._targetActor){\\t\\r\\n\\t\\t\\tif(this._time <= this._duration){\\r\\n\\t\\t\\t\\tthis.visible = true;\\r\\n\\t\\t\\t\\tthis.x = lerp(this._actor.event.screenX(), this._targetActor.event.screenX(), this._time / this._duration);\\r\\n\\t\\t\\t\\tthis.y = lerp(this._actor.event.screenY() - 24, this._targetActor.event.screenY() - 24, this._time / this._duration);\\t\\t\\t\\t\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthis._time++;\\r\\n\\t\\t} else if($gameTemp.reticuleInfo){\\r\\n\\t\\t\\tthis.start($gameTemp.reticuleInfo);\\r\\n\\t\\t} else {\\t\\r\\n\\t\\t\\tthis.visible = false;\\r\\n\\t\\t}\\t\\t\\r\\n\\t};\\r\\n//====================================================================\\r\\n// Sprite_SrpgGrid\\r\\n//====================================================================\\t\\r\\n\\t\\r\\n\\tfunction Sprite_SrpgGrid() {\\r\\n\\t\\tthis.initialize.apply(this, arguments);\\r\\n\\t}\\r\\n\\r\\n\\tSprite_SrpgGrid.prototype = Object.create(Sprite_Base.prototype);\\r\\n\\tSprite_SrpgGrid.prototype.constructor = Sprite_SrpgGrid;\\r\\n\\r\\n\\tSprite_SrpgGrid.prototype.initialize = function() {\\r\\n\\t\\tSprite_Base.prototype.initialize.call(this);\\r\\n\\t\\tthis.bitmap = new Bitmap($gameMap.tileWidth() * $gameMap.width(), $gameMap.tileHeight() * $gameMap.height());\\r\\n\\t\\tfor(var i = 0; i < $gameMap.width(); i++){\\r\\n\\t\\t\\tthis.bitmap.fillRect(i * $gameMap.tileWidth(), 0, 1 , this.bitmap.height, \\\"white\\\");\\r\\n\\t\\t}\\r\\n\\t\\tfor(var i = 0; i < $gameMap.height(); i++){\\r\\n\\t\\t\\tthis.bitmap.fillRect(0, i * $gameMap.tileHeight(), this.bitmap.width , 1, \\\"white\\\");\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tthis.anchor.x = 0;\\r\\n\\t\\tthis.anchor.y = 0;\\r\\n\\t\\tthis._posX = 0;\\r\\n\\t\\tthis._posY = 0;\\r\\n\\t\\t//this.blendMode = Graphics.BLEND_ADD;\\r\\n\\t};\\r\\n\\r\\n\\tSprite_SrpgGrid.prototype.update = function() {\\r\\n\\t\\tif($gameSystem.enableGrid && !$gameSystem.optionDisableGrid){\\r\\n\\t\\t\\tthis.opacity = 128;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis.opacity = 0;\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\tthis.updatePosition();\\t\\t\\r\\n\\t\\t//this.bitmap.fillAll('red');\\r\\n\\t};\\r\\n\\t\\r\\n\\tSprite_SrpgGrid.prototype.updatePosition = function() {\\r\\n        var tileWidth = $gameMap.tileWidth();\\r\\n        var tileHeight = $gameMap.tileHeight();\\r\\n        this.x = ($gameMap.adjustX(this._posX) + 0.5) * tileWidth -$gameMap.tileWidth()/2;\\r\\n        this.y = ($gameMap.adjustY(this._posY) + 0.5) * tileHeight -$gameMap.tileHeight()/2;\\r\\n\\t\\tthis.z = 0;\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// Sprite_AreaHighlights\\r\\n//====================================================================\\t\\r\\n\\t\\r\\n\\tfunction Sprite_AreaHighlights() {\\r\\n\\t\\tthis.initialize.apply(this, arguments);\\r\\n\\t}\\r\\n\\r\\n\\tSprite_AreaHighlights.prototype = Object.create(Sprite_Base.prototype);\\r\\n\\tSprite_AreaHighlights.prototype.constructor = Sprite_AreaHighlights;\\r\\n\\r\\n\\tSprite_AreaHighlights.prototype.initialize = function() {\\r\\n\\t\\tSprite_Base.prototype.initialize.call(this);\\r\\n\\t\\t/*for(var i = 0; i < $gameMap.width(); i++){\\r\\n\\t\\t\\tthis.bitmap.fillRect(i * $gameMap.tileWidth(), 0, 1 , this.bitmap.height, \\\"white\\\");\\r\\n\\t\\t}\\r\\n\\t\\tfor(var i = 0; i < $gameMap.height(); i++){\\r\\n\\t\\t\\tthis.bitmap.fillRect(0, i * $gameMap.tileHeight(), this.bitmap.width , 1, \\\"white\\\");\\r\\n\\t\\t}*/\\r\\n\\t\\tthis.bitmap = new Bitmap($gameMap.tileWidth() * $gameMap.width(), $gameMap.tileHeight() * $gameMap.height());\\r\\n\\t\\tthis.construct();\\r\\n\\t\\tthis.anchor.x = 0;\\r\\n\\t\\tthis.anchor.y = 0;\\r\\n\\t\\tthis._posX = 0;\\r\\n\\t\\tthis._posY = 0;\\r\\n\\t\\t//this.opacity = 128;\\r\\n\\t\\t//this.blendMode = Graphics.BLEND_ADD;\\r\\n\\t\\tthis._frameCount = 0;\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t};\\r\\n\\t\\r\\n\\tSprite_AreaHighlights.prototype.construct = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tthis._frameCount = 0;\\r\\n\\t\\tthis.bitmap.clearRect(0, 0, $gameMap.tileWidth() * $gameMap.width(), $gameMap.tileHeight() * $gameMap.height());\\t\\t\\t\\r\\n\\t\\t\\t\\r\\n\\t\\tif($gameSystem.highlightedTiles){\\r\\n\\t\\t\\tfor(var i = 0; i < $gameSystem.highlightedTiles.length; i++){\\r\\n\\t\\t\\t\\tvar highlight = $gameSystem.highlightedTiles[i];\\r\\n\\t\\t\\t\\tthis.bitmap.fillRect(highlight.x * $gameMap.tileWidth(), highlight.y * $gameMap.tileHeight(), $gameMap.tileWidth(), $gameMap.tileHeight(), highlight.color);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\t\\r\\n\\t\\tif($gameSystem.regionHighlights){\\r\\n\\t\\t\\tObject.keys($gameSystem.regionHighlights).forEach(function(regionId){\\r\\n\\t\\t\\t\\tvar color = $gameSystem.regionHighlights[regionId];\\r\\n\\t\\t\\t\\tvar tileCoords = $gameMap.getRegionTiles(regionId);\\r\\n\\t\\t\\t\\tfor(var i = 0; i < tileCoords.length; i++){\\r\\n\\t\\t\\t\\t\\tvar highlight = tileCoords[i];\\r\\n\\t\\t\\t\\t\\t_this.bitmap.fillRect(highlight.x * $gameMap.tileWidth(), highlight.y * $gameMap.tileHeight(), $gameMap.tileWidth(), $gameMap.tileHeight(), color);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t});\\t\\t\\t\\r\\n\\t\\t}\\t\\r\\n\\t\\tif($gameSystem.highlightedMapRetargetTiles){\\r\\n\\t\\t\\tfor(var i = 0; i < $gameSystem.highlightedMapRetargetTiles.length; i++){\\r\\n\\t\\t\\t\\tvar highlight = $gameSystem.highlightedMapRetargetTiles[i];\\r\\n\\t\\t\\t\\tthis.bitmap.fillRect(highlight.x * $gameMap.tileWidth(), highlight.y * $gameMap.tileHeight(), $gameMap.tileWidth(), $gameMap.tileHeight(), highlight.color);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif($gameSystem.highlightedActionTiles){\\r\\n\\t\\t\\tfor(var i = 0; i < $gameSystem.highlightedActionTiles.length; i++){\\r\\n\\t\\t\\t\\tvar highlight = $gameSystem.highlightedActionTiles[i];\\r\\n\\t\\t\\t\\tthis.bitmap.fillRect(highlight.x * $gameMap.tileWidth(), highlight.y * $gameMap.tileHeight(), $gameMap.tileWidth(), $gameMap.tileHeight(), highlight.color);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tSprite_AreaHighlights.prototype.update = function() {\\r\\n\\t\\tif($gameSystem.highlightsRefreshed){\\r\\n\\t\\t\\t$gameSystem.highlightsRefreshed = false;\\r\\n\\t\\t\\tthis.construct();\\r\\n\\t\\t}\\t\\r\\n\\t\\tthis.updatePosition();\\t\\t\\r\\n\\t\\tif($gameTemp.disableHighlightGlow){\\r\\n\\t\\t\\tthis.opacity = 128;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis._frameCount+=2;\\r\\n\\t\\t\\tthis._frameCount %= 200;\\r\\n\\t\\t\\tif(this._frameCount < 100){\\r\\n\\t\\t\\t\\tthis.opacity = this._frameCount + 80;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tthis.opacity = 200 + 80 - this._frameCount;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\t\\t\\r\\n\\t};\\r\\n\\t\\r\\n\\tSprite_AreaHighlights.prototype.updatePosition = function() {\\r\\n        var tileWidth = $gameMap.tileWidth();\\r\\n        var tileHeight = $gameMap.tileHeight();\\r\\n        this.x = ($gameMap.adjustX(this._posX) + 0.5) * tileWidth -$gameMap.tileWidth()/2;\\r\\n        this.y = ($gameMap.adjustY(this._posY) + 0.5) * tileHeight -$gameMap.tileHeight()/2;\\r\\n\\t\\tthis.z = 0;\\r\\n    };\\r\\n\\t\\r\\n//====================================================================\\r\\n// ●Spriteset_Map\\r\\n//====================================================================\\t\\r\\n\\t\\r\\nSceneManager.reloadCharacters = function(startEvent){\\r\\n\\tif(SceneManager._scene){\\r\\n\\t\\tSceneManager._scene.children[0].reloadCharacters(startEvent);\\r\\n\\t}\\t\\r\\n}\\r\\n\\t\\r\\n//====================================================================\\r\\n// ●Spriteset_Map\\r\\n//====================================================================\\r\\n\\r\\n\\tfunction UpperTilemap(){\\r\\n\\t\\tthis.initialize.apply(this, arguments);\\r\\n\\t}\\r\\n\\t\\r\\n\\tUpperTilemap.prototype = Object.create(Tilemap.prototype);\\r\\n\\tUpperTilemap.prototype.constructor = UpperTilemap;\\r\\n\\t\\r\\n\\tUpperTilemap.prototype._paintTiles = function(startX, startY, x, y) {\\r\\n\\t\\tvar tableEdgeVirtualId = 10000;\\r\\n\\t\\tvar mx = startX + x;\\r\\n\\t\\tvar my = startY + y;\\r\\n\\t\\tvar dx = (mx * this._tileWidth).mod(this._layerWidth);\\r\\n\\t\\tvar dy = (my * this._tileHeight).mod(this._layerHeight);\\r\\n\\t\\tvar lx = dx / this._tileWidth;\\r\\n\\t\\tvar ly = dy / this._tileHeight;\\r\\n\\t\\tvar tileId0 = this._readMapData(mx, my, 0);\\r\\n\\t\\tvar tileId1 = this._readMapData(mx, my, 1);\\r\\n\\t\\tvar tileId2 = this._readMapData(mx, my, 2);\\r\\n\\t\\tvar tileId3 = this._readMapData(mx, my, 3);\\r\\n\\t\\tvar shadowBits = this._readMapData(mx, my, 4);\\r\\n\\t\\tvar upperTileId1 = this._readMapData(mx, my - 1, 1);\\r\\n\\t\\tvar lowerTiles = [];\\r\\n\\t\\tvar upperTiles = [];\\r\\n\\r\\n\\t\\tif (this._isHigherTile(tileId0)) {\\r\\n\\t\\t\\tupperTiles.push(tileId0);\\r\\n\\t\\t}\\r\\n\\t\\tif (this._isHigherTile(tileId1)) {\\r\\n\\t\\t\\tupperTiles.push(tileId1);\\r\\n\\t\\t} \\r\\n\\r\\n\\t\\tif (this._isOverpassPosition(mx, my)) {\\r\\n\\t\\t\\tupperTiles.push(tileId2);\\r\\n\\t\\t\\tupperTiles.push(tileId3);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif (this._isHigherTile(tileId2)) {\\r\\n\\t\\t\\t\\tupperTiles.push(tileId2);\\r\\n\\t\\t\\t} \\r\\n\\t\\t\\tif (this._isHigherTile(tileId3)) {\\r\\n\\t\\t\\t\\tupperTiles.push(tileId3);\\r\\n\\t\\t\\t} \\r\\n\\t\\t}\\r\\n\\t\\tvar lastUpperTiles = this._readLastTiles(1, lx, ly);\\r\\n\\t\\tif (!upperTiles.equals(lastUpperTiles)) {\\r\\n\\t\\t\\tthis._upperBitmap.clearRect(dx, dy, this._tileWidth, this._tileHeight);\\r\\n\\t\\t\\tfor (var j = 0; j < upperTiles.length; j++) {\\r\\n\\t\\t\\t\\tthis._drawTile(this._upperBitmap, upperTiles[j], dx, dy);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthis._writeLastTiles(1, lx, ly, upperTiles);\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tfunction UpperShaderTileMap(){\\r\\n\\t\\tTilemap.apply(this, arguments);\\r\\n\\t\\tthis.roundPixels = true;\\r\\n\\t}\\r\\n\\t\\r\\n\\tUpperShaderTileMap.prototype = Object.create(ShaderTilemap.prototype);\\r\\n\\tUpperShaderTileMap.prototype.constructor = UpperShaderTileMap;\\r\\n\\t\\r\\n\\tUpperShaderTileMap.prototype._paintTiles = function(startX, startY, x, y) {\\r\\n\\t\\tvar mx = startX + x;\\r\\n\\t\\tvar my = startY + y;\\r\\n\\t\\tvar dx = x * this._tileWidth, dy = y * this._tileHeight;\\r\\n\\t\\tvar tileId0 = this._readMapData(mx, my, 0);\\r\\n\\t\\tvar tileId1 = this._readMapData(mx, my, 1);\\r\\n\\t\\tvar tileId2 = this._readMapData(mx, my, 2);\\r\\n\\t\\tvar tileId3 = this._readMapData(mx, my, 3);\\r\\n\\t\\tvar shadowBits = this._readMapData(mx, my, 4);\\r\\n\\t\\tvar upperTileId1 = this._readMapData(mx, my - 1, 1);\\r\\n\\t\\tvar lowerLayer = this.lowerLayer.children[0];\\r\\n\\t\\tvar upperLayer = this.upperLayer.children[0];\\r\\n\\r\\n\\t\\tif (this._isHigherTile(tileId0)) {\\r\\n\\t\\t\\tthis._drawTile(upperLayer, tileId0, dx, dy);\\r\\n\\t\\t} \\r\\n\\t\\tif (this._isHigherTile(tileId1)) {\\r\\n\\t\\t\\tthis._drawTile(upperLayer, tileId1, dx, dy);\\r\\n\\t\\t} \\r\\n\\r\\n\\t\\t\\r\\n\\t\\tif (this._isOverpassPosition(mx, my)) {\\r\\n\\t\\t\\tthis._drawTile(upperLayer, tileId2, dx, dy);\\r\\n\\t\\t\\tthis._drawTile(upperLayer, tileId3, dx, dy);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif (this._isHigherTile(tileId2)) {\\r\\n\\t\\t\\t\\tthis._drawTile(upperLayer, tileId2, dx, dy);\\r\\n\\t\\t\\t} \\r\\n\\t\\t\\tif (this._isHigherTile(tileId3)) {\\r\\n\\t\\t\\t\\tthis._drawTile(upperLayer, tileId3, dx, dy);\\r\\n\\t\\t\\t} \\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\t\\r\\n\\tSpriteset_Map.prototype.createUpperLayer = function() {\\r\\n\\t\\t\\r\\n\\t\\t/*if($gameTemp.intermissionPending){\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}*/\\r\\n\\t\\t\\r\\n\\t\\tif (Graphics.isWebGL()) {\\r\\n\\t\\t\\tthis._upperTilemap = new UpperShaderTileMap();\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis._upperTilemap = new UpperTilemap();\\r\\n\\t\\t}\\r\\n\\t\\tthis._upperTilemap.tileWidth = $gameMap.tileWidth();\\r\\n\\t\\tthis._upperTilemap.tileHeight = $gameMap.tileHeight();\\r\\n\\t\\tthis._upperTilemap.setData($gameMap.width(), $gameMap.height(), $gameMap.data());\\r\\n\\t\\tthis._upperTilemap.horizontalWrap = $gameMap.isLoopHorizontal();\\r\\n\\t\\tthis._upperTilemap.verticalWrap = $gameMap.isLoopVertical();\\r\\n\\t\\r\\n\\t\\tthis._tileset = $gameMap.tileset();\\r\\n\\t\\tif (this._tileset) {\\r\\n\\t\\t\\tvar tilesetNames = this._tileset.tilesetNames;\\r\\n\\t\\t\\tfor (var i = 0; i < tilesetNames.length; i++) {\\r\\n\\t\\t\\t\\tthis._upperTilemap.bitmaps[i] = ImageManager.loadTileset(tilesetNames[i]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tvar newTilesetFlags = $gameMap.tilesetFlags();\\t\\t\\t\\r\\n\\t\\t\\tthis._upperTilemap.refreshTileset();\\r\\n\\t\\t\\tif (!this._tilemap.flags.equals(newTilesetFlags)) {\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tthis._upperTilemap.refresh();\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthis._upperTilemap.flags = newTilesetFlags;\\r\\n\\t\\t}\\r\\n\\t\\r\\n\\t\\tthis._baseSprite.addChild(this._upperTilemap);\\r\\n\\t\\t\\r\\n\\t\\tfor (var i = 0; i < this.shipUpperTops.length; i++) {\\r\\n\\t\\t\\tthis.addCharacterToBaseSprite(this.shipUpperTops[i]);\\r\\n\\t\\t}\\r\\n\\t\\tfor (var i = 0; i < this.actorUpperTops.length; i++) {\\r\\n\\t\\t\\tthis.addCharacterToBaseSprite(this.actorUpperTops[i]);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tthis._srpgMoveTile = [];\\r\\n        for (var i = 0; i < $gameSystem.spriteMoveTileMax(); i++) {\\r\\n\\t\\t\\tthis._srpgMoveTile[i] = new Sprite_SrpgMoveTile();\\r\\n\\t\\t\\tthis._baseSprite.addChild(this._srpgMoveTile[i]);\\r\\n        }\\r\\n\\t\\t\\r\\n\\t\\tthis._highlightSprite = new Sprite_AreaHighlights();\\r\\n\\t\\tthis._baseSprite.addChild(this._highlightSprite); \\r\\n\\t\\t\\r\\n\\t\\tfor (var i = 0; i < this.shipBottomOverlays.length; i++) {\\r\\n\\t\\t\\tthis.addCharacterToBaseSprite(this.shipBottomOverlays[i]);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tfor (var i = 0; i < this.shipTopOverlays.length; i++) {\\r\\n\\t\\t\\tthis.addCharacterToBaseSprite(this.shipTopOverlays[i]);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tfor (var i = 0; i < this.actorBottomOverlays.length; i++) {\\r\\n\\t\\t\\tthis.addCharacterToBaseSprite(this.actorBottomOverlays[i]);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tfor (var i = 0; i < this.actorTopOverlays.length; i++) {\\r\\n\\t\\t\\tthis.addCharacterToBaseSprite(this.actorTopOverlays[i]);\\r\\n\\t\\t}\\t\\r\\n\\t\\t\\r\\n\\t\\tfor (var i = 0; i < this.shipTurnEndSprites.length; i++) {\\r\\n\\t\\t\\tthis.addCharacterToBaseSprite(this.shipTurnEndSprites[i]);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tfor (var i = 0; i < this.actorTurnEndSprites.length; i++) {\\r\\n\\t\\t\\tthis.addCharacterToBaseSprite(this.actorTurnEndSprites[i]);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\t$gameMap.events().forEach(function(event) {\\r\\n\\t\\t\\tthis.createDefendIndicator(event._eventId, event);\\r\\n\\t\\t\\tthis.createAttackIndicator(event._eventId, event);\\r\\n\\t\\t\\tthis.createWillIndicator(event._eventId, event);\\r\\n\\t\\t\\tthis.createTwinIndicator(event._eventId, event);\\r\\n\\t\\t\\tthis.createExplosionSprite(event._eventId, event);\\r\\n\\t\\t\\tthis.createAppearSprite(event._eventId, event);\\r\\n\\t\\t\\tthis.createDisappearSprite(event._eventId, event);\\t\\r\\n\\t\\t}, this);\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tthis._reticuleSprite = new Sprite_Reticule();\\r\\n\\t\\tthis.addCharacterToBaseSprite(this._reticuleSprite);\\r\\n\\t\\t\\r\\n\\t\\tvar sprite = new Sprite_Player($gamePlayer);\\r\\n\\t\\t$gameTemp.upperPlayerSprite = sprite;\\r\\n\\t\\tthis.addCharacterToBaseSprite(sprite);   \\r\\n\\t\\t\\t\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tthis.createPictures();\\r\\n\\t\\tthis.createTimer();\\r\\n\\t\\tthis.createScreenSprites();\\r\\n\\t\\t\\r\\n\\t\\t$gameTemp.updatePlayerSpriteVisibility();\\r\\n\\t};\\r\\n\\t\\r\\n\\tSpriteset_Map.prototype.updateTilemap = function() {\\r\\n\\t\\tthis._tilemap.origin.x = $gameMap.displayX() * $gameMap.tileWidth();\\r\\n\\t\\tthis._tilemap.origin.y = $gameMap.displayY() * $gameMap.tileHeight();\\r\\n\\t\\t\\r\\n\\t\\tthis._upperTilemap.origin.x = $gameMap.displayX() * $gameMap.tileWidth();\\r\\n\\t\\tthis._upperTilemap.origin.y = $gameMap.displayY() * $gameMap.tileHeight();\\r\\n\\t};\\r\\n\\r\\n    var _SRPG_Spriteset_Map_createTilemap = Spriteset_Map.prototype.createTilemap;\\r\\n    Spriteset_Map.prototype.createTilemap = function() {\\t\\t\\r\\n\\t\\t_SRPG_Spriteset_Map_createTilemap.call(this);\\r\\n\\t\\tif($gameTemp.intermissionPending){\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\tthis._gridSprite = new Sprite_SrpgGrid();\\r\\n\\t\\tthis._baseSprite.addChild(this._gridSprite);   \\r\\n\\t\\t\\r\\n\\t\\t \\t\\t\\r\\n        \\t\\r\\n    };\\r\\n\\t\\r\\n\\tSpriteset_Map.prototype.addCharacterToBaseSprite = function(sprite) {\\r\\n\\t\\tvar child = this._baseSprite.addChild(sprite);\\r\\n\\t\\tthis._characterLayerSprites.push(child);\\r\\n\\t}\\r\\n\\t\\r\\n\\tSpriteset_Map.prototype.reloadCharacters = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tthis._characterLayerSprites.forEach(function(child){\\r\\n\\t\\t\\t_this._baseSprite.removeChild(child);\\r\\n\\t\\t});\\r\\n\\t\\tthis.createCharacters();\\r\\n\\t}\\r\\n\\t\\r\\n\\tvar _SRPG_Spriteset_Map_createTilemap_createCharacters = Spriteset_Map.prototype.createCharacters;\\r\\n\\tSpriteset_Map.prototype.createCharacters = function() {\\r\\n\\t\\tvar _this  = this;\\r\\n\\t\\tthis._characterLayerSprites = [];\\r\\n\\t\\t/*if($gameTemp.intermissionPending){\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}*/\\r\\n\\t\\t\\t\\r\\n\\t\\tthis._bshadowSprites = {};\\r\\n\\t\\tthis._explosionSprites = {};\\r\\n\\t\\tthis._appearSprites = {};\\r\\n\\t\\tthis._disappearSprites = {};\\r\\n\\t\\tthis._willIndicators = {};\\r\\n\\t\\tthis._defendIndicators = {};\\r\\n\\t\\tthis._attackIndicators = {};\\r\\n\\t\\tthis._twinIndicators = {};\\r\\n\\t\\t$gameMap.events().forEach(function(event) {\\r\\n\\t\\t\\tthis.createBShadow(event._eventId,event);\\t\\t\\t\\r\\n\\t\\t}, this);\\r\\n\\t\\t//_SRPG_Spriteset_Map_createTilemap_createCharacters.call(this);\\r\\n\\t\\tthis._characterSprites = [];\\r\\n\\t\\tvar ships = [];\\r\\n\\t\\tvar shipBottoms = [];\\r\\n\\t\\tvar shipTops = [];\\r\\n\\t\\tvar actors = [];\\r\\n\\t\\tvar actorBottoms = [];\\r\\n\\t\\tvar actorTops = [];\\r\\n\\t\\t\\r\\n\\t\\tthis.shipTurnEndSprites = [];\\r\\n\\t\\tthis.actorTurnEndSprites = [];\\r\\n\\t\\tthis.shipUpperTops = [];\\r\\n\\t\\tthis.actorUpperTops = [];\\r\\n\\t\\tthis.actorTopOverlays = [];\\r\\n\\t\\tthis.actorBottomOverlays = [];\\r\\n\\t\\tthis.shipTopOverlays = [];\\r\\n\\t\\tthis.shipBottomOverlays = [];\\r\\n\\t\\t\\r\\n\\t\\t$gameMap.events().forEach(function(event) {\\r\\n\\t\\t\\tif(event.isType() == \\\"ship\\\" || event.isType() == \\\"ship_event\\\"){\\r\\n\\t\\t\\t\\tships.push(new Sprite_Character(event));\\r\\n\\t\\t\\t\\tshipBottoms.push(new Sprite());\\r\\n\\t\\t\\t\\t_this.shipBottomOverlays.push(new Sprite());\\r\\n\\t\\t\\t\\t_this.shipTurnEndSprites.push(new Sprite());\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tactors.push(new Sprite_Character(event));\\r\\n\\t\\t\\t\\tactorBottoms.push(new Sprite());\\r\\n\\t\\t\\t\\t_this.actorBottomOverlays.push(new Sprite());\\r\\n\\t\\t\\t\\t_this.actorTurnEndSprites.push(new Sprite());\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}, this);\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\t$gameMap.events().forEach(function(event) {\\r\\n\\t\\t\\tif(event.isType() == \\\"ship\\\" || event.isType() == \\\"ship_event\\\"){\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tshipTops.push(new Sprite());\\r\\n\\t\\t\\t\\t_this.shipTopOverlays.push(new Sprite());\\r\\n\\t\\t\\t\\t_this.shipUpperTops.push(new Sprite());\\r\\n\\t\\t\\t} else {\\t\\t\\t\\r\\n\\t\\t\\t\\tactorTops.push(new Sprite());\\r\\n\\t\\t\\t\\t_this.actorTopOverlays.push(new Sprite());\\r\\n\\t\\t\\t\\t_this.actorUpperTops.push(new Sprite());\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}, this);\\r\\n\\t\\t\\r\\n\\t\\tfor(var i = 0; i < actors.length; i++){\\r\\n\\t\\t\\tactors[i].setLowerBody(actorBottoms[i]);\\r\\n\\t\\t\\tactors[i].setUpperBody(actorTops[i]);\\r\\n\\t\\t\\tactors[i].setUpperBodyTop(this.actorUpperTops[i]);\\r\\n\\t\\t\\tactors[i].setTurnEnd(this.actorTurnEndSprites[i]);\\r\\n\\t\\t\\tactors[i].setLowerBodyOverlay(this.actorBottomOverlays[i]);\\r\\n\\t\\t\\tactors[i].setUpperBodyOverlay(this.actorTopOverlays[i]);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tfor(var i = 0; i < ships.length; i++){\\r\\n\\t\\t\\tships[i].setLowerBody(shipBottoms[i]);\\r\\n\\t\\t\\tships[i].setUpperBody(shipTops[i]);\\r\\n\\t\\t\\tships[i].setUpperBodyTop(this.shipUpperTops[i]);\\r\\n\\t\\t\\tships[i].setTurnEnd(this.shipTurnEndSprites[i]);\\r\\n\\t\\t\\tships[i].setLowerBodyOverlay(this.shipBottomOverlays[i]);\\r\\n\\t\\t\\tships[i].setUpperBodyOverlay(this.shipTopOverlays[i]);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tthis._characterSprites = shipBottoms.concat(actorBottoms).concat(shipTops).concat(actorTops).concat(ships).concat(actors);\\r\\n\\t\\t\\r\\n\\t\\t//.concat(shipTurnEndSprites) .concat(actorTurnEndSprites)\\r\\n\\t\\t$gameMap.vehicles().forEach(function(vehicle) {\\r\\n\\t\\t\\tthis._characterSprites.push(new Sprite_Character(vehicle));\\r\\n\\t\\t}, this);\\r\\n\\t\\t$gamePlayer.followers().reverseEach(function(follower) {\\r\\n\\t\\t\\tthis._characterSprites.push(new Sprite_Character(follower));\\r\\n\\t\\t}, this);\\r\\n\\t\\tvar sprite = new Sprite_Player($gamePlayer);\\r\\n\\t\\t$gameTemp.lowerPlayerSprite = sprite;\\r\\n\\t\\tthis.addCharacterToBaseSprite(sprite);  \\t\\t \\r\\n\\t\\t\\r\\n\\t\\tfor (var i = 0; i < this._characterSprites.length; i++) {\\r\\n\\t\\t\\tthis.addCharacterToBaseSprite(this._characterSprites[i]);\\r\\n\\t\\t}\\t\\t   \\t\\r\\n\\t};\\r\\n\\t\\r\\n\\tSpriteset_Map.prototype.createExplosionSprite = function(id,character) {\\r\\n\\t\\tif (!character) return;\\r\\n\\t\\tif (!this._explosionSprites[id]) {\\r\\n\\t\\t\\tthis._explosionSprites[id] = new Sprite_Destroyed(character);\\r\\n\\t\\t\\tthis.addCharacterToBaseSprite(this._explosionSprites[id]);\\r\\n\\t\\t\\tcharacter._explosionSprite = true;\\r\\n\\t\\t};\\r\\n\\t};\\r\\n\\t\\r\\n\\tSpriteset_Map.prototype.createAppearSprite = function(id,character) {\\r\\n\\t\\tif (!character) return;\\r\\n\\t\\tif (!this._appearSprites[id]) {\\r\\n\\t\\t\\tthis._appearSprites[id] = new Sprite_Appear(character);\\r\\n\\t\\t\\tthis.addCharacterToBaseSprite(this._appearSprites[id]);\\r\\n\\t\\t\\tcharacter._appearSprite = true;\\r\\n\\t\\t};\\r\\n\\t};\\r\\n\\t\\r\\n\\tSpriteset_Map.prototype.createDisappearSprite = function(id,character) {\\r\\n\\t\\tif (!character) return;\\r\\n\\t\\tif (!this._disappearSprites[id]) {\\r\\n\\t\\t\\tthis._disappearSprites[id] = new Sprite_Disappear(character);\\r\\n\\t\\t\\tthis.addCharacterToBaseSprite(this._disappearSprites[id]);\\r\\n\\t\\t\\tcharacter._disappearSprite = true;\\r\\n\\t\\t};\\r\\n\\t};\\r\\n\\t\\r\\n\\tSpriteset_Map.prototype.createBShadow = function(id,character) {\\r\\n\\t\\tif (!character) return;\\r\\n\\t\\tif (!this._bshadowSprites[id]) {\\r\\n\\t\\t\\tthis._bshadowSprites[id] = new Sprite_BasicShadow(character);\\r\\n\\t\\t\\tthis.addCharacterToBaseSprite(this._bshadowSprites[id]);\\r\\n\\t\\t\\tcharacter._shadSprite = true;\\r\\n\\t\\t};\\r\\n\\t};\\r\\n\\t\\r\\n\\tSpriteset_Map.prototype.createWillIndicator = function(id,character) {\\r\\n\\t\\tif (!character) return;\\r\\n\\t\\tif (!this._willIndicators[id]) {\\r\\n\\t\\t\\tthis._willIndicators[id] = new Sprite_WillIndicator(character);\\r\\n\\t\\t\\tthis.addCharacterToBaseSprite(this._willIndicators[id]);\\r\\n\\t\\t\\tcharacter._willIndicator = true;\\r\\n\\t\\t};\\r\\n\\t};\\t\\r\\n\\t\\r\\n\\tSpriteset_Map.prototype.createDefendIndicator = function(id,character) {\\r\\n\\t\\tif (!character) return;\\r\\n\\t\\tif (!this._defendIndicators[id]) {\\r\\n\\t\\t\\tthis._defendIndicators[id] = new Sprite_DefendIndicator(character);\\r\\n\\t\\t\\tthis.addCharacterToBaseSprite(this._defendIndicators[id]);\\r\\n\\t\\t\\tcharacter._defendIndicator = true;\\r\\n\\t\\t};\\r\\n\\t};\\t\\r\\n\\t\\r\\n\\tSpriteset_Map.prototype.createAttackIndicator = function(id,character) {\\r\\n\\t\\tif (!character) return;\\r\\n\\t\\tif (!this._attackIndicators[id]) {\\r\\n\\t\\t\\tthis._attackIndicators[id] = new Sprite_AttackIndicator(character);\\r\\n\\t\\t\\tthis.addCharacterToBaseSprite(this._attackIndicators[id]);\\r\\n\\t\\t\\tcharacter._defendIndicator = true;\\r\\n\\t\\t};\\r\\n\\t};\\r\\n\\t\\r\\n\\tSpriteset_Map.prototype.createTwinIndicator = function(id,character) {\\r\\n\\t\\tif (!character) return;\\r\\n\\t\\tif (!this._twinIndicators[id]) {\\r\\n\\t\\t\\tthis._twinIndicators[id] = new Sprite_TwinIndicator(character);\\r\\n\\t\\t\\tthis.addCharacterToBaseSprite(this._twinIndicators[id]);\\r\\n\\t\\t\\tcharacter._twinIndicator = true;\\r\\n\\t\\t};\\r\\n\\t};\\t\\r\\n\\r\\n    var _SRPG_Spriteset_Map_update = Spriteset_Map.prototype.update;\\r\\n    Spriteset_Map.prototype.update = function() {\\r\\n        _SRPG_Spriteset_Map_update.call(this);\\r\\n        this.updateSrpgMoveTile();\\r\\n\\t\\tif($gameTemp.tempSprites){\\r\\n\\t\\t\\twhile($gameTemp.tempSprites.length){\\r\\n\\t\\t\\t\\tvar sprite = $gameTemp.tempSprites.pop();\\r\\n\\t\\t\\t\\tthis._baseSprite.addChild(sprite);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n    };\\r\\n\\r\\n    Spriteset_Map.prototype.updateSrpgMoveTile = function() {\\r\\n\\t\\tif(this._srpgMoveTile){\\t\\t\\r\\n\\t\\t\\tif ($gameTemp.resetMoveList() == true) {\\r\\n\\t\\t\\t\\tfor (var i = 0; i < $gameSystem.spriteMoveTileMax(); i++) {\\r\\n\\t\\t\\t\\t\\tthis._srpgMoveTile[i].clearThisMoveTile();\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t$gameTemp.setResetMoveList(false);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif ($gameTemp.isMoveListValid()) {\\r\\n\\t\\t\\t\\tif (!this._srpgMoveTile[0].isThisMoveTileValid()) {\\r\\n\\t\\t\\t\\t\\tvar list = $gameTemp.moveList();\\r\\n\\t\\t\\t\\t\\tfor (var i = 0; i < list.length; i++) {\\r\\n\\t\\t\\t\\t\\t\\tvar pos = list[i];\\r\\n\\t\\t\\t\\t\\t\\tthis._srpgMoveTile[i].setThisMoveTile(pos[0], pos[1], pos[2]);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tif (this._srpgMoveTile[0].isThisMoveTileValid()) {\\r\\n\\t\\t\\t\\t\\tfor (var i = 0; i < $gameSystem.spriteMoveTileMax(); i++) {\\r\\n\\t\\t\\t\\t\\t\\tthis._srpgMoveTile[i].clearThisMoveTile();\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// ●Window_Base\\r\\n//====================================================================\\r\\n    // EXPの割合を表示する\\r\\n    Window_Base.prototype.drawSrpgExpRate = function(actor, x, y, width) {\\r\\n        width = width || 120;\\r\\n        var color1 = this.hpGaugeColor1();\\r\\n        var color2 = this.hpGaugeColor2();\\r\\n        this.drawGauge(x, y, width, actor.expRate(), color1, color2);\\r\\n    };\\r\\n\\r\\n    Window_Base.prototype.drawEnemyFaceWhenNoFace = function(enemy, x, y, width, height) {\\r\\n        width = width || Window_Base._faceWidth;\\r\\n        height = height || Window_Base._faceHeight;\\r\\n        if ($gameSystem.isSideView()) {\\r\\n            var bitmap = ImageManager.loadSvEnemy(enemy.battlerName(), enemy.battlerHue());\\r\\n        } else {\\r\\n            var bitmap = ImageManager.loadEnemy(enemy.battlerName(), enemy.battlerHue());\\r\\n        }\\r\\n        var pw = Window_Base._faceWidth;\\r\\n        var ph = Window_Base._faceHeight;\\r\\n        var sw = Math.min(width, pw, bitmap.width);\\r\\n        var sh = Math.min(height, ph, bitmap.height);\\r\\n        var dx = Math.floor(x + Math.max(width - bitmap.width, 0) / 2);\\r\\n        var dy = Math.floor(y + Math.max(height - bitmap.height, 0) / 2);\\r\\n        var sx = Math.floor(Math.max(bitmap.width / 2 - width / 2, 0));\\r\\n        var sy = Math.floor(Math.max(bitmap.height / 2 - height / 2, 0));\\r\\n        this.contents.blt(bitmap, sx, sy, sw, sh, dx, dy);\\r\\n    };\\r\\n\\r\\n    // エネミーの職業（クラス）を描画する\\r\\n    Window_Base.prototype.drawEnemyClass = function(enemy, x, y, width) {\\r\\n        width = width || 168;\\r\\n        var className = enemy.enemy().meta.srpgClass;\\r\\n        if (!className) {\\r\\n            className = _enemyDefaultClass;\\r\\n        }\\r\\n        this.resetTextColor();\\r\\n        this.drawText(className, x, y, width);\\r\\n    };\\r\\n\\r\\n    // エネミーの顔グラフィックを描画する\\r\\n    Window_Base.prototype.drawEnemyFace = function(enemy, x, y, width, height) {\\r\\n        var faceName = enemy.enemy().meta.faceName;\\r\\n        var faceIndex = enemy.enemy().meta.faceIndex - 1;\\r\\n        if (!faceName || !faceIndex) {\\r\\n            this.drawEnemyFaceWhenNoFace(enemy, x, y, width, height);\\r\\n        } else {\\r\\n            this.drawFace(faceName, faceIndex, x, y, width, height);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    // エネミーのレベルを描画する\\r\\n    Window_Base.prototype.drawEnemyLevel = function(enemy, x, y) {\\r\\n\\t\\tvar srpgLevel;\\r\\n\\t\\tvar SRWLevel = $statCalc.getCurrentLevel(enemy);\\r\\n\\t\\tif(SRWLevel){\\r\\n\\t\\t\\tsrpgLevel = SRWLevel;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tsrpgLevel = enemy.enemy().meta.srpgLevel;\\r\\n\\t\\t}\\r\\n        if (srpgLevel) {\\r\\n            this.changeTextColor(this.systemColor());\\r\\n            this.drawText(TextManager.levelA, x, y, 48);\\r\\n            this.resetTextColor();\\r\\n            this.drawText(srpgLevel, x + 84, y, 36, 'right');\\r\\n        }\\r\\n    };\\r\\n\\r\\n    // アクターの装備（武器）を描画する\\r\\n    Window_Base.prototype.drawActorSrpgEqiup = function(actor, x, y) {\\r\\n        var item = actor.weapons()[0]\\r\\n        this.changeTextColor(this.systemColor());\\r\\n        this.drawText(_textSrpgEquip, x, y, 92);\\r\\n        this.resetTextColor();\\r\\n        if (item) {\\r\\n            this.drawItemName(item, x + 96, y, 240);\\r\\n        } else {\\r\\n// Japanese Term \\\"なし\\\"\\r\\n            this.drawText('None', x + 96, y, 240);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    // エネミーの装備（武器）を描画する\\r\\n    Window_Base.prototype.drawEnemySrpgEqiup = function(enemy, x, y) {\\r\\n        var item = $dataWeapons[enemy.enemy().meta.srpgWeapon];\\r\\n        this.changeTextColor(this.systemColor());\\r\\n        this.drawText(_textSrpgEquip, x, y, 92);\\r\\n        this.resetTextColor();\\r\\n        if (item) {\\r\\n            this.drawItemName(item, x + 96, y, 240);\\r\\n        } else {\\r\\n// Japanese Term \\\"なし\\\"\\r\\n            this.drawText('None', x + 96, y, 240);\\r\\n        }\\r\\n    };\\r\\n\\t\\r\\n\\tWindow_Base.prototype.drawActorMp = function(actor, x, y, width) {\\r\\n\\t\\twidth = width || 186;\\r\\n\\t\\tvar color1 = this.mpGaugeColor1();\\r\\n\\t\\tvar color2 = this.mpGaugeColor2();\\r\\n\\t\\tthis.drawGauge(x, y, width, actor.mpRate(), color1, color2);\\r\\n\\t\\tthis.changeTextColor(this.systemColor());\\r\\n\\t\\tthis.drawText(\\\"EN\\\", x, y, 44);\\r\\n\\t\\tthis.drawCurrentAndMax(actor.mp, actor.mmp, x, y, width,\\r\\n\\t\\t\\t\\t\\t\\t\\t   this.mpColor(actor), this.normalColor());\\r\\n\\t};\\r\\n\\r\\n//====================================================================\\r\\n// ●Window_SrpgStatus\\r\\n//====================================================================\\r\\n    function Window_SrpgStatus() {\\r\\n        this.initialize.apply(this, arguments);\\r\\n    }\\r\\n\\r\\n    Window_SrpgStatus.prototype = Object.create(Window_Base.prototype);\\r\\n    Window_SrpgStatus.prototype.constructor = Window_SrpgStatus;\\r\\n\\r\\n    Window_SrpgStatus.prototype.initialize = function(x, y) {\\r\\n        var width = this.windowWidth();\\r\\n        var height = this.windowHeight();\\r\\n        this._type = null;\\r\\n        this._battler = null;\\r\\n        Window_Base.prototype.initialize.call(this, x, y, width, height);\\r\\n        this.refresh();\\r\\n    };\\r\\n\\r\\n    Window_SrpgStatus.prototype.windowWidth = function() {\\r\\n        return 408;\\r\\n    };\\r\\n\\r\\n    Window_SrpgStatus.prototype.windowHeight = function() {\\r\\n        return this.fittingHeight(6);\\r\\n    };\\r\\n\\r\\n    Window_SrpgStatus.prototype.setBattler = function(data) {\\r\\n        this._type = data[0];\\r\\n        this._battler = data[1];\\r\\n        this.refresh();\\r\\n    };\\r\\n\\r\\n    Window_SrpgStatus.prototype.clearBattler = function() {\\r\\n        this._type = null;\\r\\n        this._battler = null;\\r\\n        this.refresh();\\r\\n    };\\r\\n\\r\\n    Window_SrpgStatus.prototype.refresh = function() {\\r\\n        this.contents.clear();\\r\\n        if (!this._battler) {\\r\\n          return;\\r\\n        }\\r\\n        if (this._type === 'actor') {\\r\\n            this.drawContentsActor();\\r\\n        } else if (this._type === 'enemy') {\\r\\n            this.drawContentsEnemy();\\r\\n        }\\r\\n    };\\r\\n\\r\\n    Window_SrpgStatus.prototype.drawContentsActor = function() {\\r\\n        var lineHeight = this.lineHeight();\\r\\n        this.drawActorName(this._battler, 6, lineHeight * 0);\\r\\n        this.drawActorClass(this._battler, 192, lineHeight * 0);\\r\\n        this.drawActorFace(this._battler, 6, lineHeight * 1);\\r\\n        this.drawBasicInfoActor(176, lineHeight * 1);\\r\\n        //this.drawActorSrpgEqiup(this._battler, 6, lineHeight * 5);\\r\\n       // this.drawParameters(6, lineHeight * 6);\\r\\n        //this.drawSrpgParameters(6, lineHeight * 9);\\r\\n    };\\r\\n\\r\\n    Window_SrpgStatus.prototype.drawContentsEnemy = function() {\\r\\n        var lineHeight = this.lineHeight();\\r\\n        this.drawActorName(this._battler, 6, lineHeight * 0);\\r\\n        this.drawEnemyClass(this._battler, 192, lineHeight * 0);\\r\\n        this.drawEnemyFace(this._battler, 6, lineHeight * 1);\\r\\n        this.drawBasicInfoEnemy(176, lineHeight * 1);\\r\\n        //this.drawEnemySrpgEqiup(this._battler, 6, lineHeight * 5);\\r\\n       // this.drawParameters(6, lineHeight * 6);\\r\\n       // this.drawSrpgParameters(6, lineHeight * 9);\\r\\n    };\\r\\n\\r\\n    Window_SrpgStatus.prototype.drawBasicInfoActor = function(x, y) {\\r\\n        var lineHeight = this.lineHeight();\\r\\n        this.drawSrpgExpRate(this._battler, x, y + lineHeight * 0);\\r\\n        this.drawActorLevel(this._battler, x, y + lineHeight * 0);\\r\\n        this.drawActorIcons(this._battler, x, y + lineHeight * 1);\\r\\n        this.drawActorHp(this._battler, x, y + lineHeight * 2);\\r\\n        if ($dataSystem.optDisplayTp) {\\r\\n            this.drawActorMp(this._battler, x, y + lineHeight * 3, 90);\\r\\n            this.drawActorTp(this._battler, x + 96, y + lineHeight * 3, 90);\\r\\n        } else {\\r\\n            this.drawActorMp(this._battler, x, y + lineHeight * 3);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    Window_SrpgStatus.prototype.drawBasicInfoEnemy = function(x, y) {\\r\\n        var lineHeight = this.lineHeight();\\r\\n        this.drawEnemyLevel(this._battler, x, y + lineHeight * 0);\\r\\n        this.drawActorIcons(this._battler, x, y + lineHeight * 1);\\r\\n        this.drawActorHp(this._battler, x, y + lineHeight * 2);\\r\\n        if ($dataSystem.optDisplayTp) {\\r\\n            this.drawActorMp(this._battler, x, y + lineHeight * 3, 90);\\r\\n            this.drawActorTp(this._battler, x + 96, y + lineHeight * 3, 90);\\r\\n        } else {\\r\\n            this.drawActorMp(this._battler, x, y + lineHeight * 3);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    Window_SrpgStatus.prototype.drawParameters = function(x, y) {\\r\\n        var lineHeight = this.lineHeight();\\r\\n        for (var i = 0; i < 6; i++) {\\r\\n            var paramId = i + 2;\\r\\n            var x2 = x + 188 * (i % 2);\\r\\n            var y2 = y + lineHeight * Math.floor(i / 2);\\r\\n            this.changeTextColor(this.systemColor());\\r\\n            this.drawText(TextManager.param(paramId), x2, y2, 120);\\r\\n            this.resetTextColor();\\r\\n            this.drawText(this._battler.param(paramId), x2 + 120, y2, 48, 'right');\\r\\n        }\\r\\n    };\\r\\n\\r\\n    Window_SrpgStatus.prototype.drawSrpgParameters = function(x, y) {\\r\\n        var lineHeight = this.lineHeight();\\r\\n        this.changeTextColor(this.systemColor());\\r\\n        this.drawText(_textSrpgMove, x, y, 120);\\r\\n        this.resetTextColor();\\r\\n        this.drawText(this._battler.srpgMove(), x + 120, y, 48, 'right');\\r\\n        this.changeTextColor(this.systemColor());\\r\\n        this.drawText(_textSrpgRange, x + 188, y, 120);\\r\\n        this.resetTextColor();\\r\\n        var text = '';\\r\\n        if (this._battler.srpgWeaponMinRange() > 0) {\\r\\n            text += this._battler.srpgWeaponMinRange() + '-';\\r\\n        }\\r\\n        text += this._battler.srpgWeaponRange();\\r\\n        this.drawText(text, x + 188 + 72, y, 96, 'right');\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// ●Window_SrpgActorCommandStatus\\r\\n//====================================================================\\r\\n    function Window_SrpgActorCommandStatus() {\\r\\n        this.initialize.apply(this, arguments);\\r\\n    }\\r\\n\\r\\n    Window_SrpgActorCommandStatus.prototype = Object.create(Window_Base.prototype);\\r\\n    Window_SrpgActorCommandStatus.prototype.constructor = Window_SrpgActorCommandStatus;\\r\\n\\r\\n    Window_SrpgActorCommandStatus.prototype.initialize = function(x, y) {\\r\\n        var width = this.windowWidth();\\r\\n        var height = this.windowHeight();\\r\\n        this._battler = null;\\r\\n        Window_Base.prototype.initialize.call(this, x, y, width, height);\\r\\n        this.refresh();\\r\\n    };\\r\\n\\r\\n    Window_SrpgActorCommandStatus.prototype.windowWidth = function() {\\r\\n        return Graphics.boxWidth - 240;\\r\\n    };\\r\\n\\r\\n    Window_SrpgActorCommandStatus.prototype.windowHeight = function() {\\r\\n        return this.fittingHeight(3);\\r\\n    };\\r\\n\\r\\n    Window_SrpgActorCommandStatus.prototype.setBattler = function(battler) {\\r\\n        this._battler = battler;\\r\\n        this.refresh();\\r\\n        this.open();\\r\\n    };\\r\\n\\r\\n    Window_SrpgActorCommandStatus.prototype.clearBattler = function() {\\r\\n        this._battler = null;\\r\\n        this.refresh();\\r\\n        this.close();\\r\\n    };\\r\\n\\r\\n    Window_SrpgActorCommandStatus.prototype.refresh = function() {\\r\\n        this.contents.clear();\\r\\n        if (!this._battler) {\\r\\n          return;\\r\\n        }\\r\\n        this.drawContents();\\r\\n    };\\r\\n\\r\\n    Window_SrpgActorCommandStatus.prototype.drawContents = function() {\\r\\n        this.drawActorFace(this._battler, 0, -24, Window_Base._faceWidth, Window_Base._faceHeight);\\r\\n        var x = 156;\\r\\n        var y = 0;\\r\\n        var width = this.windowWidth() - x - this.textPadding();\\r\\n        var width2 = Math.min(200, this.windowWidth() - 180 - this.textPadding());\\r\\n        var lineHeight = this.lineHeight();\\r\\n        var x2 = x + 180;\\r\\n        var width2 = Math.min(200, width - 180 - this.textPadding());\\r\\n        this.drawActorName(this._battler, x, y);\\r\\n        this.drawActorLevel(this._battler, x, y + lineHeight * 1);\\r\\n        this.drawActorIcons(this._battler, x, y + lineHeight * 2);\\r\\n        this.drawActorClass(this._battler, x2, y);\\r\\n        this.drawActorHp(this._battler, x2, y + lineHeight * 1, width2);\\r\\n        if ($dataSystem.optDisplayTp) {\\r\\n            this.drawActorMp(this._battler, x2, y + lineHeight * 2, width2 / 2 - 4);\\r\\n            this.drawActorTp(this._battler, x2 + width2 / 2 + 4, y + lineHeight * 2, width2 / 2 - 4);\\r\\n        } else {\\r\\n            this.drawActorMp(this._battler, x2, y + lineHeight * 2);\\r\\n        }\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// ●Window_SrpgBattleStatus\\r\\n//====================================================================\\r\\n    function Window_SrpgBattleStatus() {\\r\\n        this.initialize.apply(this, arguments);\\r\\n    }\\r\\n\\r\\n    Window_SrpgBattleStatus.prototype = Object.create(Window_Base.prototype);\\r\\n    Window_SrpgBattleStatus.prototype.constructor = Window_SrpgBattleStatus;\\r\\n\\r\\n    Window_SrpgBattleStatus.prototype.initialize = function(pos) {\\r\\n        var width = this.windowWidth();\\r\\n        var height = this.windowHeight();\\r\\n        var x = 0 + width * pos;\\r\\n        var y = Graphics.boxHeight - height;\\r\\n        this._type = null;\\r\\n        this._battler = null;\\r\\n        this._reserveHp = null;\\r\\n        this._reserveMp = null;\\r\\n        this._reserveTp = null;\\r\\n        this._changeHp = 0;\\r\\n        this._changeMp = 0;\\r\\n        this._changeTp = 0;\\r\\n        Window_Base.prototype.initialize.call(this, x, y, width, height);\\r\\n        this.refresh();\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattleStatus.prototype.windowWidth = function() {\\r\\n        return Graphics.boxWidth / 2;\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattleStatus.prototype.windowHeight = function() {\\r\\n        return this.fittingHeight(4);\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattleStatus.prototype.update = function() {\\r\\n        Window_Base.prototype.update.call(this);\\r\\n        this.updateData();\\r\\n    };\\r\\n\\r\\n\\r\\n    Window_SrpgBattleStatus.prototype.updateData = function() {\\r\\n        if (!this._type || !this._battler) {\\r\\n            return;\\r\\n        }\\r\\n        if (this._changeHp > 0 || this._changeMp > 0 || this._changeTp > 0) {\\r\\n            this.refresh();\\r\\n        }\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattleStatus.prototype.setBattler = function(battler) {\\r\\n        if (battler.isActor() == true) {\\r\\n            this._type = 'actor';\\r\\n        } else if (battler.isEnemy() == true) {\\r\\n            this._type = 'enemy';\\r\\n        }\\r\\n        this._battler = battler;\\r\\n        this._reserveHp = battler.hp;\\r\\n        this._reserveMp = battler.mp;\\r\\n        this._reserveTp = battler.tp;\\r\\n        this._changeHp = 1;\\r\\n        this._changeMp = 1;\\r\\n        this._changeTp = 1;\\r\\n        this.refresh();\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattleStatus.prototype.refresh = function() {\\r\\n        this.contents.clear();\\r\\n        if (!this._battler) {\\r\\n          return;\\r\\n        }\\r\\n        if (this._changeHp <= 0 && this._reserveHp != this._battler.hp) {\\r\\n            this._changeHp = 20;\\r\\n        }\\r\\n        if (this._changeMp <= 0 && this._reserveMp != this._battler.mp) {\\r\\n            this._changeMp = 20;\\r\\n        }\\r\\n        if (this._changeTp <= 0 && this._reserveTp != this._battler.tp) {\\r\\n            this._changeTp = 20;\\r\\n        }\\r\\n        if (this._type === 'actor') {\\r\\n            this.drawContentsActor();\\r\\n        } else if (this._type === 'enemy') {\\r\\n            this.drawContentsEnemy();\\r\\n        }\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattleStatus.prototype.drawContentsActor = function() {\\r\\n        var lineHeight = this.lineHeight();\\r\\n        this.drawActorName(this._battler, 176, lineHeight * 0);\\r\\n        this.drawActorFace(this._battler, 6, lineHeight * 0);\\r\\n        this.drawBasicInfoActor(176, lineHeight * 1);\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattleStatus.prototype.drawContentsEnemy = function() {\\r\\n        var lineHeight = this.lineHeight();\\r\\n        this.drawActorName(this._battler, 176, lineHeight * 0);\\r\\n        this.drawEnemyFace(this._battler, 6, lineHeight * 0);\\r\\n        this.drawBasicInfoEnemy(176, lineHeight * 1);\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattleStatus.prototype.drawBasicInfoActor = function(x, y) {\\r\\n        var lineHeight = this.lineHeight();\\r\\n        this.drawActorIcons(this._battler, x, y + lineHeight * 0);\\r\\n        this.drawActorHp(this._battler, x, y + lineHeight * 1);\\r\\n        if ($dataSystem.optDisplayTp) {\\r\\n            this.drawActorMp(this._battler, x, y + lineHeight * 2, 90);\\r\\n            this.drawActorTp(this._battler, x + 96, y + lineHeight * 2, 90);\\r\\n        } else {\\r\\n            this.drawActorMp(this._battler, x, y + lineHeight * 2);\\r\\n        }\\r\\n\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattleStatus.prototype.drawBasicInfoEnemy = function(x, y) {\\r\\n        var lineHeight = this.lineHeight();\\r\\n        this.drawActorIcons(this._battler, x, y + lineHeight * 0);\\r\\n        this.drawActorHp(this._battler, x, y + lineHeight * 1);\\r\\n        if ($dataSystem.optDisplayTp) {\\r\\n            this.drawActorMp(this._battler, x, y + lineHeight * 2, 90);\\r\\n            this.drawActorTp(this._battler, x + 96, y + lineHeight * 2, 90);\\r\\n        } else {\\r\\n            this.drawActorMp(this._battler, x, y + lineHeight * 2);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattleStatus.prototype.drawActorHp = function(actor, x, y, width) {\\r\\n        width = width || 186;\\r\\n        var color1 = this.hpGaugeColor1();\\r\\n        var color2 = this.hpGaugeColor2();\\r\\n        var nowHp = Math.floor(actor.hp + (this._reserveHp - actor.hp) / 20 * (this._changeHp - 1));\\r\\n        var rate = nowHp / actor.mhp;\\r\\n        this.drawGauge(x, y, width, rate, color1, color2);\\r\\n        this.changeTextColor(this.systemColor());\\r\\n        this.drawText(TextManager.hpA, x, y, 44);\\r\\n        this.drawCurrentAndMax(nowHp, actor.mhp, x, y, width,\\r\\n                               this.hpColor(actor), this.normalColor());\\r\\n        this._changeHp -= 1;\\r\\n        if (this._changeHp <= 0) {\\r\\n            this._reserveHp = actor.hp;\\r\\n        }\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattleStatus.prototype.drawActorMp = function(actor, x, y, width) {\\r\\n        width = width || 186;\\r\\n        var color1 = this.mpGaugeColor1();\\r\\n        var color2 = this.mpGaugeColor2();\\r\\n        var nowMp = Math.floor(actor.mp + (this._reserveMp - actor.mp) / 20 * (this._changeMp - 1));\\r\\n        if (actor.mmp == 0) {\\r\\n            var rate = 0;\\r\\n        } else {\\r\\n            var rate = nowMp / actor.mmp;\\r\\n        }\\r\\n        this.drawGauge(x, y, width, rate, color1, color2);\\r\\n        this.changeTextColor(this.systemColor());\\r\\n        this.drawText(TextManager.mpA, x, y, 44);\\r\\n        this.drawCurrentAndMax(nowMp, actor.mmp, x, y, width,\\r\\n                               this.mpColor(actor), this.normalColor());\\r\\n        this._changeMp -= 1;\\r\\n        if (this._changeMp <= 0) {\\r\\n            this._reserveMp = actor.mp;\\r\\n        }\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattleStatus.prototype.drawActorTp = function(actor, x, y, width) {\\r\\n        width = width || 96;\\r\\n        var color1 = this.tpGaugeColor1();\\r\\n        var color2 = this.tpGaugeColor2();\\r\\n        var nowTp = Math.floor(actor.tp + (this._reserveTp - actor.tp) / 20 * (this._changeTp - 1));\\r\\n        var rate = nowTp / actor.maxTp();\\r\\n        this.drawGauge(x, y, width, rate, color1, color2);\\r\\n        this.changeTextColor(this.systemColor());\\r\\n        this.drawText(TextManager.tpA, x, y, 44);\\r\\n        this.changeTextColor(this.tpColor(actor));\\r\\n        this.drawText(nowTp, x + width - 64, y, 64, 'right');\\r\\n        this._changeTp -= 1;\\r\\n        if (this._changeTp <= 0) {\\r\\n            this._reserveTp = actor.tp;\\r\\n        }\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// ●Window_SrpgBattleResult\\r\\n//====================================================================\\r\\n    function Window_SrpgBattleResult() {\\r\\n        this.initialize.apply(this, arguments);\\r\\n    }\\r\\n\\r\\n    Window_SrpgBattleResult.prototype = Object.create(Window_Base.prototype);\\r\\n    Window_SrpgBattleResult.prototype.constructor = Window_SrpgBattleResult;\\r\\n\\r\\n    Window_SrpgBattleResult.prototype.initialize = function(battler) {\\r\\n        var width = this.windowWidth();\\r\\n        var height = this.windowHeight();\\r\\n        var x = (Graphics.boxWidth - width) / 2;\\r\\n        var y = Graphics.boxHeight / 2 - height;\\r\\n        this._battler = battler;\\r\\n        this._reserveExp = this._battler.currentExp();\\r\\n        this._level = this._battler.level;\\r\\n        this._rewards = null;\\r\\n        this._changeExp = 0;\\r\\n        Window_Base.prototype.initialize.call(this, x, y, width, height);\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattleResult.prototype.windowWidth = function() {\\r\\n        return Graphics.boxWidth - 300;\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattleResult.prototype.windowHeight = function() {\\r\\n        return this.fittingHeight(4);\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattleResult.prototype.isChangeExp = function() {\\r\\n        return this._changeExp > 0;\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattleResult.prototype.update = function() {\\r\\n        Window_Base.prototype.update.call(this);\\r\\n        this.updateData();\\r\\n    };\\r\\n\\r\\n\\r\\n    Window_SrpgBattleResult.prototype.updateData = function() {\\r\\n        if (!this._battler) {\\r\\n            return;\\r\\n        }\\r\\n        if (this._changeExp > 0) {\\r\\n            this.refresh();\\r\\n        }\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattleResult.prototype.setRewards = function(rewards) {\\r\\n        this._rewards = rewards;\\r\\n        this._changeExp = 30;\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattleResult.prototype.refresh = function() {\\r\\n        this.contents.clear();\\r\\n        this.drawContents();\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattleResult.prototype.drawContents = function() {\\r\\n        var lineHeight = this.lineHeight();\\r\\n        this.drawGainExp(6, lineHeight * 0);\\r\\n        this.drawGainGold(6, lineHeight * 2);\\r\\n        this.drawGainItem(0, lineHeight * 3);\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattleResult.prototype.drawGainExp = function(x, y) {\\r\\n        var lineHeight = this.lineHeight();\\r\\n        var exp = this._rewards.exp;\\r\\n        var width = this.windowWidth() - this.padding * 2;\\r\\n        if (exp > 0) {\\r\\n            var text = TextManager.obtainExp.format(exp, TextManager.exp);\\r\\n            this.resetTextColor();\\r\\n            this.drawText(text, x, y, width);\\r\\n        } else {\\r\\n            this._changeExp = 1;\\r\\n        }\\r\\n        var color1 = this.hpGaugeColor1();\\r\\n        var color2 = this.hpGaugeColor2();\\r\\n        var nowExp = Math.floor(this._reserveExp + exp / 30 * (31 - this._changeExp));\\r\\n        if (nowExp >= this._battler.expForLevel(this._level + 1)) {\\r\\n            this._level += 1;\\r\\n            var se = {};\\r\\n            se.name = 'Up4';\\r\\n            se.pan = 0;\\r\\n            se.pitch = 100;\\r\\n            se.volume = 90;\\r\\n            AudioManager.playSe(se);\\r\\n        }\\r\\n        if (this._level >= this._battler.maxLevel()) {\\r\\n            var rate = 1.0;\\r\\n            var nextExp = '-------'\\r\\n        } else {\\r\\n            var rate = (nowExp - this._battler.expForLevel(this._level)) / \\r\\n                       (this._battler.expForLevel(this._level + 1) - this._battler.expForLevel(this._level));\\r\\n            var nextExp = this._battler.expForLevel(this._level + 1) - nowExp;\\r\\n        }\\r\\n        this.drawGauge(x + 100, y + lineHeight, width - 100, rate, color1, color2);\\r\\n        this.changeTextColor(this.systemColor());\\r\\n        this.drawText(TextManager.levelA, x, y + lineHeight, 48);\\r\\n        this.resetTextColor();\\r\\n        this.drawText(this._level, x + 48, y + lineHeight, 36, 'right');\\r\\n        var expNext = TextManager.expNext.format(TextManager.level);\\r\\n        this.drawText(expNext, width - 270, y + lineHeight, 270);\\r\\n        this.drawText(nextExp, width - 270, y + lineHeight, 270, 'right');\\r\\n        this._changeExp -= 1;\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattleResult.prototype.drawGainGold = function(x, y) {\\r\\n        var gold = this._rewards.gold;\\r\\n        var width = (this.windowWidth() - this.padding * 2) / 2;\\r\\n        if (gold > 0) {\\r\\n            var unitWidth = Math.min(80, this.textWidth(TextManager.currencyUnit));\\r\\n            this.resetTextColor();\\r\\n            this.drawText(gold, x, y, width - unitWidth - 6);\\r\\n            this.changeTextColor(this.systemColor());\\r\\n            this.drawText(TextManager.currencyUnit, x + this.textWidth(gold) + 6, y, unitWidth);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    Window_SrpgBattleResult.prototype.drawGainItem = function(x, y) {\\r\\n        var items = this._rewards.items;\\r\\n        if (items.length > 1) {\\r\\n            var width = (this.windowWidth() - this.padding * 2) / 2;\\r\\n        } else {\\r\\n            var width = this.windowWidth() - this.padding * 2;\\r\\n        }\\r\\n        if (items.length > 0) {\\r\\n            for (var i = 0; i < items.length; i++) {\\r\\n                this.drawItemName(items[i], x + width * Math.floor(0.5 + i * 0.5), y - this.lineHeight() * (i % 2), width);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n//====================================================================\\r\\n// ●Window_SrpgPrediction\\r\\n//====================================================================\\r\\n    function Window_SrpgPrediction() {\\r\\n        this.initialize.apply(this, arguments);\\r\\n    }\\r\\n\\r\\n    Window_SrpgPrediction.prototype = Object.create(Window_Base.prototype);\\r\\n    Window_SrpgPrediction.prototype.constructor = Window_SrpgPrediction;\\r\\n\\r\\n    Window_SrpgPrediction.prototype.initialize = function(x, y) {\\r\\n        var width = this.windowWidth();\\r\\n        var height = this.windowHeight();\\r\\n        this._actionArray = [];\\r\\n        this._targetArray = [];\\r\\n        Window_Base.prototype.initialize.call(this, x, y, width, height);\\r\\n        this.refresh();\\r\\n    };\\r\\n\\r\\n    Window_SrpgPrediction.prototype.windowWidth = function() {\\r\\n        return Graphics.boxWidth;\\r\\n    };\\r\\n\\r\\n    Window_SrpgPrediction.prototype.windowHeight = function() {\\r\\n        if (_srpgPredictionWindowMode === 2) {\\r\\n            return this.fittingHeight(1);\\r\\n        } else {\\r\\n            return this.fittingHeight(3);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    Window_SrpgPrediction.prototype.setBattler = function(data1, data2) {\\r\\n        this._actionArray = data1;\\r\\n        this._targetArray = data2;\\r\\n        this.refresh();\\r\\n    };\\r\\n\\r\\n    Window_SrpgPrediction.prototype.clearBattler = function() {\\r\\n        this._actionArray = [];\\r\\n        this._targetArray = [];\\r\\n        this.refresh();\\r\\n    };\\r\\n\\r\\n    Window_SrpgPrediction.prototype.refresh = function() {\\r\\n        this.contents.clear();\\r\\n        if (!this._actionArray[1] || !this._targetArray[1]) {\\r\\n          return;\\r\\n        }\\r\\n        //this.setTargetAction();\\r\\n        this.drawContents();\\r\\n    };\\r\\n\\r\\n    Window_SrpgPrediction.prototype.setTargetAction = function() {\\r\\n        $gameParty.clearSrpgBattleActors();\\r\\n        $gameTroop.clearSrpgBattleEnemys();\\r\\n        $gameTroop.clear();\\r\\n        if (this._actionArray[0] === 'actor') {\\r\\n            $gameParty.pushSrpgBattleActors(this._actionArray[1]);\\r\\n            if (this._targetArray[0] === 'actor') {\\r\\n                if (this._actionArray[1] != this._targetArray[1]) {\\r\\n                    $gameParty.pushSrpgBattleActors(this._targetArray[1]);\\r\\n                    this._actionArray[1].action(0).setTarget(1);\\r\\n                } else {\\r\\n                    this._actionArray[1].action(0).setTarget(0);\\r\\n                }\\r\\n            } else if (this._targetArray[0] === 'enemy') {\\r\\n                $gameTroop.pushSrpgBattleEnemys(this._targetArray[1]);\\r\\n                this._actionArray[1].action(0).setTarget(0);\\r\\n            }\\r\\n        } else if (this._actionArray[0] === 'enemy') {\\r\\n            $gameTroop.pushSrpgBattleEnemys(this._actionArray[1]);\\r\\n            this._actionArray[1].action(0).setSrpgEnemySubject(0);\\r\\n            if (this._targetArray[0] === 'actor') {\\r\\n                $gameParty.pushSrpgBattleActors(this._targetArray[1]);\\r\\n                this._actionArray[1].action(0).setTarget(0);\\r\\n            } else if (this._targetArray[0] === 'enemy') {\\r\\n                if (this._actionArray[1] != this._targetArray[1]) {\\r\\n                    $gameTroop.pushSrpgBattleEnemys(this._targetArray[1]);\\r\\n                    this._actionArray[1].action(0).setTarget(1);\\r\\n                } else {\\r\\n                    this._actionArray[1].action(0).setTarget(0);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        //対象の行動を設定\\r\\n        if (this._actionArray[1] != this._targetArray[1]) {\\r\\n            this._targetArray[1].srpgMakeNewActions();\\r\\n            if (this._actionArray[0] === 'actor' && this._targetArray[0] === 'enemy' &&\\r\\n                this._targetArray[1].canMove()) {\\r\\n                $gameTroop.pushMembers(this._targetArray[1]);\\r\\n                this._targetArray[1].action(0).setSrpgEnemySubject(0);\\r\\n                this._targetArray[1].action(0).setAttack();\\r\\n                this._targetArray[1].action(0).setTarget(0);\\r\\n            }\\r\\n            if (this._actionArray[0] === 'enemy' && this._targetArray[0] === 'actor' &&\\r\\n                this._targetArray[1].canMove()) {\\r\\n                this._targetArray[1].action(0).setAttack();\\r\\n                this._targetArray[1].action(0).setTarget(0);\\r\\n            }\\r\\n        }\\r\\n    };\\r\\n\\r\\n    Window_SrpgPrediction.prototype.drawContents = function() {\\r\\n        var windowWidth = this.windowWidth();\\r\\n        var lineHeight = this.lineHeight();\\r\\n        var x = 40;\\r\\n        // 攻撃側\\r\\n\\r\\n\\t\\t\\r\\n        this.drawSrpgBattleActionName($gameTemp.actorAction, windowWidth / 2 + x, lineHeight * 0);\\r\\n        this.drawSrpgBattleHit($battleCalc.getActorFinalHit(), windowWidth / 2 + x, lineHeight * 1);\\r\\n       // this.drawSrpgBattleDistance(actor, action, windowWidth / 2 + 160 + x, lineHeight * 1);\\r\\n       // this.drawSrpgBattleDamage(damage, windowWidth / 2 + x, lineHeight * 2);\\r\\n        // 迎撃側\\r\\n       /* var actor = this._targetArray[1];\\r\\n        var target = this._actionArray[1];\\r\\n        var action = actor.currentAction();\\r\\n        if (!this._targetArray[1].canUse(action.item())) {\\r\\n            action = null;\\r\\n        }\\r\\n        if (!action || actor == target) {\\r\\n            this.drawSrpgBattleActionName(actor, action, x, lineHeight * 0, false);\\r\\n            return;\\r\\n        }\\r\\n    */\\r\\n\\t\\tthis.drawSrpgBattleActionName($gameTemp.enemyAction, x, lineHeight * 0);\\r\\n        this.drawSrpgBattleHit($battleCalc.getEnemyFinalHit(), x, lineHeight * 1);\\r\\n       // this.drawSrpgBattleDistance(actor, action, 160 + x, lineHeight * 1);\\r\\n        //this.drawSrpgBattleDamage(damage, x, lineHeight * 2);\\r\\n       // this._targetArray[1].clearActions();\\r\\n\\t\\t\\r\\n    };\\r\\n\\r\\n    Window_SrpgPrediction.prototype.drawSrpgBattleActionName = function(actionDef, x, y) {\\r\\n        /*if (action && flag == true) {\\r\\n            var skill = action.item();\\r\\n            if (skill) {\\r\\n                var costWidth = this.costWidth();\\r\\n                this.changePaintOpacity(this.isEnabled(actor, skill));\\r\\n                if (DataManager.isSkill(skill) && skill.id == actor.attackSkillId() &&\\r\\n                    !actor.hasNoWeapons()) {\\r\\n                    if (actor.isActor()) {\\r\\n                        var item = actor.weapons()[0];\\r\\n                    } else {\\r\\n                        var item = $dataWeapons[actor.enemy().meta.srpgWeapon];\\r\\n                    }\\r\\n                    this.drawItemName(item, x, y, 280 - costWidth);\\r\\n                } else {\\r\\n                    this.drawItemName(skill, x, y, 280 - costWidth);\\r\\n                }\\r\\n                this.drawSkillCost(actor, skill, x, y, 288);\\r\\n                this.changePaintOpacity(1);\\r\\n            } else {\\r\\n                this.drawText('------------', x + 52, y, 96, 'right');\\r\\n            }\\r\\n        } else {\\r\\n            this.drawText('------------', x + 52, y, 96, 'right');\\r\\n        }*/\\r\\n\\t\\tif(actionDef.type === \\\"attack\\\"){\\t\\t\\t\\r\\n\\t\\t\\tthis.drawText(actionDef.attack.name, x + 52, y, 96, 'right');\\r\\n\\t\\t} else if(actionDef.type === \\\"evade\\\"){\\r\\n\\t\\t\\tthis.drawText('Evade', x + 52, y, 96, 'right');\\r\\n\\t\\t} else if(actionDef.type === \\\"defend\\\"){\\r\\n\\t\\t\\tthis.drawText('Defend', x + 52, y, 96, 'right');\\r\\n\\t\\t}\\r\\n    };\\r\\n\\r\\n    Window_SrpgPrediction.prototype.drawSrpgBattleDistance = function(actor, action, x, y) {\\r\\n        var skill = action.item();\\r\\n        this.changeTextColor(this.systemColor());\\r\\n        this.drawText(_textSrpgRange, x, y, 98);\\r\\n        this.resetTextColor();\\r\\n        var text = '';\\r\\n        if (actor.srpgSkillMinRange(skill) > 0) {\\r\\n            text += actor.srpgSkillMinRange(skill) + '-';\\r\\n        }\\r\\n        text += actor.srpgSkillRange(skill);\\r\\n        this.drawText(text, x + 32, y, 96, 'right');\\r\\n    };\\r\\n\\r\\n    Window_SrpgPrediction.prototype.drawSrpgBattleDamage = function(damage, x, y) {\\r\\n        this.changeTextColor(this.systemColor());\\r\\n        if (damage >= 0) {\\r\\n// Japanese Term \\\"ダメージ\\\"\\r\\n            this.drawText('Damage', x, y, 164);\\r\\n            this.resetTextColor();\\r\\n            this.drawText(damage, x + 188, y, 100, 'right');\\r\\n        } else {\\r\\n// Japanese Term \\\"回復\\\"\\r\\n            this.drawText('Recovery', x, y, 164);\\r\\n            this.resetTextColor();\\r\\n            this.drawText(damage * -1, x + 188, y, 100, 'right');\\r\\n        }\\r\\n    };\\r\\n\\r\\n    Window_SrpgPrediction.prototype.drawSrpgBattleHit = function(finalHit, x, y) {\\r\\n        var val = finalHit;\\r\\n        this.changeTextColor(this.systemColor());\\r\\n// Japanese Term \\\"回復\\\"\\r\\n        this.drawText('Hit', x, y, 98);\\r\\n        this.resetTextColor();\\r\\n        this.drawText(Math.floor(val * 100) + '%', x + 64, y, 64, 'right');\\r\\n    };\\r\\n\\r\\n    Window_SrpgPrediction.prototype.costWidth = function() {\\r\\n        return this.textWidth('000');\\r\\n    };\\r\\n\\r\\n    Window_SrpgPrediction.prototype.drawSkillCost = function(actor, skill, x, y, width) {\\r\\n        if (actor.skillTpCost(skill) > 0) {\\r\\n            this.changeTextColor(this.tpCostColor());\\r\\n            this.drawText(actor.skillTpCost(skill), x, y, width, 'right');\\r\\n        } else if (actor.skillMpCost(skill) > 0) {\\r\\n            this.changeTextColor(this.mpCostColor());\\r\\n            this.drawText(actor.skillMpCost(skill), x, y, width, 'right');\\r\\n        }\\r\\n    };\\r\\n\\r\\n    Window_SrpgPrediction.prototype.isEnabled = function(actor, item) {\\r\\n        return actor && actor.canUse(item);\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// ●Window_ActorCommand\\r\\n//====================================================================\\r\\n    Window_Command.prototype.isList = function() {\\r\\n        if (this._list) {\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    };\\r\\n\\r\\n    var _SRPG_Window_ActorCommand_numVisibleRows = Window_ActorCommand.prototype.numVisibleRows;\\r\\n    Window_ActorCommand.prototype.numVisibleRows = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            if (this.isList()) {\\r\\n                return this.maxItems();\\r\\n            } else {\\r\\n                return 0;\\r\\n            }\\r\\n        } else {\\r\\n            return _SRPG_Window_ActorCommand_numVisibleRows.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    var _SRPG_Window_ActorCommand_makeCommandList = Window_ActorCommand.prototype.makeCommandList;\\r\\n    Window_ActorCommand.prototype.makeCommandList = function() {\\r\\n\\t\\tvar _this = this;\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            if (this._actor) {\\r\\n\\t\\t\\t\\t//TODO: turn different menus into subclasses\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tvar battler = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n\\t\\t\\t\\tvar type = battler.isActor() ? \\\"enemy\\\" : \\\"actor\\\";\\r\\n\\t\\t\\t\\tvar pos = {\\r\\n\\t\\t\\t\\t\\tx: $gameTemp.activeEvent().posX(),\\r\\n\\t\\t\\t\\t\\ty: $gameTemp.activeEvent().posY()\\r\\n\\t\\t\\t\\t};\\r\\n\\t\\t\\t\\tvar fullRange = $statCalc.getFullWeaponRange(battler, $gameTemp.isPostMove);\\r\\n\\t\\t\\t\\tvar hasTarget = $statCalc.getAllInRange($gameSystem.getPlayerFactionInfo(), pos, fullRange.range, fullRange.minRange).length > 0;\\r\\n\\t\\t\\t\\tvar hasMapWeapon = $statCalc.hasMapWeapon(battler);\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tfunction boardingMenu(){\\r\\n\\t\\t\\t\\t\\t_this.addCommand(APPSTRINGS.MAPMENU.board, 'board');\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tfunction regularMenu(){\\r\\n\\t\\t\\t\\t\\tif(_this._actor.battleMode() != \\\"fixed\\\"){\\r\\n\\t\\t\\t\\t\\t\\t_this.addMoveCommand();\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tif(hasTarget || hasMapWeapon){\\r\\n\\t\\t\\t\\t\\t\\t_this.addCommand(APPSTRINGS.MAPMENU.cmd_attack, 'attack');\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tif($statCalc.isShip(_this._actor) && $statCalc.hasBoardedUnits(_this._actor)){\\r\\n\\t\\t\\t\\t\\t\\t_this.addCommand(APPSTRINGS.MAPMENU.deploy, 'deploy');\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t_this.addCommand(APPSTRINGS.MAPMENU.cmd_spirit, 'spirit');\\r\\n\\t\\t\\t\\t\\tif($statCalc.applyStatModsToValue(_this._actor, 0, [\\\"heal\\\"])){\\r\\n\\t\\t\\t\\t\\t\\t_this.addCommand(APPSTRINGS.MAPMENU.cmd_repair, 'heal');\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tif($statCalc.applyStatModsToValue(_this._actor, 0, [\\\"resupply\\\"])){\\r\\n\\t\\t\\t\\t\\t\\t_this.addCommand(APPSTRINGS.MAPMENU.cmd_resupply, 'resupply');\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tif($statCalc.getConsumables(_this._actor).length){\\r\\n\\t\\t\\t\\t\\t\\t _this.addCommand(APPSTRINGS.MAPMENU.cmd_item, 'item');\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tif($statCalc.getAbilityCommands(_this._actor).length){\\r\\n\\t\\t\\t\\t\\t\\t _this.addCommand(APPSTRINGS.MAPMENU.cmd_ability, 'ability');\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tif($statCalc.canFly(_this._actor) && $statCalc.getCurrentTerrain(_this._actor) != \\\"space\\\"){\\r\\n\\t\\t\\t\\t\\t\\tif($statCalc.isFlying(_this._actor)){\\r\\n\\t\\t\\t\\t\\t\\t\\tif(($statCalc.getTileType(_this._actor) == \\\"land\\\" && $statCalc.canBeOnLand(_this._actor)) || ($statCalc.getTileType(_this._actor) == \\\"water\\\" && $statCalc.canBeOnWater(_this._actor))){\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t_this.addCommand(APPSTRINGS.MAPMENU.cmd_land, 'land');\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\t\\t_this.addCommand(APPSTRINGS.MAPMENU.cmd_fly, 'fly');\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\r\\n\\t\\t\\t\\t\\tif($gameSystem.getPersuadeOption(_this._actor)){\\r\\n\\t\\t\\t\\t\\t\\t_this.addCommand(APPSTRINGS.MAPMENU.cmd_persuade, 'persuade');\\r\\n\\t\\t\\t\\t\\t}\\t\\r\\n\\t\\t\\t\\t\\tif($statCalc.canCombine(_this._actor).isValid){\\r\\n\\t\\t\\t\\t\\t\\t_this.addCommand(APPSTRINGS.MAPMENU.cmd_combine, 'combine');\\r\\n\\t\\t\\t\\t\\t}\\t\\r\\n\\t\\t\\t\\t\\tif($statCalc.isCombined(_this._actor)){\\r\\n\\t\\t\\t\\t\\t\\t_this.addCommand(APPSTRINGS.MAPMENU.cmd_split, 'split');\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tif(ENGINE_SETTINGS.ENABLE_TWIN_SYSTEM && !ENGINE_SETTINGS.DISABLE_ALLY_TWINS){\\r\\n\\t\\t\\t\\t\\t\\tif(!$statCalc.isShip(_this._actor) && $statCalc.canSwap(_this._actor)){\\r\\n\\t\\t\\t\\t\\t\\t\\t_this.addCommand(APPSTRINGS.MAPMENU.cmd_swap, 'swap');\\r\\n\\t\\t\\t\\t\\t\\t}\\t\\r\\n\\t\\t\\t\\t\\t\\tif(!$statCalc.isShip(_this._actor) && $statCalc.isMainTwin(_this._actor)){\\r\\n\\t\\t\\t\\t\\t\\t\\t_this.addCommand(APPSTRINGS.MAPMENU.cmd_separate, 'separate');\\r\\n\\t\\t\\t\\t\\t\\t}\\t\\r\\n\\t\\t\\t\\t\\t\\tif(!$statCalc.isShip(_this._actor) && $statCalc.canTwin(_this._actor)){\\r\\n\\t\\t\\t\\t\\t\\t\\t_this.addCommand(APPSTRINGS.MAPMENU.cmd_join, 'join');\\r\\n\\t\\t\\t\\t\\t\\t}\\t\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tif($statCalc.canTransform(_this._actor)){\\r\\n\\t\\t\\t\\t\\t\\t_this.addCommand(APPSTRINGS.MAPMENU.cmd_transform, 'transform');\\r\\n\\t\\t\\t\\t\\t}\\t\\r\\n\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t_this.addWaitCommand();\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tfunction hitAndAwayMenu(){\\r\\n\\t\\t\\t\\t\\t_this.addMoveCommand();\\r\\n\\t\\t\\t\\t\\t_this.addWaitCommand();\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tfunction disabledMenu(){\\r\\n\\t\\t\\t\\t\\t_this.addWaitCommand();\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tfunction postMoveMenu(){\\r\\n\\t\\t\\t\\t\\tif(hasTarget || hasMapWeapon){\\r\\n\\t\\t\\t\\t\\t\\t_this.addCommand(APPSTRINGS.MAPMENU.cmd_attack, 'attack');\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tif($gameSystem.getPersuadeOption(_this._actor)){\\r\\n\\t\\t\\t\\t\\t\\t_this.addCommand(APPSTRINGS.MAPMENU.cmd_persuade, 'persuade');\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tif($statCalc.applyStatModsToValue(_this._actor, 0, [\\\"heal\\\"])){\\r\\n\\t\\t\\t\\t\\t\\t_this.addCommand(APPSTRINGS.MAPMENU.cmd_repair, 'heal');\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tif(ENGINE_SETTINGS.ENABLE_TWIN_SYSTEM && !ENGINE_SETTINGS.DISABLE_ALLY_TWINS){\\r\\n\\t\\t\\t\\t\\t\\tif($statCalc.canTwin(_this._actor)){\\r\\n\\t\\t\\t\\t\\t\\t\\t_this.addCommand(APPSTRINGS.MAPMENU.cmd_join, 'join');\\r\\n\\t\\t\\t\\t\\t\\t}\\t\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t_this.addWaitCommand();\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tfunction deployMenu(){\\r\\n\\t\\t\\t\\t\\t_this.addMoveCommand();\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t_this.addCommand(APPSTRINGS.MAPMENU.cmd_spirit, 'spirit');\\r\\n\\t\\t\\t\\t\\tif($statCalc.canFly(_this._actor) && $statCalc.getCurrentTerrain(_this._actor) != \\\"space\\\"){\\r\\n\\t\\t\\t\\t\\t\\tif($statCalc.isFlying(_this._actor)){\\r\\n\\t\\t\\t\\t\\t\\t\\t_this.addCommand(APPSTRINGS.MAPMENU.cmd_land, 'land');\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\t\\t_this.addCommand(APPSTRINGS.MAPMENU.cmd_fly, 'fly');\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tif($statCalc.getConsumables(_this._actor).length){\\r\\n\\t\\t\\t\\t\\t\\t _this.addCommand(APPSTRINGS.MAPMENU.cmd_item, 'item');\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tif($gameSystem.isSubBattlePhase() == 'confirm_boarding'){\\r\\n\\t\\t\\t\\t\\tboardingMenu();\\r\\n\\t\\t\\t\\t} else if($gameTemp.isHitAndAway){\\r\\n\\t\\t\\t\\t\\thitAndAwayMenu();\\r\\n\\t\\t\\t\\t} else if($gameTemp.isPostMove){\\r\\n\\t\\t\\t\\t\\tpostMoveMenu();\\r\\n\\t\\t\\t\\t} else if($gameTemp.activeShip){\\r\\n\\t\\t\\t\\t\\tdeployMenu();\\r\\n\\t\\t\\t\\t} else if(this._actor.battleMode() == \\\"disabled\\\"){\\r\\n\\t\\t\\t\\t\\tdisabledMenu();\\r\\n\\t\\t\\t\\t} else {\\t\\r\\n\\t\\t\\t\\t\\tregularMenu();\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n            }\\r\\n        } else {\\r\\n            _SRPG_Window_ActorCommand_makeCommandList.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    Window_ActorCommand.prototype.addEquipCommand = function() {\\r\\n        this.addCommand(_textSrpgEquip, 'equip', this._actor.canSrpgEquip());\\r\\n    };\\r\\n\\r\\n    Window_ActorCommand.prototype.addWaitCommand = function() {\\r\\n        this.addCommand(APPSTRINGS.MAPMENU.cmd_wait, 'wait');\\r\\n    };\\r\\n\\t\\r\\n\\tWindow_ActorCommand.prototype.addMoveCommand = function() {\\r\\n        this.addCommand(APPSTRINGS.MAPMENU.cmd_move, 'move');\\r\\n    };\\r\\n\\r\\n    var _SRPG_Window_ActorCommand_setup = Window_ActorCommand.prototype.setup;\\r\\n    Window_ActorCommand.prototype.setup = function(actor) {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            this._actor = actor;\\r\\n            this.clearCommandList();\\r\\n            this.makeCommandList();\\r\\n            this.updatePlacement();\\r\\n            this.refresh();\\r\\n            this.selectLast();\\r\\n            this.activate();\\r\\n            this.open();\\r\\n        } else {\\r\\n            _SRPG_Window_ActorCommand_setup.call(this, actor);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    Window_ActorCommand.prototype.updatePlacement = function() {\\r\\n        this.width = this.windowWidth();\\r\\n        this.height = this.windowHeight();\\r\\n        this.x = Math.max($gameTemp.activeEvent().screenX() - $gameMap.tileWidth() / 2 - this.windowWidth(), 0);\\r\\n        if ($gameTemp.activeEvent().screenY() < Graphics.boxHeight - 160) {\\r\\n            var eventY = $gameTemp.activeEvent().screenY();\\r\\n        } else {\\r\\n            var eventY = Graphics.boxHeight - 160;\\r\\n        }\\r\\n        this.y = Math.max(eventY - this.windowHeight(), 0);\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// ●Window_SrpgBattle\\r\\n//====================================================================\\r\\n    function Window_SrpgBattle() {\\r\\n        this.initialize.apply(this, arguments);\\r\\n    }\\r\\n\\r\\n    Window_SrpgBattle.prototype = Object.create(Window_HorzCommand.prototype);\\r\\n    Window_SrpgBattle.prototype.constructor = Window_SrpgBattle;\\r\\n\\r\\n    Window_SrpgBattle.prototype.initialize = function() {\\r\\n        Window_HorzCommand.prototype.initialize.call(this, 0, 0);\\r\\n        this._actor = null;\\r\\n        this._item = null;\\r\\n        this.openness = 0;\\r\\n        this.deactivate();\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattle.prototype.windowWidth = function() {\\r\\n        return 240;\\r\\n    };\\r\\n\\t\\r\\n\\tWindow_SrpgBattle.prototype.windowHeight = function() {\\r\\n        return this.fittingHeight(3);\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattle.prototype.maxCols = function() {\\r\\n        return 1;\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattle.prototype.makeCommandList = function() {\\r\\n// Japanese Term \\\"戦闘開始\\\"\\r\\n        this.addCommand('Execute', 'battleStart');\\r\\n\\t\\tif($gameTemp.isEnemyAttack){\\r\\n\\t\\t\\tif($gameTemp.actorAction.type === \\\"attack\\\"){\\r\\n\\t\\t\\t\\tthis.addCommand('Counter', 'selectCounterAction');\\r\\n\\t\\t\\t} else if($gameTemp.actorAction.type === \\\"defend\\\"){\\r\\n\\t\\t\\t\\tthis.addCommand('Defend', 'selectCounterAction');\\r\\n\\t\\t\\t} else if($gameTemp.actorAction.type === \\\"evade\\\"){\\r\\n\\t\\t\\t\\tthis.addCommand('Evade', 'selectCounterAction');\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\tthis.addCommand('Support', '');\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif($gameTemp.supportAttackCandidates && $gameTemp.supportAttackCandidates.length){\\r\\n\\t\\t\\t\\tthis.addCommand('Support', 'selectSupportAttack');\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthis.addCommand(TextManager.cancel, 'cancel');\\r\\n\\t\\t}        \\r\\n    };\\r\\n\\r\\n    Window_SrpgBattle.prototype.setup = function(actorArray) {\\r\\n        //this._actor = actorArray[1];\\r\\n       // this._item = actorArray[1].currentAction().item();\\r\\n        this.clearCommandList();\\r\\n        this.makeCommandList();\\r\\n        this.refresh();\\r\\n        this.activate();\\r\\n        this.open();\\r\\n    };\\r\\n\\r\\n    Window_SrpgBattle.prototype.clearActor = function() {\\r\\n        this._actor = null;\\r\\n        this._item = null;\\r\\n        this.clearCommandList();\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// ●Window_BattleLog\\r\\n//====================================================================\\r\\n    var _SRPG_Window_BattleLog_showEnemyAttackAnimation = Window_BattleLog.prototype.showEnemyAttackAnimation;\\r\\n    Window_BattleLog.prototype.showEnemyAttackAnimation = function(subject, targets) {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            this.showNormalAnimation(targets, subject.attackAnimationId(), false);\\r\\n        } else {\\r\\n            _SRPG_Window_BattleLog_showEnemyAttackAnimation.call(this, subject, targets);\\r\\n        }\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// ●Window_MenuStatus\\r\\n//====================================================================\\r\\n    var _SRPG_Window_MenuStatus_drawItemImage = Window_MenuStatus.prototype.drawItemImage;\\r\\n    Window_MenuStatus.prototype.drawItemImage = function(index) {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            var actor = $gameParty.members()[index];\\r\\n            var rect = this.itemRect(index);\\r\\n            if (actor.srpgTurnEnd() == true || actor.isRestricted() == true) {\\r\\n                this.changePaintOpacity(false);\\r\\n            } else {\\r\\n                this.changePaintOpacity(true);\\r\\n            }\\r\\n            this.drawActorFace(actor, rect.x + 1, rect.y + 1, Window_Base._faceWidth, Window_Base._faceHeight);\\r\\n        } else {\\r\\n            _SRPG_Window_MenuStatus_drawItemImage.call(this, index);\\r\\n        }\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// ●Window_MenuCommand\\r\\n//====================================================================\\r\\n    var _SRPG_Window_MenuCommand_makeCommandList = Window_MenuCommand.prototype.makeCommandList;\\r\\n    Window_MenuCommand.prototype.makeCommandList = function() {       \\r\\n          \\r\\n       // _SRPG_Window_MenuCommand_makeCommandList.call(this);\\r\\n\\t   \\r\\n\\t   if($gameSystem.isSRPGMode()){\\r\\n\\t\\t   this.addTurnEndCommand();     \\r\\n\\t\\t   this.addCommand(APPSTRINGS.MAPMENU.cmd_search, 'search', true);\\r\\n\\t\\t   this.addCommand(APPSTRINGS.MAPMENU.cmd_list, 'unitList', true);\\r\\n\\t\\t   this.addCommand(APPSTRINGS.MAPMENU.cmd_conditions, 'conditions', true);\\r\\n\\t   }\\r\\n\\t   \\r\\n\\t   this.addCommand(APPSTRINGS.MAPMENU.cmd_options, 'options');\\r\\n\\t   this.addCommand(APPSTRINGS.MAPMENU.cmd_save, 'save');\\r\\n\\t   this.addCommand(APPSTRINGS.MAPMENU.cmd_game_end, 'gameEnd');\\r\\n    };\\r\\n\\r\\n    Window_MenuCommand.prototype.addTurnEndCommand = function() {\\r\\n        this.addCommand(APPSTRINGS.MAPMENU.cmd_end_turn, 'turnEnd', true);\\r\\n    };\\r\\n\\r\\n    var _SRPG_Window_MenuCommand_isFormationEnabled = Window_MenuCommand.prototype.isFormationEnabled;\\r\\n    Window_MenuCommand.prototype.isFormationEnabled = function() {\\r\\n        /*if ($gameSystem.isSRPGMode() == true) {\\r\\n            return false;\\r\\n        } else {\\r\\n            return _SRPG_Window_MenuCommand_isFormationEnabled.call(this);\\r\\n        }*/\\r\\n\\t\\treturn false\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// ●Scene_Base\\r\\n//====================================================================\\r\\n    //SRPG戦闘中は無効化する\\r\\n    var _SRPG_Scene_Base_checkGameover = Scene_Base.prototype.checkGameover;\\r\\n    Scene_Base.prototype.checkGameover = function() {\\r\\n        if ($gameSystem.isSRPGMode() == false) {\\r\\n            _SRPG_Scene_Base_checkGameover.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// ●Scene_Map\\r\\n//====================================================================\\r\\n    // 初期化\\r\\n    var _SRPG_SceneMap_initialize = Scene_Map.prototype.initialize;\\r\\n    Scene_Map.prototype.initialize = function() {\\r\\n        _SRPG_SceneMap_initialize.call(this);\\r\\n        this._callSrpgBattle = false;\\r\\n\\t\\t//this._deathQueue = [];\\r\\n\\t\\tthis.idToMenu = {};\\r\\n\\t\\t$gameTemp.menuStack = [];\\r\\n    };\\r\\n\\r\\n    // フェード速度を返す\\r\\n    Scene_Map.prototype.fadeSpeed = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true && _srpgBattleQuickLaunch == 'true') {\\r\\n           return 12;\\r\\n        } else {\\r\\n           return Scene_Base.prototype.fadeSpeed.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    //セーブファイルをロードした際に画像をプリロードする\\r\\n    var _SRPG_Scene_Map_start = Scene_Map.prototype.start;\\r\\n    Scene_Map.prototype.start = function() {\\r\\n        _SRPG_Scene_Map_start.call(this);\\r\\n        if ($gameTemp.isSrpgLoadFlag() == true) {\\r\\n            $gameMap.events().forEach(function(event) {\\r\\n                var battlerArray = $gameSystem.EventToUnit(event.eventId());\\r\\n                if (battlerArray && battlerArray[0] === 'actor') {\\r\\n                    var bitmap = ImageManager.loadFace(battlerArray[1].faceName());\\r\\n                } else if (battlerArray && battlerArray[0] === 'enemy') {\\r\\n                    var faceName = battlerArray[1].enemy().meta.faceName;\\r\\n                    if (faceName) {\\r\\n                        var bitmap = ImageManager.loadFace(faceName);\\r\\n                    } else {\\r\\n                        if ($gameSystem.isSideView()) {\\r\\n                            var bitmap = ImageManager.loadSvEnemy(battlerArray[1].battlerName(), battlerArray[1].battlerHue());\\r\\n                        } else {\\r\\n                            var bitmap = ImageManager.loadEnemy(battlerArray[1].battlerName(), battlerArray[1].battlerHue());\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            });\\r\\n            $gameTemp.setSrpgLoadFlag(false);\\r\\n        }\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.destroy = function() {\\r\\n\\t\\t\\r\\n\\t}\\r\\n\\t\\r\\n\\tvar Scene_Map_prototype_stop = Scene_Map.prototype.stop;\\r\\n\\tScene_Map.prototype.stop = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tScene_Map_prototype_stop.call(this);\\r\\n\\t\\tObject.keys(_this.idToMenu).forEach(function(id){\\r\\n\\t\\t\\t_this.idToMenu[id].destroy();\\r\\n\\t\\t});\\r\\n\\t}\\r\\n\\r\\n    // マップのウィンドウ作成\\r\\n    var _SRPG_SceneMap_createAllWindows = Scene_Map.prototype.createAllWindows;\\r\\n    Scene_Map.prototype.createAllWindows = function() {\\r\\n        _SRPG_SceneMap_createAllWindows.call(this);\\r\\n        this.createSrpgStatusWindow();\\r\\n        this.createSrpgActorCommandStatusWindow();\\r\\n        this.createSrpgTargetWindow();\\r\\n        this.createSrpgPredictionWindow();\\r\\n        this.createSrpgActorCommandWindow();\\r\\n        this.createSrpgBattleWindow();\\r\\n        this.createHelpWindow();\\r\\n        this.createSkillWindow();\\r\\n        \\r\\n\\t\\tthis.createAttackWindow();\\r\\n\\t\\tthis.createSpiritWindow();\\r\\n\\t\\tthis.createCounterWindow();\\r\\n\\t\\tthis.createRewardsWindow();\\r\\n\\t\\tthis.createLevelUpWindow();\\r\\n\\t\\tthis.createUnitSummaryWindow();\\r\\n\\t\\tthis.createTerrainDetailsWindow();\\r\\n\\t\\tthis.createIntermissionWindow();\\r\\n\\t\\tthis.createMechListWindow();\\r\\n\\t\\tthis.createMechListDeployedWindow();\\r\\n\\t\\tthis.createMechReassignSelectWindow();\\r\\n\\t\\tthis.createPilotReassignSelectWindow();\\r\\n\\t\\tthis.createUpgradeUnitSelectionWindow();\\r\\n\\t\\tthis.createUpgradeMechWindow();\\r\\n\\t\\tthis.createPilotListWindow();\\r\\n\\t\\tthis.createPilotUpgradeSelectionWindow();\\r\\n\\t\\tthis.createPilotUpgradeWindow();\\r\\n\\t\\tthis.createItemEquipWindow();\\r\\n\\t\\tthis.createItemEquipSelectionWindow();\\r\\n\\t\\tthis.createMinimalBattleWindow();\\r\\n\\t\\tthis.createSpiritAnimWindow();\\r\\n\\t\\tthis.createDetailPagesWindow();\\r\\n\\t\\tthis.createBeforeBattleWindow();\\r\\n\\t\\tthis.createPauseWindow();\\r\\n\\t\\tthis.createConditionsWindow();\\r\\n\\t\\tthis.createItemWindow();\\r\\n\\t\\tthis.createAbilityWindow();\\r\\n\\t\\tthis.createTransformWindow();\\r\\n\\t\\tthis.createDeploymentWindow();\\r\\n\\t\\tthis.createEndTurnConfirmWindow();\\r\\n\\t\\tthis.createDeploymentInStageWindow();\\r\\n\\t\\tthis.createDeploySelectionWindow();\\r\\n\\t\\tthis.createSearchWindow();\\r\\n\\t\\tthis.createOptionsWindow();\\r\\n\\t\\t$battleSceneManager.init();\\t\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.createPauseWindow = function() {\\r\\n\\t\\t\\r\\n\\t\\tthis._commandWindow = new Window_MenuCommand(0, 0);\\r\\n\\t\\tthis._commandWindow.setHandler('save',      this.commandSave.bind(this));\\r\\n\\t\\tthis._commandWindow.setHandler('gameEnd',   this.commandGameEnd.bind(this));\\r\\n\\t\\tthis._commandWindow.setHandler('options',   this.commandOptions.bind(this));\\r\\n\\t\\tthis._commandWindow.setHandler('cancel',    this.closePauseMenu.bind(this));\\r\\n\\t\\tthis._commandWindow.setHandler('turnEnd',this.commandTurnEnd.bind(this));    \\r\\n\\t\\tthis._commandWindow.setHandler('unitList',this.commandUnitList.bind(this));   \\r\\n\\t\\tthis._commandWindow.setHandler('search',this.commandSearch.bind(this));   \\t\\t\\r\\n\\t\\tthis._commandWindow.setHandler('conditions',this.commandConditions.bind(this)); \\r\\n\\t\\t\\r\\n\\t\\tthis._commandWindow.y = 100;\\r\\n\\t\\tthis._commandWindow.x = 800;\\r\\n\\t\\tthis.addWindow(this._commandWindow);\\t\\r\\n\\t\\tthis._goldWindow = new Window_StageInfo(0, 0);\\r\\n\\t\\tthis._goldWindow.y = this._commandWindow.y + this._commandWindow.windowHeight();\\r\\n\\t\\tthis._goldWindow.x = 800;\\r\\n\\t\\tthis.addWindow(this._goldWindow);\\r\\n\\t\\tthis._commandWindow.hide();\\r\\n\\t\\tthis._commandWindow.deactivate();\\r\\n\\t\\tthis._goldWindow.hide();\\r\\n\\t\\tthis._goldWindow.deactivate();\\r\\n\\t}\\r\\n\\t\\r\\n\\tScene_Map.prototype.createConditionsWindow = function() {\\r\\n\\t\\tthis._conditionsWindow = new Window_ConditionsInfo(0, 0);\\r\\n\\t\\tthis._conditionsWindow.y = 100;\\r\\n\\t\\tthis._conditionsWindow.x = 20;\\r\\n\\t\\tthis._conditionsWindow.hide();\\r\\n\\t\\tthis._conditionsWindow.deactivate();\\r\\n\\t\\tthis.addWindow(this._conditionsWindow);\\r\\n\\t};\\r\\n\\t\\r\\n\\tScene_Map.prototype.commandOptions = function() {\\r\\n\\t\\t//SceneManager.push(Scene_Options);\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\t$gameTemp.optionsWindowCancelCallback = function(){\\r\\n\\t\\t\\t$gameTemp.optionsWindowCancelCallback = null;\\r\\n\\t\\t\\t_this._commandWindow.activate();\\r\\n\\t\\t\\t$gameTemp.deactivatePauseMenu = false;\\r\\n\\t\\t\\tInput.clear();//ensure the B press from closing the list does not propagate to the pause menu\\r\\n\\t\\t}\\r\\n\\t\\tthis._commandWindow.deactivate();\\r\\n\\t\\t$gameTemp.deactivatePauseMenu = true;\\r\\n\\t\\t//$gameSystem.setSubBattlePhase('normal');\\r\\n        $gameTemp.pushMenu = \\\"options\\\";\\r\\n\\t};\\r\\n\\t\\r\\n\\tScene_Map.prototype.showPauseMenu = function() {\\r\\n\\t\\tthis._commandWindow.open();\\r\\n\\t\\tthis._commandWindow.show();\\r\\n\\t\\tthis._commandWindow.activate();\\r\\n\\t\\tthis._goldWindow.open();\\r\\n\\t\\tthis._goldWindow.show();\\r\\n\\t\\tthis._goldWindow.activate();\\r\\n\\t}\\r\\n\\t\\r\\n\\tScene_Map.prototype.closePauseMenu = function() {\\r\\n\\t\\tthis._commandWindow.hide();\\r\\n\\t\\tthis._commandWindow.deactivate();\\r\\n\\t\\tthis._goldWindow.hide();\\r\\n\\t\\tthis._goldWindow.deactivate();\\r\\n\\t\\tthis._conditionsWindow.hide();\\r\\n\\t\\t$gameSystem.setSubBattlePhase('normal');\\r\\n\\t}\\r\\n\\t\\r\\n\\tScene_Map.prototype.commandGameEnd = function() {\\r\\n\\t\\tSceneManager.push(Scene_GameEnd);\\r\\n\\t};\\r\\n\\t\\r\\n\\tScene_Map.prototype.commandSave = function() {\\r\\n\\t\\tif(ENGINE_SETTINGS.DEBUG_SAVING){\\r\\n\\t\\t\\t$gameSystem.setSubBattlePhase('normal');\\r\\n\\t\\t\\tSceneManager.push(Scene_Save);\\r\\n\\t\\t\\tDataManager.saveContinueSlot();\\t\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis.closePauseMenu();\\r\\n\\t\\t\\tDataManager.saveContinueSlot();\\t\\r\\n\\t\\t}\\t\\t\\t\\r\\n\\t};\\r\\n\\t\\r\\n\\tScene_Map.prototype.commandTurnEnd = function() {\\r\\n\\t\\tthis._commandWindow.hide();\\r\\n\\t\\tthis._goldWindow.hide();\\r\\n\\t\\t$gameSystem.setSubBattlePhase('confirm_end_turn');\\r\\n\\t\\tif($gameSystem.getActorsWithAction().length){\\t\\t\\t\\r\\n\\t\\t\\t$gameTemp.pushMenu = \\\"confirm_end_turn\\\";\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t$gameTemp.setTurnEndFlag(true);\\r\\n\\t\\t\\t$gameTemp.setAutoBattleFlag(false);\\r\\n\\t\\t}\\t\\t\\r\\n    }\\r\\n\\t\\r\\n\\tScene_Map.prototype.commandUnitList = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\t$gameTemp.mechListWindowCancelCallback = function(){\\r\\n\\t\\t\\t$gameTemp.mechListWindowCancelCallback = null;\\r\\n\\t\\t\\t_this._commandWindow.activate();\\r\\n\\t\\t\\t$gameTemp.deactivatePauseMenu = false;\\r\\n\\t\\t\\tInput.clear();//ensure the B press from closing the list does not propagate to the pause menu\\r\\n\\t\\t}\\r\\n\\t\\tthis._commandWindow.deactivate();\\r\\n\\t\\t$gameTemp.deactivatePauseMenu = true;\\r\\n\\t\\t//$gameSystem.setSubBattlePhase('normal');\\r\\n        $gameTemp.pushMenu = \\\"mech_list_deployed\\\";\\r\\n    }\\r\\n\\t\\r\\n\\tScene_Map.prototype.commandSearch = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\t$gameTemp.searchWindowCancelCallback = function(){\\r\\n\\t\\t\\t$gameTemp.searchWindowCancelCallback = null;\\r\\n\\t\\t\\t_this._commandWindow.activate();\\r\\n\\t\\t\\t$gameTemp.deactivatePauseMenu = false;\\r\\n\\t\\t\\tInput.clear();//ensure the B press from closing the list does not propagate to the pause menu\\r\\n\\t\\t}\\r\\n\\t\\t$gameTemp.searchWindowSelectedCallback = function(actor){\\r\\n\\t\\t\\t$gameTemp.searchWindowSelectedCallback = null;\\r\\n\\t\\t\\tvar referenceEvent = $statCalc.getReferenceEvent(actor);\\r\\n\\t\\t\\tif(referenceEvent){\\r\\n\\t\\t\\t\\t$gamePlayer.locate(referenceEvent.posX(), referenceEvent.posY());\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t_this.closePauseMenu();\\r\\n\\t\\t}\\r\\n\\t\\tthis._commandWindow.deactivate();\\r\\n\\t\\t$gameTemp.deactivatePauseMenu = true;\\r\\n\\t\\t//$gameSystem.setSubBattlePhase('normal');\\r\\n        $gameTemp.pushMenu = \\\"search\\\";\\r\\n    }\\r\\n\\t\\r\\n\\tScene_Map.prototype.commandConditions = function() {\\r\\n\\t\\tthis._conditionsWindow.refresh();\\r\\n\\t\\tif(this._conditionsWindow.visible){\\r\\n\\t\\t\\tthis._conditionsWindow.hide();\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis._conditionsWindow.show();\\r\\n\\t\\t}\\t\\t\\r\\n\\t}\\t\\r\\n\\t\\r\\n\\tScene_Map.prototype.createIntermissionWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\t_this._intermissionWindow = new Window_Intermission(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\r\\n\\t\\t_this._intermissionWindow.addHandler(\\\"intermissionEnd\\\", function(){\\r\\n\\t\\t\\t//$gameVariables.setValue(_nextMapVariable, 4);\\r\\n\\t\\t\\t$gameVariables.setValue(_nextMapXVariable, 1);\\r\\n\\t\\t\\t$gameVariables.setValue(_nextMapYVariable, 1);\\r\\n\\t\\t\\t$gameSwitches.setValue(_endIntermissionSwitchID, true);\\r\\n\\t\\t});\\r\\n\\t\\t_this._intermissionWindow.hide();\\r\\n\\t\\t_this._intermissionWindow.close();\\r\\n\\t\\t_this.addWindow(this._intermissionWindow);\\r\\n\\t\\t_this.idToMenu[\\\"intermission_menu\\\"] = this._intermissionWindow;\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.createMechListWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tthis._mechListWindow = new Window_MechList(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\r\\n\\t\\tthis._mechListWindow.close();\\r\\n\\t\\tthis.addWindow(this._mechListWindow);\\r\\n\\t\\tthis._mechListWindow.registerCallback(\\\"closed\\\", function(){\\r\\n\\t\\t\\t/*if($gameTemp.isEnemyAttack){\\r\\n\\t\\t\\t\\t_this._mapSrpgBattleWindow.activate();\\r\\n\\t\\t\\t} else {\\t\\t\\t\\r\\n\\t\\t\\t\\t_this._mapSrpgActorCommandWindow.activate();\\r\\n\\t\\t\\t}  */\\r\\n\\t\\t\\tif($gameTemp.mechListWindowCancelCallback){\\r\\n\\t\\t\\t\\t$gameTemp.mechListWindowCancelCallback();\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\tthis._mechListWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"mech_list\\\"] = this._mechListWindow;\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.createMechListDeployedWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tthis._mechListDeployedWindow = new Window_MechListDeployed(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\r\\n\\t\\tthis._mechListDeployedWindow.close();\\r\\n\\t\\tthis.addWindow(this._mechListDeployedWindow);\\r\\n\\t\\tthis._mechListDeployedWindow.registerCallback(\\\"closed\\\", function(){\\r\\n\\t\\t\\t/*if($gameTemp.isEnemyAttack){\\r\\n\\t\\t\\t\\t_this._mapSrpgBattleWindow.activate();\\r\\n\\t\\t\\t} else {\\t\\t\\t\\r\\n\\t\\t\\t\\t_this._mapSrpgActorCommandWindow.activate();\\r\\n\\t\\t\\t}  */\\r\\n\\t\\t\\tif($gameTemp.mechListWindowCancelCallback){\\r\\n\\t\\t\\t\\t$gameTemp.mechListWindowCancelCallback();\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\tthis._mechListDeployedWindow.registerCallback(\\\"search_selected\\\", function(actor){\\r\\n\\t\\t\\t/*if($gameTemp.isEnemyAttack){\\r\\n\\t\\t\\t\\t_this._mapSrpgBattleWindow.activate();\\r\\n\\t\\t\\t} else {\\t\\t\\t\\r\\n\\t\\t\\t\\t_this._mapSrpgActorCommandWindow.activate();\\r\\n\\t\\t\\t}  */\\r\\n\\t\\t\\tif($gameTemp.mechListWindowSearchSelectionCallback){\\r\\n\\t\\t\\t\\t$gameTemp.mechListWindowSearchSelectionCallback(actor);\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\tthis._mechListDeployedWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"mech_list_deployed\\\"] = this._mechListDeployedWindow;\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.createMechReassignSelectWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tthis._mechReassignSelectWindow = new Window_SelectReassignMech(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\r\\n\\t\\tthis._mechReassignSelectWindow.close();\\r\\n\\t\\tthis.addWindow(this._mechReassignSelectWindow);\\r\\n\\t\\t\\r\\n\\t\\tthis._mechReassignSelectWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"mech_reassign_select\\\"] = this._mechReassignSelectWindow;\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.createPilotReassignSelectWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tthis._pilotReassignSelectWindow = new Window_SelectReassignPilot(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\r\\n\\t\\tthis._pilotReassignSelectWindow.close();\\r\\n\\t\\tthis.addWindow(this._pilotReassignSelectWindow);\\r\\n\\t\\t\\r\\n\\t\\tthis._pilotReassignSelectWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"pilot_reassign_select\\\"] = this._pilotReassignSelectWindow;\\r\\n    };\\t\\r\\n\\t\\r\\n\\tScene_Map.prototype.createDeploySelectionWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tthis._deploySelectionWindow = new Window_DeploySelection(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\r\\n\\t\\tthis._deploySelectionWindow.close();\\r\\n\\t\\tthis.addWindow(this._deploySelectionWindow);\\r\\n\\t\\tthis._deploySelectionWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"boarded_deploy_selection\\\"] = this._deploySelectionWindow;\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.createDeploymentWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\t\\r\\n\\t\\tthis._deploymentWindow = new Window_DeploymentTwin(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tthis._deploymentWindow.close();\\r\\n\\t\\tthis.addWindow(this._deploymentWindow);\\r\\n\\t\\tthis._deploymentWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"deployment\\\"] = this._deploymentWindow;\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.createEndTurnConfirmWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tthis._endTurnConfirmWindow = new Window_ConfirmEndTurn(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\r\\n\\t\\tthis._endTurnConfirmWindow.close();\\r\\n\\t\\tthis.addWindow(this._endTurnConfirmWindow);\\r\\n\\t\\tthis._endTurnConfirmWindow.registerCallback(\\\"selected\\\", function(result){\\r\\n\\t\\t\\t$gameTemp.OKHeld = true;\\t\\t\\t\\r\\n\\t\\t\\tif(result){\\r\\n\\t\\t\\t\\t$gameTemp.setTurnEndFlag(true);\\r\\n\\t\\t\\t\\t$gameTemp.setAutoBattleFlag(false);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t$gameSystem.setSubBattlePhase(\\\"normal\\\");\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\tthis._endTurnConfirmWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"confirm_end_turn\\\"] = this._endTurnConfirmWindow;\\r\\n    };\\t\\r\\n\\t\\r\\n\\tScene_Map.prototype.createDeploymentInStageWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tthis._deploymentInStageWindow = new Window_DeploymentInStage(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\r\\n\\t\\tthis._deploymentInStageWindow.close();\\r\\n\\t\\tthis.addWindow(this._deploymentInStageWindow);\\r\\n\\t\\tthis._deploymentInStageWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"in_stage_deploy\\\"] = this._deploymentInStageWindow;\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.createUpgradeUnitSelectionWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tthis._ugradeUnitSelectionWindow = new Window_UpgradeUnitSelection(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\r\\n\\t\\tthis._ugradeUnitSelectionWindow.close();\\r\\n\\t\\tthis.addWindow(this._ugradeUnitSelectionWindow);\\r\\n\\t\\tthis._ugradeUnitSelectionWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"upgrade_unit_selection\\\"] = this._ugradeUnitSelectionWindow;\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.createUpgradeMechWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tthis._upgradeMechWindow = new Window_UpgradeMech(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\r\\n\\t\\tthis._upgradeMechWindow.close();\\r\\n\\t\\tthis.addWindow(this._upgradeMechWindow);\\r\\n\\t\\tthis._upgradeMechWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"upgrade_mech\\\"] = this._upgradeMechWindow;\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.createPilotListWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tthis._pilotListWindow = new Window_PilotList(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\r\\n\\t\\tthis._pilotListWindow.close();\\r\\n\\t\\tthis.addWindow(this._pilotListWindow);\\r\\n\\t\\tthis._pilotListWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"pilot_list\\\"] = this._pilotListWindow;\\r\\n    };\\t\\r\\n\\t\\r\\n\\tScene_Map.prototype.createPilotUpgradeSelectionWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tthis._pilotUpgradeSelectionWindow = new Window_UpgradePilotSelection(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\r\\n\\t\\tthis._pilotUpgradeSelectionWindow.close();\\r\\n\\t\\tthis.addWindow(this._pilotUpgradeSelectionWindow);\\r\\n\\t\\tthis._pilotUpgradeSelectionWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"pilot_upgrade_list\\\"] = this._pilotUpgradeSelectionWindow;\\r\\n    };\\t\\r\\n\\t\\r\\n\\tScene_Map.prototype.createPilotUpgradeWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tthis._pilotUpgradeWindow = new Window_UpgradePilot(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\r\\n\\t\\tthis._pilotUpgradeWindow.close();\\r\\n\\t\\tthis.addWindow(this._pilotUpgradeWindow);\\r\\n\\t\\tthis._pilotUpgradeWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"upgrade_pilot\\\"] = this._pilotUpgradeWindow;\\r\\n    };\\t\\r\\n\\t\\r\\n\\tScene_Map.prototype.createItemEquipWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tthis._itemEquipWindow = new Window_EquipItem(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\r\\n\\t\\tthis._itemEquipWindow.close();\\r\\n\\t\\tthis.addWindow(this._itemEquipWindow);\\r\\n\\t\\tthis._itemEquipWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"equip_item\\\"] = this._itemEquipWindow;\\r\\n    };\\t\\r\\n\\t\\r\\n\\t\\r\\n\\tScene_Map.prototype.createItemEquipSelectionWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tthis._itemEquipSelectWindow = new Window_EquipMechSelection(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\r\\n\\t\\tthis._itemEquipSelectWindow.close();\\r\\n\\t\\tthis.addWindow(this._itemEquipSelectWindow);\\r\\n\\t\\tthis._itemEquipSelectWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"equip_item_select\\\"] = this._itemEquipSelectWindow;\\r\\n    };\\t\\t\\r\\n\\t\\r\\n\\tScene_Map.prototype.createMinimalBattleWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tthis._minimalBattleWindow = new Window_BattleBasic(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\r\\n\\t\\tthis._minimalBattleWindow.close();\\r\\n\\t\\tthis.addWindow(this._minimalBattleWindow);\\r\\n\\t\\tthis._minimalBattleWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"battle_basic\\\"] = this._minimalBattleWindow;\\r\\n    };\\t\\r\\n\\t\\r\\n\\tScene_Map.prototype.createSpiritAnimWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tthis._spiritAnimWindow = new Window_SpiritActivation(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\r\\n\\t\\tthis._spiritAnimWindow.registerCallback(\\\"done\\\", function(){\\r\\n\\t\\t\\tif($gameTemp.spiritWindowDoneHandler){\\r\\n\\t\\t\\t\\t$gameTemp.spiritWindowDoneHandler();\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\tthis._spiritAnimWindow.close();\\r\\n\\t\\tthis.addWindow(this._spiritAnimWindow);\\r\\n\\t\\tthis._spiritAnimWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"spirit_activation\\\"] = this._spiritAnimWindow;\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.createDetailPagesWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tthis._detailPagesWindow = new Window_DetailPages(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\r\\n\\t\\tthis._detailPagesWindow.registerCallback(\\\"closed\\\", function(){\\r\\n\\t\\t\\tif($gameTemp.detailPagesWindowCancelCallback){\\r\\n\\t\\t\\t\\t$gameTemp.detailPagesWindowCancelCallback();\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\tthis._detailPagesWindow.close();\\r\\n\\t\\tthis.addWindow(this._detailPagesWindow);\\r\\n\\t\\tthis._detailPagesWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"detail_pages\\\"] = this._detailPagesWindow;\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.createSearchWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tthis._searchWindow = new Window_Search(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\r\\n\\t\\tthis._searchWindow.registerCallback(\\\"closed\\\", function(){\\r\\n\\t\\t\\tif($gameTemp.searchWindowCancelCallback){\\r\\n\\t\\t\\t\\t$gameTemp.searchWindowCancelCallback();\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\tthis._searchWindow.registerCallback(\\\"selected\\\", function(actor){\\r\\n\\t\\t\\tif($gameTemp.searchWindowSelectedCallback){\\r\\n\\t\\t\\t\\t$gameTemp.searchWindowSelectedCallback(actor);\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\tthis._searchWindow.close();\\r\\n\\t\\tthis.addWindow(this._searchWindow);\\r\\n\\t\\tthis._searchWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"search\\\"] = this._searchWindow;\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.createOptionsWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tthis._optionsWindow = new Window_Options(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\r\\n\\t\\tthis._optionsWindow.registerCallback(\\\"closed\\\", function(){\\r\\n\\t\\t\\tif($gameTemp.optionsWindowCancelCallback){\\r\\n\\t\\t\\t\\t$gameTemp.optionsWindowCancelCallback();\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\tthis._optionsWindow.close();\\r\\n\\t\\tthis.addWindow(this._optionsWindow);\\r\\n\\t\\tthis._optionsWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"options\\\"] = this._optionsWindow;\\r\\n    };\\r\\n\\t\\r\\n\\r\\n    // ステータスウィンドウを作る\\r\\n    Scene_Map.prototype.createSrpgStatusWindow = function() {\\r\\n        this._mapSrpgStatusWindow = new Window_SrpgStatus(0, 0);\\r\\n        this._mapSrpgStatusWindow.x = Graphics.boxWidth - this._mapSrpgStatusWindow.windowWidth();\\r\\n        this._mapSrpgStatusWindow.openness = 0;\\r\\n        this.addWindow(this._mapSrpgStatusWindow);\\r\\n    };\\r\\n\\r\\n    // アクターコマンド表示時のステータスウィンドウを作る\\r\\n    Scene_Map.prototype.createSrpgActorCommandStatusWindow = function() {\\r\\n        this._mapSrpgActorCommandStatusWindow = new Window_SrpgActorCommandStatus(0, 0);\\r\\n        this._mapSrpgActorCommandStatusWindow.x = 120;\\r\\n        this._mapSrpgActorCommandStatusWindow.y = Graphics.boxHeight - this._mapSrpgActorCommandStatusWindow.windowHeight();\\r\\n        this._mapSrpgActorCommandStatusWindow.openness = 0;\\r\\n        this.addWindow(this._mapSrpgActorCommandStatusWindow);\\r\\n    };\\r\\n\\r\\n    // ターゲットウィンドウを作る\\r\\n    Scene_Map.prototype.createSrpgTargetWindow = function() {\\r\\n        this._mapSrpgTargetWindow = new Window_SrpgStatus(0, 0);\\r\\n        this._mapSrpgTargetWindow.openness = 0;\\r\\n        this.addWindow(this._mapSrpgTargetWindow);\\r\\n    };\\r\\n\\r\\n    // 予想ウィンドウを作る\\r\\n    Scene_Map.prototype.createSrpgPredictionWindow = function() {\\r\\n        this._mapSrpgPredictionWindow = new Window_SrpgPrediction(0, 0);\\r\\n        this._mapSrpgPredictionWindow.y = this._mapSrpgStatusWindow.windowHeight();\\r\\n        this._mapSrpgPredictionWindow.openness = 0;\\r\\n        this.addWindow(this._mapSrpgPredictionWindow);\\r\\n    };\\r\\n\\r\\n    // アクターコマンドウィンドウを作る\\r\\n    Scene_Map.prototype.createSrpgActorCommandWindow = function() {\\r\\n        this._mapSrpgActorCommandWindow = new Window_ActorCommand();\\r\\n        this._mapSrpgActorCommandWindow.x = Math.max(Graphics.boxWidth / 2 - this._mapSrpgActorCommandWindow.windowWidth(), 0);\\r\\n        this._mapSrpgActorCommandWindow.y = Math.max(Graphics.boxHeight / 2 - this._mapSrpgActorCommandWindow.windowHeight(), 0);\\r\\n\\t\\tthis._mapSrpgActorCommandWindow.setHandler('move',  this.commandMove.bind(this));\\r\\n        this._mapSrpgActorCommandWindow.setHandler('attack', this.commandAttack.bind(this));\\r\\n        this._mapSrpgActorCommandWindow.setHandler('skill',  this.commandSkill.bind(this));\\r\\n        this._mapSrpgActorCommandWindow.setHandler('item',   this.commandItem.bind(this));\\r\\n\\t\\tthis._mapSrpgActorCommandWindow.setHandler('ability',   this.commandAbility.bind(this));\\r\\n        this._mapSrpgActorCommandWindow.setHandler('equip',   this.commandEquip.bind(this));\\r\\n        this._mapSrpgActorCommandWindow.setHandler('wait',  this.commandWait.bind(this));\\r\\n\\t\\tthis._mapSrpgActorCommandWindow.setHandler('land',  this.commandLand.bind(this));\\r\\n\\t\\tthis._mapSrpgActorCommandWindow.setHandler('fly',  this.commandFly.bind(this));\\r\\n\\t\\tthis._mapSrpgActorCommandWindow.setHandler('spirit',  this.commandSpirit.bind(this));\\r\\n\\t\\tthis._mapSrpgActorCommandWindow.setHandler('board',  this.commandBoard.bind(this));\\r\\n\\t\\tthis._mapSrpgActorCommandWindow.setHandler('deploy',  this.commandDeploy.bind(this));\\r\\n\\t\\tthis._mapSrpgActorCommandWindow.setHandler('heal',  this.commandHeal.bind(this));\\r\\n\\t\\tthis._mapSrpgActorCommandWindow.setHandler('resupply',  this.commandResupply.bind(this));\\t\\t\\t\\t\\r\\n\\t\\tthis._mapSrpgActorCommandWindow.setHandler('persuade', this.persuadeActorMenuCommand.bind(this));\\r\\n\\t\\tthis._mapSrpgActorCommandWindow.setHandler('combine', this.combineActorMenuCommand.bind(this));\\r\\n\\t\\tthis._mapSrpgActorCommandWindow.setHandler('split', this.splitActorMenuCommand.bind(this));\\r\\n\\t\\tthis._mapSrpgActorCommandWindow.setHandler('transform', this.transformActorMenuCommand.bind(this));\\r\\n\\t\\tthis._mapSrpgActorCommandWindow.setHandler('swap', this.swapActorMenuCommand.bind(this));\\r\\n\\t\\tthis._mapSrpgActorCommandWindow.setHandler('separate', this.separateActorMenuCommand.bind(this));\\r\\n\\t\\tthis._mapSrpgActorCommandWindow.setHandler('join', this.joinActorMenuCommand.bind(this));\\t\\t\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n        this._mapSrpgActorCommandWindow.setHandler('cancel', this.cancelActorMenuCommand.bind(this));\\r\\n\\t\\t$gameTemp.actorCommandPosition = -1;\\r\\n        this.addWindow(this._mapSrpgActorCommandWindow);\\r\\n    };\\r\\n\\r\\n    // ヘルプウィンドウを作る\\r\\n    Scene_Map.prototype.createHelpWindow = function() {\\r\\n        this._helpWindow = new Window_Help();\\r\\n        this._helpWindow.visible = false;\\r\\n        this.addWindow(this._helpWindow);\\r\\n    };\\r\\n\\r\\n    // スキルウィンドウを作る\\r\\n    Scene_Map.prototype.createSkillWindow = function() {\\r\\n        var wy = this._helpWindow.y + this._helpWindow.height;\\r\\n        var wh = Graphics.boxHeight - wy - this._mapSrpgActorCommandStatusWindow.windowHeight();\\r\\n        this._skillWindow = new Window_BattleSkill(0, wy, Graphics.boxWidth, wh);\\r\\n        this._skillWindow.setHelpWindow(this._helpWindow);\\r\\n        this._skillWindow.setHandler('ok',     this.onSkillOk.bind(this));\\r\\n        this._skillWindow.setHandler('cancel', this.onSkillCancel.bind(this));\\r\\n        this.addWindow(this._skillWindow);\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.createAttackWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tthis._attackWindow = new Window_AttackList(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\r\\n\\t\\tthis._attackWindow.registerCallback(\\\"selected\\\", function(attack){\\t\\t\\t\\r\\n\\t\\t\\tif($gameTemp.attackWindowCallback){\\r\\n\\t\\t\\t\\t$gameTemp.attackWindowCallback(attack);\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\tthis._attackWindow.registerCallback(\\\"closed\\\", function(){\\r\\n\\t\\t\\t/*if($gameTemp.isEnemyAttack){\\r\\n\\t\\t\\t\\t_this._mapSrpgBattleWindow.activate();\\r\\n\\t\\t\\t} else {\\t\\t\\t\\r\\n\\t\\t\\t\\t_this._mapSrpgActorCommandWindow.activate();\\r\\n\\t\\t\\t}  */\\r\\n\\t\\t\\tif($gameTemp.attackWindowCancelCallback){\\r\\n\\t\\t\\t\\t$gameTemp.attackWindowCancelCallback();\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\tthis._attackWindow.close();\\r\\n\\t\\tthis.addWindow(this._attackWindow);\\r\\n\\t\\tthis._attackWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"attack_list\\\"] = this._attackWindow;\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.createSpiritWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\t_this._spiritWindow = new Window_SpiritSelection(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\t\\t\\r\\n\\t\\tthis._spiritWindow.registerCallback(\\\"selected\\\", function(spiritInfo){\\r\\n\\t\\t\\t_this.handleSpiritSelection(spiritInfo);\\r\\n\\t\\t});\\r\\n\\t\\tthis._spiritWindow.registerCallback(\\\"selectedMultiple\\\", function(spirits){\\r\\n\\t\\t\\t_this.handleMultipleSpiritSelection(spirits);\\r\\n\\t\\t});\\t\\t\\r\\n\\t\\tthis._spiritWindow.registerCallback(\\\"closed\\\", function(spiritInfo){\\r\\n\\t\\t\\t_this._spiritWindow.close();\\r\\n\\t\\t\\t_this._mapSrpgActorCommandWindow.activate()\\r\\n\\t\\t\\t_this._mapSrpgActorCommandWindow.show()\\r\\n\\t\\t});\\r\\n\\t\\tthis._spiritWindow.close();\\r\\n\\t\\tthis.addWindow(this._spiritWindow);\\r\\n\\t\\tthis._spiritWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"spirit_selection\\\"] = this._spiritWindow;\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.createBeforeBattleWindow = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tif(ENGINE_SETTINGS.ENABLE_TWIN_SYSTEM){\\r\\n\\t\\t\\t_this._beforeBattleWindow = new Window_BeforebattleTwin(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\t\\t\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t_this._beforeBattleWindow = new Window_BeforeBattle(0, 0, Graphics.boxWidth, Graphics.boxHeight);\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tthis._beforeBattleWindow.registerCallback(\\\"selected\\\", function(spiritInfo){\\r\\n\\t\\t\\t_this.commandBattleStart();\\r\\n\\t\\t});\\r\\n\\t\\tthis._beforeBattleWindow.registerCallback(\\\"closed\\\", function(spiritInfo){\\r\\n\\t\\t\\t_this.selectPreviousSrpgBattleStart();\\r\\n\\t\\t});\\r\\n\\t\\t\\r\\n\\t\\tthis._beforeBattleWindow.close();\\r\\n\\t\\tthis.addWindow(this._beforeBattleWindow);\\r\\n\\t\\tthis._beforeBattleWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"before_battle\\\"] = this._beforeBattleWindow;\\r\\n    };\\r\\n\\t\\r\\n\\t\\r\\n\\tScene_Map.prototype.applyAdditionalSpiritEffects = function(spiritInfo, target, caster) {\\r\\n\\t\\t//Implementation of Great Wall Ace Bonus\\r\\n\\t\\tif(spiritInfo.idx == 22 && $statCalc.applyStatModsToValue(target, 0, [\\\"great_wall\\\"])) { //Wall\\r\\n\\t\\t\\t$spiritManager.applyEffect(9, caster, [target], 0); //Drive\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\tScene_Map.prototype.handleMultipleSpiritSelection = function(spirits) {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\t$gameTemp.playingSpiritAnimations = true;\\r\\n\\t\\tvar currentSpirit = spirits.pop();\\t\\r\\n\\t\\tthis._spiritWindow.close();\\r\\n\\t\\t$gameSystem.clearSrpgActorCommandWindowNeedRefresh();\\r\\n\\t\\t\\r\\n\\t\\tfunction applySpirit(){\\r\\n\\t\\t\\t_this.applyAdditionalSpiritEffects(currentSpirit, currentSpirit.target, currentSpirit.caster);\\r\\n\\t\\t\\tvar targets = [currentSpirit.target];\\r\\n\\t\\t\\tif(currentSpirit.target.isActor()){\\r\\n\\t\\t\\t\\tvar subPilots = currentSpirit.target.SRWStats.mech.subPilots;\\r\\n\\t\\t\\t\\tif(subPilots){\\r\\n\\t\\t\\t\\t\\tsubPilots.forEach(function(actorId){\\r\\n\\t\\t\\t\\t\\t\\ttargets.push($gameActors.actor(actorId));\\r\\n\\t\\t\\t\\t\\t});\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\t$spiritManager.applyEffect(currentSpirit.idx, currentSpirit.caster, targets, currentSpirit.cost);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t$gameTemp.spiritTargetActor = currentSpirit.target;\\r\\n\\t\\t\\t$gameTemp.queuedActorEffects = [{type: \\\"spirit\\\", parameters: {target: currentSpirit.target, idx: currentSpirit.idx}}];\\t\\r\\n\\t\\t\\t_this._spiritAnimWindow.show(true);\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t$gameTemp.spiritWindowDoneHandler = function(){\\r\\n\\t\\t\\tif(!spirits.length){\\r\\n\\t\\t\\t\\t$gameTemp.playingSpiritAnimations = false;\\r\\n\\t\\t\\t\\t$gameTemp.popMenu = true;\\r\\n\\t\\t\\t\\t$gameSystem.setSrpgActorCommandWindowNeedRefresh($gameSystem.EventToUnit($gameTemp.activeEvent().eventId()));\\r\\n\\t\\t\\t\\t$gameSystem.setSubBattlePhase(\\\"actor_command_window\\\");\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tcurrentSpirit = spirits.pop();\\t\\r\\n\\t\\t\\t\\tapplySpirit();\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\t$gameSystem.setSubBattlePhase('spirit_activation');\\t\\r\\n\\t\\t$gameTemp.pushMenu = \\\"spirit_activation\\\";\\r\\n\\t\\tapplySpirit();\\r\\n\\t}\\r\\n\\t\\r\\n\\tScene_Map.prototype.handleEventSpirits = function(spirits) {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\t$gameTemp.playingSpiritAnimations = true;\\r\\n\\t\\tvar currentSpirit = spirits.pop();\\t\\r\\n\\t\\tthis._spiritWindow.close();\\r\\n\\t\\t\\r\\n\\t\\tfunction applySpirit(){\\r\\n\\t\\t\\t_this.applyAdditionalSpiritEffects(currentSpirit, currentSpirit.target, currentSpirit.caster);\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t$spiritManager.applyEffect(currentSpirit.idx, currentSpirit.caster, [currentSpirit.target], 0);\\t\\t\\t\\r\\n\\t\\t\\t$gameTemp.spiritTargetActor = currentSpirit.target;\\r\\n\\t\\t\\t$gameTemp.queuedActorEffects = [{type: \\\"spirit\\\", parameters: {target: currentSpirit.target, idx: currentSpirit.idx}}];\\t\\r\\n\\t\\t\\t_this._spiritAnimWindow.show(true);\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t$gameTemp.spiritWindowDoneHandler = function(){\\r\\n\\t\\t\\tif(!spirits.length){\\r\\n\\t\\t\\t\\t$gameSystem.setSubBattlePhase('normal');\\t\\r\\n\\t\\t\\t\\t$gameTemp.playingSpiritAnimations = false;\\r\\n\\t\\t\\t\\t$gameTemp.popMenu = true;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tcurrentSpirit = spirits.pop();\\t\\r\\n\\t\\t\\t\\tapplySpirit();\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\t$gameSystem.setSubBattlePhase('spirit_activation');\\t\\r\\n\\t\\t$gameTemp.pushMenu = \\\"spirit_activation\\\";\\r\\n\\t\\tapplySpirit();\\r\\n\\t}\\r\\n\\t\\r\\n\\tScene_Map.prototype.handleSpiritSelection = function(spiritInfo) {\\r\\n\\t\\tthis._spiritWindow.close();\\r\\n\\t\\t$gameSystem.clearSrpgActorCommandWindowNeedRefresh();\\r\\n\\t\\tvar battlerArray = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId());\\r\\n\\t\\tvar target;\\r\\n\\t\\tif(spiritInfo.target){\\r\\n\\t\\t\\ttarget = spiritInfo.target;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\ttarget = battlerArray[1];\\r\\n\\t\\t}\\r\\n\\t\\tvar caster;\\r\\n\\t\\tif(spiritInfo.caster){\\r\\n\\t\\t\\tcaster = spiritInfo.caster;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tcaster = battlerArray[1];\\r\\n\\t\\t}\\r\\n\\t\\tvar initialTargetingResult = $spiritManager.performInitialTargeting(spiritInfo.idx, target);\\r\\n\\t\\t\\r\\n\\t\\tif(initialTargetingResult.type == \\\"enemy\\\" || initialTargetingResult.type == \\\"ally\\\"){\\r\\n\\t\\t //manual Targeting required\\r\\n\\t\\t\\t $gameTemp.currentTargetingSpirit = spiritInfo;\\r\\n\\t\\t\\t $gameSystem.setSubBattlePhase('actor_target_spirit');\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t//apply immediately\\r\\n\\t\\t\\t$spiritManager.applyEffect(spiritInfo.idx, caster, initialTargetingResult.targets, spiritInfo.cost);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tthis.applyAdditionalSpiritEffects(spiritInfo, target, caster);\\r\\n\\t\\t\\tif(initialTargetingResult.type != \\\"enemy_all\\\" && initialTargetingResult.type != \\\"ally_all\\\"){\\r\\n\\t\\t\\t\\t$gameTemp.spiritTargetActor = initialTargetingResult.targets[0];\\r\\n\\t\\t\\t\\t$gameTemp.queuedActorEffects = [{type: \\\"spirit\\\", parameters: {target: initialTargetingResult.targets[0], idx: spiritInfo.idx}}];\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t$gameSystem.setSubBattlePhase('spirit_activation');\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t$gameTemp.spiritWindowDoneHandler = function(){\\r\\n\\t\\t\\t\\t\\t$gameTemp.popMenu = true;\\r\\n\\t\\t\\t\\t\\t$gameSystem.setSrpgActorCommandWindowNeedRefresh($gameSystem.EventToUnit($gameTemp.activeEvent().eventId()));\\r\\n\\t\\t\\t\\t\\t$gameSystem.setSubBattlePhase(\\\"actor_command_window\\\");\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t$gameTemp.pushMenu = \\\"spirit_activation\\\";\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t//_this._mapSrpgActorCommandWindow.activate();\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t$gameTemp.queuedEffectSpiritId = spiritInfo.idx; \\r\\n\\t\\t\\t\\t$gameSystem.setSubBattlePhase(\\\"map_spirit_animation\\\");\\t\\t\\t\\t\\r\\n\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\tScene_Map.prototype.createCounterWindow = function() {\\r\\n\\t\\tvar wy = this._helpWindow.y + this._helpWindow.height;\\r\\n\\t\\tvar wh = Graphics.boxHeight - wy - this._mapSrpgActorCommandStatusWindow.windowHeight();\\r\\n\\t\\tthis._counterWindow = new Window_CounterCommand(0, wy, Graphics.boxWidth, wh);\\r\\n\\t\\t\\r\\n\\t\\tthis._counterWindow.x = Math.max((Graphics.boxWidth - this._counterWindow.windowWidth()) / 2, 120) + this._mapSrpgBattleWindow.windowWidth();\\r\\n        this._counterWindow.y = this._mapSrpgStatusWindow.windowHeight() + this._mapSrpgPredictionWindow.windowHeight();\\r\\n\\r\\n\\t\\tthis._counterWindow.setHelpWindow(this._helpWindow);\\r\\n\\t\\t//this._counterWindow.setHandler('ok',     this.onAttackOk.bind(this));\\r\\n\\t\\t//this._attackWindow.setHandler('cancel', this.onAttackCancel.bind(this));\\r\\n\\t\\t//this._counterWindow.setup();\\r\\n\\t\\tthis._counterWindow.setHandler('counter',     this.onCounterSelected.bind(this));\\r\\n\\t\\tthis._counterWindow.setHandler('defend',     this.onDefendSelected.bind(this));\\r\\n\\t\\tthis._counterWindow.setHandler('evade',     this.onEvadeSelected.bind(this));\\r\\n\\t\\tthis._counterWindow.setHandler('cancel',     this.onCounterCancel.bind(this));\\r\\n\\t\\tthis.addWindow(this._counterWindow);\\r\\n    };\\r\\n\\r\\n    // アイテムウィンドウを作る\\r\\n    Scene_Map.prototype.createItemWindow = function() {\\r\\n        var wy = this._helpWindow.y + this._helpWindow.height;\\r\\n        var wh = Graphics.boxHeight - wy - this._mapSrpgActorCommandStatusWindow.windowHeight();\\r\\n        this._itemWindow = new Window_SRWItemBattle(0, wy, 200, 180);\\r\\n\\t\\tthis._itemWindow.x = this._mapSrpgActorCommandWindow.x - this._mapSrpgActorCommandWindow.windowWidth() + 120;\\r\\n\\t\\tthis._itemWindow.y = this._mapSrpgActorCommandWindow.y - this._mapSrpgActorCommandWindow.windowHeight()/2;\\r\\n        //this._itemWindow.setHelpWindow(this._helpWindow);\\r\\n        this._itemWindow.setHandler('ok',     this.onConsumableOk.bind(this));\\r\\n        this._itemWindow.setHandler('cancel', this.onItemCancel.bind(this));\\r\\n        this.addWindow(this._itemWindow);\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.createAbilityWindow = function() {\\r\\n        var wy = this._helpWindow.y + this._helpWindow.height;\\r\\n        var wh = Graphics.boxHeight - wy - this._mapSrpgActorCommandStatusWindow.windowHeight();\\r\\n        this._abilityWindow = new Window_SRWAbilityCommand(0, wy, 200, 180);\\r\\n\\t\\tthis._abilityWindow.x = this._mapSrpgActorCommandWindow.x - this._mapSrpgActorCommandWindow.windowWidth() + 120;\\r\\n\\t\\tthis._abilityWindow.y = this._mapSrpgActorCommandWindow.y - this._mapSrpgActorCommandWindow.windowHeight()/2;\\r\\n        //this._itemWindow.setHelpWindow(this._helpWindow);\\r\\n        this._abilityWindow.setHandler('ok',     this.onAbilityOk.bind(this));\\r\\n        this._abilityWindow.setHandler('cancel', this.onAbilityCancel.bind(this));\\r\\n        this.addWindow(this._abilityWindow);\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.createTransformWindow = function() {\\r\\n        var wy = this._helpWindow.y + this._helpWindow.height;\\r\\n        var wh = Graphics.boxHeight - wy - this._mapSrpgActorCommandStatusWindow.windowHeight();\\r\\n        this._transformWindow = new Window_SRWTransformSelection(0, wy, 200, 180);\\r\\n\\t\\tthis._transformWindow.x = this._mapSrpgActorCommandWindow.x - this._mapSrpgActorCommandWindow.windowWidth() + 120;\\r\\n\\t\\tthis._transformWindow.y = this._mapSrpgActorCommandWindow.y - this._mapSrpgActorCommandWindow.windowHeight()/2;\\r\\n        //this._itemWindow.setHelpWindow(this._helpWindow);\\r\\n        this._transformWindow.setHandler('ok',     this.onTransformOk.bind(this));\\r\\n        this._transformWindow.setHandler('cancel', this.onTransformCancel.bind(this));\\r\\n        this.addWindow(this._transformWindow);\\r\\n    };\\r\\n\\t\\r\\n\\t\\r\\n\\t\\r\\n\\r\\n    // 戦闘開始ウィンドウを作る\\r\\n    Scene_Map.prototype.createSrpgBattleWindow = function() {\\r\\n        this._mapSrpgBattleWindow = new Window_SrpgBattle();\\r\\n        this._mapSrpgBattleWindow.x = Math.max((Graphics.boxWidth - this._mapSrpgBattleWindow.windowWidth()) / 2, 120);\\r\\n        this._mapSrpgBattleWindow.y = this._mapSrpgStatusWindow.windowHeight() + this._mapSrpgPredictionWindow.windowHeight();\\r\\n        this._mapSrpgBattleWindow.setHandler('battleStart', this.commandBattleStart.bind(this));\\r\\n\\t\\tthis._mapSrpgBattleWindow.setHandler('selectCounterAction', this.selectCounterAction.bind(this));\\r\\n        this._mapSrpgBattleWindow.setHandler('cancel', this.selectPreviousSrpgBattleStart.bind(this));\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n        this.addWindow(this._mapSrpgBattleWindow);\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.createRewardsWindow = function() {\\r\\n\\t\\tvar wy = this._helpWindow.y + this._helpWindow.height;\\r\\n\\t\\tvar wh = Graphics.boxHeight - wy - this._mapSrpgActorCommandStatusWindow.windowHeight();\\r\\n\\t\\tthis._rewardsWindow = new Window_Rewards(0, wy, Graphics.boxWidth, wh);\\r\\n\\t\\t\\r\\n\\t\\tthis._rewardsWindow.close();\\r\\n\\t\\tthis.addWindow(this._rewardsWindow);\\r\\n\\t\\tthis._rewardsWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"rewards\\\"] = this._rewardsWindow;\\r\\n    };\\r\\n\\t\\t\\r\\n\\tScene_Map.prototype.createUnitSummaryWindow = function() {\\r\\n\\t\\tthis._summaryWindow = new Window_UnitSummary(0, 0);\\t\\t\\t\\t\\r\\n\\t\\tthis._summaryWindow.close();\\r\\n\\t\\tthis.addWindow(this._summaryWindow);\\r\\n\\t\\tthis._summaryWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"unit_summary\\\"] = this._summaryWindow;\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.createTerrainDetailsWindow = function() {\\r\\n\\t\\tthis._terrainDetailsWindow = new Window_TerrainDetails(0, 0);\\t\\t\\t\\t\\r\\n\\t\\tthis._terrainDetailsWindow.close();\\r\\n\\t\\tthis.addWindow(this._terrainDetailsWindow);\\r\\n\\t\\tthis._terrainDetailsWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"terrain_details\\\"] = this._terrainDetailsWindow;\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.createLevelUpWindow = function() {\\r\\n\\t\\tvar wy = this._helpWindow.y + this._helpWindow.height;\\r\\n\\t\\tvar wh = Graphics.boxHeight - wy - this._mapSrpgActorCommandStatusWindow.windowHeight();\\r\\n\\t\\tthis._levelUpWindow = new Window_LevelUp(0, wy, Graphics.boxWidth, wh);\\r\\n\\t\\t\\t\\t\\r\\n\\t\\tthis._levelUpWindow.close();\\r\\n\\t\\tthis.addWindow(this._levelUpWindow);\\r\\n\\t\\tthis._levelUpWindow.hide();\\r\\n\\t\\tthis.idToMenu[\\\"level_up\\\"] = this._levelUpWindow;\\r\\n    };\\r\\n\\r\\n    // サブフェーズの状況に応じてキャンセルキーの機能を変更する\\r\\n    var _SRPG_SceneMap_updateCallMenu = Scene_Map.prototype.updateCallMenu;\\r\\n    Scene_Map.prototype.updateCallMenu = function() {\\r\\n\\t\\tvar _this = this;\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n\\t\\t\\t\\r\\n           /* if ($gameSystem.srpgWaitMoving() == true ||\\r\\n                $gameTemp.isAutoMoveDestinationValid() == true ||\\r\\n                $gameSystem.isSubBattlePhase() === 'status_window' ||\\r\\n                $gameSystem.isSubBattlePhase() === 'battle_window' ||\\r\\n\\t\\t\\t\\t//$gameSystem.isSubBattlePhase() === 'actor_command_window' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'post_move_command_window' ||\\r\\n                $gameSystem.isBattlePhase() != 'actor_phase' ||\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'process_death_queue' || \\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'process_death' || \\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'pause_menu' || \\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'event_before_battle' || \\t\\t\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'rewards_display' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'level_up_display' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'battle_basic' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'spirit_activation' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'after_battle'  ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'map_attack_animation' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'process_map_attack_queue' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'map_spirit_animation' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'confirm_boarding' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'enemy_unit_summary' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'confirm_end_turn' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'enemy_targeting_display' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'enemy_attack' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'enemy_range_display' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'await_character_anim' ||\\r\\n\\t\\t\\t\\t$gameSystem.isSubBattlePhase() === 'process_destroy_transform_queue'\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t) {\\r\\n                this.menuCalling = false;\\r\\n                return;\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\r\\n            }\\t*/\\t\\r\\n\\r\\n\\t\\t\\tif(!$SRWGameState.canUseMenu()){\\r\\n\\t\\t\\t\\t this.menuCalling = false;\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n            if ($gameSystem.isSubBattlePhase() === 'normal' && !$gameSystem.isIntermission()) {\\r\\n\\t\\t\\t\\t$gameTemp.isPostMove = false;\\r\\n                if (Input.isTriggered('pageup')) {                   \\r\\n                    $gameSystem.getNextLActor();\\r\\n                } else if (Input.isTriggered('pagedown')) {      \\r\\n                    $gameSystem.getNextRActor();\\r\\n                }\\r\\n            }\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif ($gameSystem.isSubBattlePhase() === 'twin_selection') {\\r\\n                \\r\\n            }/*else {\\r\\n                _SRPG_SceneMap_updateCallMenu.call(this);\\r\\n            }*/\\r\\n        } else {\\r\\n            _SRPG_SceneMap_updateCallMenu.call(this);\\r\\n        }\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.processMenuStack = function(){\\r\\n\\t\\tvar menuStack = $gameTemp.menuStack;\\r\\n\\t\\tif($gameTemp.popMenu){\\r\\n\\t\\t\\t//console.log(\\\"Pop Menu \\\" + $gameTemp.menuStack[menuStack.length-1]);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t//Input.update is called twice to prevent inputs that triggered the closing of a window to also trigger something in the new state\\r\\n\\t\\t\\tInput.update();\\r\\n\\t\\t\\tInput.update();\\r\\n\\t\\t\\tif(menuStack.length){\\r\\n\\t\\t\\t\\tvar menu = menuStack.pop();\\r\\n\\t\\t\\t\\tif(menu){\\r\\n\\t\\t\\t\\t\\tmenu.hide();\\r\\n\\t\\t\\t\\t\\tmenu.close();\\r\\n\\t\\t\\t\\t\\tmenu.deactivate();\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(menuStack.length){\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tvar menu = menuStack[menuStack.length-1];\\r\\n\\t\\t\\t\\t\\tif(menu){\\r\\n\\t\\t\\t\\t\\t\\tmenu.show();\\r\\n\\t\\t\\t\\t\\t\\tmenu.open();\\r\\n\\t\\t\\t\\t\\t\\tmenu.activate();\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$gameTemp.popMenu = false;\\r\\n\\t\\t\\tif($gameTemp.popFunction){\\r\\n\\t\\t\\t\\t$gameTemp.popFunction.call(this);\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t$gameTemp.popFunction = null;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tif($gameTemp.killMenus && Object.keys($gameTemp.killMenus).length){\\r\\n\\t\\t\\tvar tmp = [];\\r\\n\\t\\t\\tfor(var i = 0; i < menuStack.length; i++){\\r\\n\\t\\t\\t\\tvar menu = menuStack[i];\\r\\n\\t\\t\\t\\tif(menu){\\r\\n\\t\\t\\t\\t\\tif(!$gameTemp.killMenus[menuStack[i]._layoutId]){\\r\\n\\t\\t\\t\\t\\t\\ttmp.push(menu);\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\tmenu.hide();\\r\\n\\t\\t\\t\\t\\t\\tmenu.close();\\r\\n\\t\\t\\t\\t\\t\\tmenu.deactivate();\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$gameTemp.killMenus = {};\\r\\n\\t\\t\\tmenuStack = tmp;\\r\\n\\t\\t\\tif(menuStack.length){\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tvar menu = menuStack[menuStack.length-1];\\r\\n\\t\\t\\t\\tif(menu){\\r\\n\\t\\t\\t\\t\\tmenu.show();\\r\\n\\t\\t\\t\\t\\tmenu.open();\\r\\n\\t\\t\\t\\t\\tmenu.activate();\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$gameTemp.menuStack = menuStack;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif($gameTemp.pushMenu){\\r\\n\\t\\t\\t//console.log(\\\"Push Menu \\\"+$gameTemp.pushMenu);\\r\\n\\t\\t\\tif(menuStack.length){\\r\\n\\t\\t\\t\\tvar menu = menuStack[menuStack.length-1];\\r\\n\\t\\t\\t\\tif(menu){\\r\\n\\t\\t\\t\\t\\tmenu.hide();\\r\\n\\t\\t\\t\\t\\tmenu.close();\\r\\n\\t\\t\\t\\t\\tmenu.deactivate();\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tvar menu = this.idToMenu[$gameTemp.pushMenu];\\r\\n\\t\\t\\tif(menu){\\r\\n\\t\\t\\t\\tmenu.show();\\r\\n\\t\\t\\t\\tmenu.open();\\r\\n\\t\\t\\t\\tmenu.activate();\\r\\n\\t\\t\\t\\tmenuStack.push(menu);\\r\\n\\t\\t\\t}\\t\\r\\n\\t\\t\\t$gameTemp.pushMenu = null;\\t\\r\\n\\t\\t}\\t\\r\\n\\t}\\r\\n\\r\\n    // マップの更新\\r\\n    var _SRPG_SceneMap_update = Scene_Map.prototype.update;\\r\\n    Scene_Map.prototype.update = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\t\\r\\n\\t\\t//Soft Reset\\r\\n\\t\\tif(!$gameSystem.isIntermission() && Input.isPressed(\\\"ok\\\") && Input.isPressed(\\\"cancel\\\") && Input.isPressed(\\\"pageup\\\") && Input.isPressed(\\\"pagedown\\\")){\\r\\n\\t\\t\\tInput.clear();\\r\\n\\t\\t\\ttry {\\r\\n\\t\\t\\t\\tJsonEx.parse(StorageManager.load(\\\"continue\\\"));//check if the continue slot exists first by trying to parse it\\r\\n\\t\\t\\t\\tDataManager.loadContinueSlot();\\r\\n\\t\\t\\t} catch(e){\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\t\\r\\n\\t\\t_SRPG_SceneMap_update.call(this);\\r\\n\\t\\t\\r\\n\\t\\tthis.processMenuStack();\\r\\n\\t\\t\\r\\n\\t\\tif($gameSystem.isIntermission()){\\r\\n\\t\\t\\t$SRWGameState.requestNewState(\\\"intermission\\\");\\r\\n\\t\\t\\tif(!this._intermissionWindowOpen){\\r\\n\\t\\t\\t\\t$gameSystem.clearData();//make sure stage temp data is cleared when moving between stages\\r\\n\\t\\t\\t\\tthis._intermissionWindowOpen = true;\\r\\n\\t\\t\\t\\tthis._intermissionWindow.setActor($gameSystem._availableUnits[0]);\\r\\n\\t\\t\\t\\t/*this._intermissionWindow.refresh();\\r\\n\\t\\t\\t\\tthis._intermissionWindow.open();\\r\\n\\t\\t\\t\\tthis._intermissionWindow.show();\\r\\n\\t\\t\\t\\tthis._intermissionWindow.activate();*/\\r\\n\\t\\t\\t\\t$gameTemp.pushMenu = \\\"intermission_menu\\\";\\r\\n\\t\\t\\t}\\t\\r\\n\\t\\t\\tvar menu = this.idToMenu[\\\"intermission_menu\\\"];\\r\\n\\t\\t\\tif(!menu.visible){\\r\\n\\t\\t\\t\\tmenu.visible = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn;\\t\\t\\t\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif(this._intermissionWindowOpen){\\r\\n\\t\\t\\t\\tthis._intermissionWindowOpen = false;\\r\\n\\t\\t\\t\\tthis._intermissionWindow.close();\\r\\n\\t\\t\\t\\tthis._intermissionWindow.hide();\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif(!$SRWGameState.update(this)) {\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tif($gameTemp.continueLoaded){\\r\\n\\t\\t\\t$gameTemp.continueLoaded = false;\\r\\n\\t\\t\\t$gameSystem.onAfterLoad();\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\t//Start first actor turn\\r\\n\\t\\tif ($gameSystem.isBattlePhase() == \\\"start_srpg\\\"){\\r\\n\\t\\t\\tif (!$gameMap.isEventRunning()) {\\r\\n\\t\\t\\t\\t$gameSystem.srpgStartActorTurn();\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\t//$gameSystem.isSubBattlePhase() !== 'normal' && $gameSystem.isSubBattlePhase() !== 'actor_target' && $gameSystem.isSubBattlePhase() !== 'actor_target_spirit' && $gameSystem.isSubBattlePhase() !== 'actor_map_target_confirm'\\r\\n\\t\\tif (!$SRWGameState.canShowSummaries()) {\\t\\r\\n\\t\\t\\tthis._summaryWindow.hide();\\r\\n\\t\\t\\tthis._terrainDetailsWindow.hide();\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tif($gameTemp.OKHeld && !Input.isTriggered(\\\"ok\\\")){\\r\\n\\t\\t\\t$gameTemp.OKHeld = false;\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t//console.log($gameSystem.isSubBattlePhase());\\r\\n\\t\\tif($gameTemp.enemyAppearQueueIsProcessing){\\r\\n\\t\\t\\t$gameTemp.unitAppearTimer--;\\r\\n\\t\\t\\tif($gameTemp.unitAppearTimer <= 0){\\r\\n\\t\\t\\t\\tif(!$gameTemp.enemyAppearQueue.length){\\r\\n\\t\\t\\t\\t\\t$gameTemp.enemyAppearQueueIsProcessing = false;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tvar current = $gameTemp.enemyAppearQueue.shift();\\r\\n\\t\\t\\t\\t\\t$gamePlayer.locate(current.posX(), current.posY());\\r\\n\\t\\t\\t\\t\\tcurrent.isDoingAppearAnim = true;\\r\\n\\t\\t\\t\\t\\tcurrent.isPendingDeploy = false;\\r\\n\\t\\t\\t\\t\\tvar battlerArray = $gameSystem.EventToUnit(current.eventId());\\r\\n\\t\\t\\t\\t\\tvar wait = 15;\\r\\n\\t\\t\\t\\t\\t/*if(battlerArray && battlerArray[1]){\\r\\n\\t\\t\\t\\t\\t\\tvar animInfo = $statCalc.getSpawnAnimInfo(battlerArray[1]);\\r\\n\\t\\t\\t\\t\\t\\twait+=animInfo.frames;\\r\\n\\t\\t\\t\\t\\t}*/\\r\\n\\t\\t\\t\\t\\t$gameTemp.unitAppearTimer = wait;\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif($gameTemp.disappearQueueIsProcessing){\\r\\n\\t\\t\\t$gameTemp.unitAppearTimer--;\\r\\n\\t\\t\\tif($gameTemp.unitAppearTimer <= 0){\\r\\n\\t\\t\\t\\tif(!$gameTemp.disappearQueue.length){\\r\\n\\t\\t\\t\\t\\t$gameTemp.disappearQueueIsProcessing = false;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tvar current = $gameTemp.disappearQueue.shift();\\r\\n\\t\\t\\t\\t\\t$gamePlayer.locate(current.posX(), current.posY());\\r\\n\\t\\t\\t\\t\\tcurrent.isDoingDisappearAnim = true;\\r\\n\\t\\t\\t\\t\\t$gameTemp.unitAppearTimer = 15;\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n        if ($gameSystem.isSRPGMode() == false) {\\r\\n            return;\\r\\n        }\\r\\n        if ($gameSystem.srpgWaitMoving() == true || $gameTemp.isAutoMoveDestinationValid() == true) {\\r\\n            return;\\r\\n        }\\r\\n        //ターン終了コマンドの実行\\r\\n        if ($gameTemp.isTurnEndFlag() == true) {\\r\\n            this.menuActorTurnEnd();\\r\\n            return;\\r\\n        }\\r\\n        //アクターコマンドからの装備変更の後処理\\r\\n        if ($gameTemp.isSrpgActorEquipFlag() == true) {\\r\\n            this.srpgAfterActorEquip();\\r\\n            return;\\r\\n        }\\r\\n\\t\\t\\r\\n        //ステータスウィンドウの開閉\\r\\n        var flag = $gameSystem.srpgStatusWindowNeedRefresh();\\r\\n        if (flag[0]) {\\r\\n            if (!this._mapSrpgStatusWindow.isOpen() && !this._mapSrpgStatusWindow.isOpening()) {\\r\\n                this._mapSrpgStatusWindow.setBattler(flag[1]);\\r\\n                this._mapSrpgStatusWindow.open();\\r\\n\\t\\t\\t\\tthis._mapSrpgStatusWindow.show();\\r\\n            }\\r\\n        } else {\\r\\n            if (this._mapSrpgStatusWindow.isOpen() && !this._mapSrpgStatusWindow.isClosing()) {\\r\\n                this._mapSrpgStatusWindow.clearBattler();\\r\\n                this._mapSrpgStatusWindow.close();\\r\\n            }\\r\\n        }\\r\\n        //アクターコマンドウィンドウの開閉\\r\\n\\t\\t\\r\\n        var flag = $gameSystem.srpgActorCommandWindowNeedRefresh();\\r\\n        if (flag[0]) {\\r\\n            if ($gameTemp.forceActorMenuRefresh || (!this._mapSrpgActorCommandWindow.isOpen() && !this._mapSrpgActorCommandWindow.isOpening())) {\\r\\n                $gameTemp.forceActorMenuRefresh = false;\\r\\n\\t\\t\\t\\tthis._mapSrpgActorCommandWindow.setup(flag[1][1]);\\r\\n\\t\\t\\t\\tthis._mapSrpgActorCommandWindow.activate();\\r\\n\\t\\t\\t\\tthis._mapSrpgActorCommandWindow.open();\\r\\n\\t\\t\\t\\tthis._mapSrpgActorCommandWindow.show();\\r\\n\\t\\t\\t\\tif($gameTemp.actorCommandPosition != -1){\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tthis._mapSrpgActorCommandWindow.select($gameTemp.actorCommandPosition);\\r\\n\\t\\t\\t\\t\\t$gameTemp.actorCommandPosition = -1;\\r\\n\\t\\t\\t\\t}\\r\\n            }\\r\\n        } else {\\r\\n            if (this._mapSrpgActorCommandWindow.isOpen() && !this._mapSrpgActorCommandWindow.isClosing()) {\\r\\n                this._mapSrpgActorCommandWindow.close();\\r\\n                this._mapSrpgActorCommandWindow.deactivate();\\r\\n            }\\r\\n        }\\r\\n        //行動アクターの簡易ステータスウィンドウの開閉\\r\\n        var flag = $gameSystem.srpgActorCommandStatusWindowNeedRefresh();\\r\\n        if (!flag) {\\r\\n            flag = [false, null];\\r\\n        }\\r\\n        if (flag[0]) {\\r\\n            if (!this._mapSrpgActorCommandStatusWindow.isOpen() && !this._mapSrpgActorCommandStatusWindow.isOpening()) {\\r\\n                this._mapSrpgActorCommandStatusWindow.setBattler(flag[1][1]);\\r\\n\\t\\t\\t\\tthis._mapSrpgActorCommandStatusWindow.show();\\r\\n            }\\r\\n        } else {\\r\\n            if (this._mapSrpgActorCommandStatusWindow.isOpen() && !this._mapSrpgActorCommandStatusWindow.isClosing()) {\\r\\n                this._mapSrpgActorCommandStatusWindow.clearBattler();\\r\\n            }\\r\\n        }\\r\\n        //予想ウィンドウ・戦闘開始ウィンドウの開閉\\r\\n        var flag = $gameSystem.srpgBattleWindowNeedRefresh();\\r\\n        if (flag[0]) {\\r\\n            if (_srpgPredictionWindowMode === 3) {\\r\\n                this.commandBattleStart();\\r\\n                return;\\r\\n            }\\r\\n            if (!this._mapSrpgTargetWindow.isOpen() && !this._mapSrpgTargetWindow.isOpening()) {\\r\\n                this._mapSrpgTargetWindow.setBattler(flag[2]);\\r\\n                this._mapSrpgTargetWindow.open();\\r\\n\\t\\t\\t\\tthis._mapSrpgTargetWindow.show();\\r\\n            }\\r\\n            if (!this._mapSrpgPredictionWindow.isOpen() && !this._mapSrpgPredictionWindow.isOpening()) {\\r\\n                this._mapSrpgPredictionWindow.setBattler(flag[1], flag[2]);\\r\\n                this._mapSrpgPredictionWindow.open();\\r\\n\\t\\t\\t\\tthis._mapSrpgPredictionWindow.show();\\r\\n            }\\r\\n            if (!this._mapSrpgBattleWindow.isOpen() && !this._mapSrpgBattleWindow.isOpening()) {\\r\\n                this._mapSrpgBattleWindow.setup(flag[1]);\\r\\n\\t\\t\\t\\tthis._mapSrpgBattleWindow.show();\\r\\n            }\\r\\n        } else {\\r\\n            if (this._mapSrpgTargetWindow.isOpen() && !this._mapSrpgTargetWindow.isClosing()) {\\r\\n                this._mapSrpgTargetWindow.clearBattler();\\r\\n                this._mapSrpgTargetWindow.close();\\r\\n            }\\r\\n            if (this._mapSrpgPredictionWindow.isOpen() && !this._mapSrpgPredictionWindow.isClosing()) {\\r\\n                this._mapSrpgPredictionWindow.clearBattler();\\r\\n                this._mapSrpgPredictionWindow.close();\\r\\n            }\\r\\n            if (this._mapSrpgBattleWindow.isOpen() && !this._mapSrpgBattleWindow.isClosing()) {\\r\\n                this._mapSrpgBattleWindow.clearActor();\\r\\n                this._mapSrpgBattleWindow.close();\\r\\n                this._mapSrpgBattleWindow.deactivate();\\r\\n            }\\r\\n        }\\r\\n\\t\\t\\t\\r\\n        \\r\\n        //戦闘開始の処理\\r\\n        if (this._callSrpgBattle == true && this._mapSrpgBattleWindow.isClosed()) {\\r\\n            this._callSrpgBattle = false;\\r\\n            SceneManager.push(Scene_Battle);\\r\\n            return;\\r\\n        }\\r\\n\\t\\t\\r\\n\\t\\tif ($gameMap.isEventRunning() == true) {\\r\\n            return;\\r\\n        }\\r\\n\\t\\t\\r\\n        //アクターフェイズの開始処理\\r\\n        if ($gameSystem.isBattlePhase() === 'actor_phase' && $gameSystem.isSubBattlePhase() === 'initialize') {\\r\\n\\t\\t\\t/*if($gameVariables.value(_turnVarID) != 1){\\r\\n\\t\\t\\t\\t$statCalc.modifyAllWill(\\\"actor\\\", 1);\\t\\t\\t\\t\\r\\n\\t\\t\\t}*/\\r\\n            if (this.isSrpgActorTurnEnd()) {\\r\\n                $gameSystem.srpgStartEnemyTurn(0); //自動行動のアクターが行動する\\r\\n            } else {\\r\\n                $gameSystem.setSubBattlePhase('normal');\\r\\n            }\\r\\n        }      \\r\\n       \\t\\r\\n\\t\\t\\r\\n        //エネミーフェイズの処理\\r\\n        if ($gameSystem.isBattlePhase() === 'AI_phase') {\\r\\n\\t\\t\\t$gameTemp.summaryUnit = null;\\t\\t\\t\\t\\t\\r\\n        }\\r\\n\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t//$gameSystem.isSubBattlePhase() === 'actor_target' || $gameSystem.isSubBattlePhase() === 'actor_target_spirit' || $gameSystem.isSubBattlePhase() === 'actor_map_target_confirm'\\r\\n\\t\\tif ($SRWGameState.canShowSummaries()) {\\r\\n\\t\\t\\tvar currentPosition = {x: $gamePlayer.posX(), y: $gamePlayer.posY()};\\r\\n\\t\\t\\t$gameTemp.previousCursorPosition = currentPosition;\\r\\n\\t\\t\\tvar summaryUnit = $statCalc.activeUnitAtPosition(currentPosition);\\r\\n\\t\\t\\tif(summaryUnit && ($gameSystem.isSubBattlePhase() !== 'actor_map_target_confirm' || $gameTemp.isMapTarget(summaryUnit.event.eventId()))){\\r\\n\\t\\t\\t\\tvar previousUnit = $gameTemp.summaryUnit;\\r\\n\\t\\t\\t\\t$gameTemp.summaryUnit = summaryUnit;\\t\\r\\n\\t\\t\\t\\tif(!_this._summaryWindow.visible || $gameTemp.summaryUnit != previousUnit){\\r\\n\\t\\t\\t\\t\\t_this._summaryWindow.show();\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.startMapAttackResultDisplay = function(){\\r\\n\\t\\t$gameTemp.mapAttackEffectQueue = [];\\r\\n\\t\\tObject.keys($gameTemp.battleEffectCache).forEach(function(cacheRef){\\r\\n\\t\\t\\tvar battleEffect = $gameTemp.battleEffectCache[cacheRef];\\r\\n\\t\\t\\tif(battleEffect.type == \\\"defender\\\"){\\r\\n\\t\\t\\t\\tvar effect = {parameters: {target: battleEffect.ref}};\\r\\n\\t\\t\\t\\tif(battleEffect.isHit){\\r\\n\\t\\t\\t\\t\\teffect.type = \\\"damage\\\";\\r\\n\\t\\t\\t\\t\\teffect.parameters.damage = battleEffect.damageTaken;\\r\\n\\t\\t\\t\\t} else if(battleEffect.isDoubleImage){\\r\\n\\t\\t\\t\\t\\teffect.type = \\\"double_image\\\";\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\teffect.type = \\\"miss\\\";\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t$gameTemp.mapAttackEffectQueue.push(effect);\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\t$gameTemp.battleEffectWindowIsOpen = false;\\r\\n\\t\\t$gameTemp.processingMapAttackEffect = false;\\r\\n\\t\\t$gameSystem.setSubBattlePhase('process_map_attack_queue');\\r\\n\\t}\\r\\n\\t\\r\\n\\tScene_Map.prototype.getAdjustedMapAttackCoordinates = function(originalCoordinates, direction){\\r\\n\\t\\tvar result = JSON.parse(JSON.stringify(originalCoordinates));\\r\\n\\t\\t//default direction is right\\r\\n\\t\\tif(direction == \\\"left\\\"){\\r\\n\\t\\t\\tfor(var i = 0; i < result.length; i++){\\r\\n\\t\\t\\t\\tresult[i][0]*=-1;\\r\\n\\t\\t\\t}\\r\\n\\t\\t} \\r\\n\\t\\tif(direction == \\\"down\\\" || direction == \\\"up\\\"){\\r\\n\\t\\t\\tfor(var i = 0; i < result.length; i++){\\r\\n\\t\\t\\t\\tvar tmp = result[i][0];\\r\\n\\t\\t\\t\\tresult[i][0] = result[i][1];\\r\\n\\t\\t\\t\\tresult[i][1] = tmp;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(direction == \\\"up\\\"){\\r\\n\\t\\t\\t\\tfor(var i = 0; i < result.length; i++){\\r\\n\\t\\t\\t\\t\\tresult[i][1]*=-1;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t} \\t\\r\\n\\t\\treturn result;\\r\\n\\t};\\r\\n\\t\\r\\n    //戦闘終了後の戦闘不能判定\\r\\n    Scene_Map.prototype.srpgBattlerDeadAfterBattle = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\t$gameTemp.deathQueue = [];\\r\\n\\t\\t$gameTemp.destroyTransformQueue = [];\\r\\n\\t\\t\\r\\n\\t\\tObject.keys($gameTemp.battleEffectCache).forEach(function(cacheRef){\\r\\n\\t\\t\\tvar battleEffect = $gameTemp.battleEffectCache[cacheRef];\\r\\n\\t\\t\\tif(battleEffect.isDestroyed){\\r\\n\\t\\t\\t\\tif(battleEffect.ref.SRWStats.mech.destroyTransformInto != null){\\r\\n\\t\\t\\t\\t\\t//$statCalc.transformOnDestruction(battleEffect.ref);\\r\\n\\t\\t\\t\\t\\t$gameTemp.destroyTransformQueue.push({actor: battleEffect.ref, event: battleEffect.ref.event});\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t//battleEffect.ref.event._erased = true;\\r\\n\\t\\t\\t\\t\\t$gameTemp.deathQueue.push({actor: battleEffect.ref, event: $statCalc.getReferenceEvent(battleEffect.ref)});\\r\\n\\t\\t\\t\\t\\tif($statCalc.isShip(battleEffect.ref)){\\r\\n\\t\\t\\t\\t\\t\\tvar boardedUnits = $statCalc.getBoardedUnits(battleEffect.ref)\\r\\n\\t\\t\\t\\t\\t\\tfor(var i = 0; i < boardedUnits.length; i++){\\r\\n\\t\\t\\t\\t\\t\\t\\t$gameTemp.deathQueue.push({actor: boardedUnits[i], event: boardedUnits[i].event});\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t});\\r\\n\\t\\tif($gameTemp.destroyTransformQueue.length){\\r\\n\\t\\t\\t$gameSystem.setSubBattlePhase(\\\"process_destroy_transform_queue\\\");\\r\\n\\t\\t\\tthis.eventBeforeDestruction();\\r\\n\\t\\t} else if($gameTemp.deathQueue.length){\\r\\n\\t\\t\\t$gameSystem.setSubBattlePhase(\\\"process_death_queue\\\");\\r\\n\\t\\t\\tthis.eventBeforeDestruction();\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis.srpgAfterAction();\\r\\n\\t\\t}\\r\\n    };\\r\\n\\r\\n    //行動終了時の処理\\r\\n    //戦闘終了の判定はイベントで行う。\\r\\n    Scene_Map.prototype.srpgAfterAction = function() {\\t\\t\\r\\n\\t\\r\\n\\t\\tfunction processGains(battleEffect){\\r\\n\\t\\t\\tvar subPilots = $statCalc.getSubPilots(battleEffect.ref);\\r\\n\\t\\t\\tvar gainResults = [];\\r\\n\\t\\t\\tsubPilots.forEach(function(id){\\t\\r\\n\\t\\t\\t\\tif($gameActors.actor(id)){\\r\\n\\t\\t\\t\\t\\tgainResults.push({actor: $gameActors.actor(id), expGain: 0, ppGain: battleEffect.ppGain});\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t});\\r\\n\\t\\t\\r\\n\\t\\t\\tvar gainDonors = battleEffect.gainDonors;\\r\\n\\t\\t\\tvar itemDrops = [];\\r\\n\\t\\t\\tgainDonors.forEach(function(gainDonor){\\r\\n\\t\\t\\t\\tif(gainDonor.isDestroyed){\\r\\n\\t\\t\\t\\t\\t$statCalc.addKill(battleEffect.ref);\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tvar itemDrop = -1;\\r\\n\\t\\t\\t\\tif(gainDonor.isDestroyed){\\r\\n\\t\\t\\t\\t\\tvar items = $statCalc.getEquipInfo(gainDonor.ref);\\r\\n\\t\\t\\t\\t\\tif(items[0]){\\r\\n\\t\\t\\t\\t\\t\\titemDrop = items[0].idx;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(itemDrop != -1){\\r\\n\\t\\t\\t\\t\\t$inventoryManager.addItem(itemDrop);\\r\\n\\t\\t\\t\\t\\titemDrops.push(itemDrop);\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tgainResults.forEach(function(entry){\\t\\r\\n\\t\\t\\t\\t\\tvar gain = $battleCalc.performExpCalculation(entry.actor, gainDonor.ref);\\r\\n\\t\\t\\t\\t\\tif(!gainDonor.isDestroyed){\\r\\n\\t\\t\\t\\t\\t\\tgain = Math.floor(gain/10);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tentry.expGain+=gain;\\r\\n\\t\\t\\t\\t});\\r\\n\\t\\t\\t});\\t\\r\\n\\r\\n\\t\\t\\tif($statCalc.isMainTwin(battleEffect.ref)){\\r\\n\\t\\t\\t\\tvar subTwin = battleEffect.ref.subTwin;\\r\\n\\t\\t\\t\\tvar gainModifier = 0.75;\\r\\n\\t\\t\\t\\tif($statCalc.applyStatModsToValue(subTwin, 0, [\\\"full_twin_gains\\\"])){\\r\\n\\t\\t\\t\\t\\tgainModifier = 1;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tgainResults.unshift({actor: subTwin, expGain: Math.floor(battleEffect.expGain * gainModifier), ppGain: Math.floor(battleEffect.ppGain * gainModifier)});\\t\\r\\n\\t\\t\\t}\\t\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tgainResults.unshift({actor: battleEffect.ref, expGain: battleEffect.expGain, ppGain: battleEffect.ppGain});\\t\\t\\t\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tvar expResults = [];\\r\\n\\t\\t\\tgainResults.forEach(function(entry){\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t$statCalc.addPP(entry.actor, battleEffect.ppGain);\\r\\n\\t\\t\\t\\texpResults.push({actor: entry.actor, details: $statCalc.addExp(entry.actor, entry.expGain)});\\t\\t\\t\\t\\r\\n\\t\\t\\t});\\t\\t\\t\\t\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t$gameTemp.rewardsInfo = {\\r\\n\\t\\t\\t\\t//actor: battleEffect.ref,\\r\\n\\t\\t\\t\\tlevelResult: expResults,\\r\\n\\t\\t\\t\\t//expGain: battleEffect.expGain,\\r\\n\\t\\t\\t\\t//ppGain: battleEffect.ppGain,\\r\\n\\t\\t\\t\\titemDrops: itemDrops,\\r\\n\\t\\t\\t\\tfundGain: battleEffect.fundGain,\\r\\n\\t\\t\\t\\tgainResults: gainResults\\r\\n\\t\\t\\t};\\r\\n\\t\\t}\\r\\n\\t\\r\\n\\t\\tfunction applyCostsToActor(actor, weapon, battleResult){\\r\\n\\t\\t\\tif(actor && weapon && battleResult){\\t\\t\\t\\r\\n\\t\\t\\t\\tvar targetActors = [actor];\\r\\n\\t\\t\\t\\tif(weapon.isCombination){\\r\\n\\t\\t\\t\\t\\ttargetActors  = targetActors.concat($statCalc.getCombinationWeaponParticipants(actor, weapon).participants);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\ttargetActors.forEach(function(actor){\\r\\n\\t\\t\\t\\t\\tif(actor && actor.SRWStats && actor.SRWStats.mech){\\r\\n\\t\\t\\t\\t\\t\\tvar ENCost = battleResult.ENUsed;\\r\\n\\t\\t\\t\\t\\t\\tENCost = $statCalc.applyStatModsToValue(actor, ENCost, [\\\"EN_cost\\\"]);\\r\\n\\t\\t\\t\\t\\t\\tif(battleResult.barrierCost){\\r\\n\\t\\t\\t\\t\\t\\t\\tENCost+=battleResult.barrierCost;\\r\\n\\t\\t\\t\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\tactor.setMp(actor.mp - Math.floor(ENCost));\\r\\n\\t\\t\\t\\t\\t\\tif(weapon){\\r\\n\\t\\t\\t\\t\\t\\t\\tweapon.currentAmmo-=battleResult.ammoUsed;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t});\\t\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\tfunction applyStatusConditions(attacker, defender, hasFury){\\r\\n\\t\\t\\tvar resistance = $statCalc.applyMaxStatModsToValue(defender, 0, [\\\"status_resistance\\\"]);\\r\\n\\t\\t\\tif(resistance < 1 || (hasFury && resistance == 1)){\\t\\t\\t\\r\\n\\t\\t\\t\\tif($statCalc.applyStatModsToValue(attacker, 0, [\\\"inflict_accuracy_down\\\"])){\\r\\n\\t\\t\\t\\t\\t$statCalc.setAccuracyDown(defender);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif($statCalc.applyStatModsToValue(attacker, 0, [\\\"inflict_mobility_down\\\"])){\\r\\n\\t\\t\\t\\t\\t$statCalc.setMobilityDown(defender);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif($statCalc.applyStatModsToValue(attacker, 0, [\\\"inflict_armor_down\\\"])){\\r\\n\\t\\t\\t\\t\\t$statCalc.setArmorDown(defender);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif($statCalc.applyStatModsToValue(attacker, 0, [\\\"inflict_move_down\\\"])){\\r\\n\\t\\t\\t\\t\\t$statCalc.setMovementDown(defender);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif($statCalc.applyStatModsToValue(attacker, 0, [\\\"inflict_attack_down\\\"])){\\r\\n\\t\\t\\t\\t\\t$statCalc.setAttackDown(defender);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif($statCalc.applyStatModsToValue(attacker, 0, [\\\"inflict_range_down\\\"])){\\r\\n\\t\\t\\t\\t\\t$statCalc.setRangeDown(defender);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tvar SPReduction = $statCalc.applyStatModsToValue(attacker, 0, [\\\"inflict_SP_down\\\"]);\\r\\n\\t\\t\\t\\t$statCalc.applySPCost(defender, SPReduction);\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tvar willReduction = $statCalc.applyStatModsToValue(attacker, 0, [\\\"inflict_will_down\\\"]);\\r\\n\\t\\t\\t\\t$statCalc.modifyWill(defender, willReduction * -1);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t$gameTemp.clearMoveTable();\\r\\n\\t\\tif($gameTemp.mapAttackOccurred){\\r\\n\\t\\t\\tObject.keys($gameTemp.battleEffectCache).forEach(function(cacheRef){\\r\\n\\t\\t\\t\\tvar battleEffect = $gameTemp.battleEffectCache[cacheRef];\\r\\n\\t\\t\\t\\tif(battleEffect.ref && !battleEffect.ref.isActor()){\\r\\n\\t\\t\\t\\t\\tbattleEffect.ref.setSquadMode(\\\"normal\\\");\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(battleEffect.attacked && battleEffect.attacked.ref && !battleEffect.attacked.ref.isActor()){\\r\\n\\t\\t\\t\\t\\tbattleEffect.attacked.ref.setSquadMode(\\\"normal\\\");\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tapplyCostsToActor(battleEffect.ref, battleEffect.action.attack, battleEffect);\\r\\n\\t\\t\\t\\tif(battleEffect.damageTaken){\\r\\n\\t\\t\\t\\t\\tvar oldHP = $statCalc.getCalculatedMechStats(battleEffect.ref).currentHP;\\r\\n\\t\\t\\t\\t\\tbattleEffect.ref.setHp(oldHP - battleEffect.damageTaken);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tvar defenderPersonalityInfo = $statCalc.getPersonalityInfo(battleEffect.ref);\\r\\n\\t\\t\\t\\tvar attackerPersonalityInfo = $statCalc.getPersonalityInfo(battleEffect.attackedBy);\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tif(battleEffect.attackedBy && battleEffect.isDestroyed){\\r\\n\\t\\t\\t\\t\\t$statCalc.modifyWill(battleEffect.attackedBy.ref, Math.floor((attackerPersonalityInfo.destroy || 0) / 2));\\r\\n\\t\\t\\t\\t\\t//$statCalc.modifyAllWill(battleEffect.isActor ? \\\"actor\\\" : \\\"enemy\\\", 1);\\t\\r\\n\\t\\t\\t\\t\\t$statCalc.applyEnemyDestroyedWill($gameSystem.getFactionId(battleEffect.attackedBy.ref));\\t\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(battleEffect.isAttacked){\\t\\t\\r\\n\\t\\t\\t\\t\\tif(!battleEffect.isHit){\\r\\n\\t\\t\\t\\t\\t\\t$statCalc.modifyWill(battleEffect.ref, $statCalc.applyStatModsToValue(battleEffect.ref, 0, [\\\"evade_will\\\"]));\\r\\n\\t\\t\\t\\t\\t\\t$statCalc.modifyWill(battleEffect.ref, defenderPersonalityInfo.evade);\\r\\n\\t\\t\\t\\t\\t\\t$statCalc.incrementEvadeCount(battleEffect.ref);\\r\\n\\t\\t\\t\\t\\t} else {\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\t$statCalc.resetEvadeCount(battleEffect.ref);\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(battleEffect.isHit){\\t\\t\\r\\n\\t\\t\\t\\t\\t$statCalc.modifyWill(battleEffect.ref, defenderPersonalityInfo.damage);\\r\\n\\t\\t\\t\\t\\t$statCalc.modifyWill(battleEffect.ref, $statCalc.applyStatModsToValue(battleEffect.ref, 0, [\\\"damage_will\\\"]));\\r\\n\\t\\t\\t\\t\\tif(battleEffect.attackedBy){\\r\\n\\t\\t\\t\\t\\t\\tapplyStatusConditions(battleEffect.attackedBy.ref, battleEffect.ref, battleEffect.hasFury);\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(battleEffect.type == \\\"initiator\\\"){\\r\\n\\t\\t\\t\\t\\t$statCalc.clearNonMapAttackCounter(battleEffect.ref);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tif(battleEffect.isActor && battleEffect.type == \\\"initiator\\\"){\\t\\r\\n\\t\\t\\t\\t\\tprocessGains(battleEffect);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t});\\t\\r\\n\\t\\t\\t$gameTemp.mapAttackOccurred = false;\\r\\n\\t\\t\\tif($gameTemp.isEnemyAttack){\\r\\n\\t\\t\\t\\tthis.srpgAfterAction();\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t$gameParty.gainGold($gameTemp.rewardsInfo.fundGain);\\t\\r\\n\\t\\t\\t\\t$gameTemp.rewardsDisplayTimer = 20;\\t\\r\\n\\t\\t\\t\\t$gameSystem.setSubBattlePhase(\\\"rewards_display\\\");\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t$gameTemp.pushMenu = \\\"rewards\\\";\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t} else if($gameTemp.battleOccurred){\\r\\n\\t\\t\\tvar actorIsDestroyed = false;\\r\\n\\t\\t\\tif($gameTemp.supportAttackCandidates){\\r\\n\\t\\t\\t\\t$gameTemp.supportAttackCandidates.forEach(function(candidate){\\r\\n\\t\\t\\t\\t\\tcandidate.actor.isSupport = false;\\r\\n\\t\\t\\t\\t\\tif(candidate.actor.subTwin){\\r\\n\\t\\t\\t\\t\\t\\tcandidate.actor.subTwin.isSupport = false;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t});\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tObject.keys($gameTemp.battleEffectCache).forEach(function(cacheRef){\\r\\n\\t\\t\\t\\tvar battleEffect = $gameTemp.battleEffectCache[cacheRef];\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tif(battleEffect.ref){\\r\\n\\t\\t\\t\\t\\tif(battleEffect.HPRestored){\\r\\n\\t\\t\\t\\t\\t\\t$statCalc.recoverHP(battleEffect.ref, battleEffect.HPRestored);\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tif(battleEffect.ref && !battleEffect.ref.isActor()){\\r\\n\\t\\t\\t\\t\\tbattleEffect.ref.setSquadMode(\\\"normal\\\");\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(battleEffect.attacked && battleEffect.attacked.ref && !battleEffect.attacked.ref.isActor()){\\r\\n\\t\\t\\t\\t\\tbattleEffect.attacked.ref.setSquadMode(\\\"normal\\\");\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tapplyCostsToActor(battleEffect.ref, battleEffect.action.attack, battleEffect);\\r\\n\\t\\t\\t\\tif(battleEffect.hasActed && battleEffect.attacked){\\r\\n\\t\\t\\t\\t\\tvar oldHP = $statCalc.getCalculatedMechStats(battleEffect.attacked.ref).currentHP;\\r\\n\\t\\t\\t\\t\\tbattleEffect.attacked.ref.setHp(oldHP - battleEffect.damageInflicted);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(battleEffect.hasActed && battleEffect.attacked_all_sub){\\r\\n\\t\\t\\t\\t\\tvar oldHP = $statCalc.getCalculatedMechStats(battleEffect.attacked_all_sub.ref).currentHP;\\r\\n\\t\\t\\t\\t\\tbattleEffect.attacked_all_sub.ref.setHp(oldHP - battleEffect.damageInflicted_all_sub);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tvar personalityInfo = $statCalc.getPersonalityInfo(battleEffect.ref);\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tif(battleEffect.attacked && battleEffect.attacked.isDestroyed){\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t$statCalc.modifyWill(battleEffect.ref, personalityInfo.destroy || 0);\\r\\n\\t\\t\\t\\t\\t//$statCalc.modifyAllWill(battleEffect.isActor ? \\\"actor\\\" : \\\"enemy\\\", 1);\\t\\r\\n\\t\\t\\t\\t\\t$statCalc.applyEnemyDestroyedWill($gameSystem.getFactionId(battleEffect.ref));\\t\\r\\n\\t\\t\\t\\t}\\t\\r\\n\\t\\t\\t\\tif(battleEffect.isAttacked){\\t\\t\\r\\n\\t\\t\\t\\t\\tif(!battleEffect.isHit){\\r\\n\\t\\t\\t\\t\\t\\t;\\r\\n\\t\\t\\t\\t\\t\\t$statCalc.incrementEvadeCount(battleEffect.ref);\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\t$statCalc.resetEvadeCount(battleEffect.ref);\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(battleEffect.isHit){\\t\\t\\r\\n\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(battleEffect.attacked){\\t\\r\\n\\t\\t\\t\\t\\tvar defenderPersonalityInfo = $statCalc.getPersonalityInfo(battleEffect.attacked.ref);\\r\\n\\t\\t\\t\\t\\tif(battleEffect.attacked.isHit){\\r\\n\\t\\t\\t\\t\\t\\t$statCalc.modifyWill(battleEffect.ref, personalityInfo.hit || 0);\\r\\n\\t\\t\\t\\t\\t\\t$statCalc.modifyWill(battleEffect.ref, $statCalc.applyStatModsToValue(battleEffect.ref, 0, [\\\"hit_will\\\"]));\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t$statCalc.modifyWill(battleEffect.attacked.ref, defenderPersonalityInfo.damage || 0);\\r\\n\\t\\t\\t\\t\\t\\t$statCalc.modifyWill(battleEffect.attacked.ref, $statCalc.applyStatModsToValue(battleEffect.attacked.ref, 0, [\\\"damage_will\\\"]));\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\tapplyStatusConditions(battleEffect.ref, battleEffect.attacked.ref, battleEffect.hasFury);\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\t$statCalc.modifyWill(battleEffect.attacked.ref, defenderPersonalityInfo.evade || 0)\\r\\n\\t\\t\\t\\t\\t\\t$statCalc.modifyWill(battleEffect.attacked.ref, $statCalc.applyStatModsToValue(battleEffect.attacked.ref, 0, [\\\"evade_will\\\"]));\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\t$statCalc.modifyWill(battleEffect.ref, personalityInfo.miss || 0);\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\t\\tif(battleEffect.type == \\\"initiator\\\"){\\r\\n\\t\\t\\t\\t\\t$statCalc.incrementNonMapAttackCounter(battleEffect.ref);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(battleEffect.isActor && (battleEffect.type == \\\"initiator\\\" || battleEffect.type == \\\"defender\\\")){\\r\\n\\t\\t\\t\\t\\tif(battleEffect.isDestroyed) {\\r\\n\\t\\t\\t\\t\\t\\tactorIsDestroyed = true;\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\tprocessGains(battleEffect);\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tif(battleEffect.isAttacked){\\r\\n\\t\\t\\t\\t\\t$statCalc.clearSpirit(battleEffect.ref, \\\"alert\\\");\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(battleEffect.isHit){\\r\\n\\t\\t\\t\\t\\t$statCalc.clearSpirit(battleEffect.ref, \\\"persist\\\");\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(battleEffect.type == \\\"support attack\\\"){\\r\\n\\t\\t\\t\\t\\t$statCalc.incrementSupportAttackCounter(battleEffect.ref);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif(battleEffect.type == \\\"support defend\\\" && battleEffect.hasActed){\\r\\n\\t\\t\\t\\t\\t$statCalc.incrementSupportDefendCounter(battleEffect.ref);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif($statCalc.getCalculatedMechStats(battleEffect.ref).currentHP <= 100000){\\r\\n\\t\\t\\t\\t\\t$statCalc.setRevealed(battleEffect.ref);\\r\\n\\t\\t\\t\\t}\\t\\r\\n\\t\\t\\t\\tif(battleEffect.attacked && battleEffect.attacked.ref && $statCalc.getCalculatedMechStats(battleEffect.attacked.ref).currentHP <= 100000){\\r\\n\\t\\t\\t\\t\\t$statCalc.setRevealed(battleEffect.attacked.ref);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t});\\r\\n\\t\\t\\t$gameTemp.battleOccurred = false;\\r\\n\\t\\t\\t$gameTemp.currentBattleResult = null;\\r\\n\\t\\t\\tif(actorIsDestroyed){\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tthis.srpgPrepareNextAction();\\r\\n\\t\\t\\t} else if($gameTemp.rewardsInfo){\\r\\n\\t\\t\\t\\t$gameParty.gainGold($gameTemp.rewardsInfo.fundGain);\\t\\r\\n\\t\\t\\t\\t$gameTemp.rewardsDisplayTimer = 20;\\r\\n\\t\\t\\t\\t$gameSystem.setSubBattlePhase(\\\"rewards_display\\\");\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t/*this._rewardsWindow.refresh();\\r\\n\\t\\t\\t\\t//this._rewardsWindow.open();\\r\\n\\t\\t\\t\\tthis._rewardsWindow.show();\\r\\n\\t\\t\\t\\tthis._rewardsWindow.activate();\\t*/\\r\\n\\t\\t\\t\\t$gameTemp.pushMenu = \\\"rewards\\\";\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tthis.srpgPrepareNextAction();\\r\\n\\t\\t\\t}\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis.srpgPrepareNextAction();\\r\\n\\t\\t}\\r\\n\\t\\t$statCalc.resetCurrentAttack($gameTemp.currentBattleActor);\\t\\r\\n\\t\\t$statCalc.resetCurrentAttack($gameTemp.currentBattleEnemy);\\t\\r\\n\\t}\\t\\r\\n\\t\\r\\n\\tScene_Map.prototype.srpgPrepareNextAction = function(){\\r\\n\\t\\t$gameTemp.rewardsInfo = null;\\t\\r\\n\\t\\tvar battler = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n\\t\\tif(!$gameTemp.isPostMove && $statCalc.applyStatModsToValue(battler, 0, [\\\"hit_and_away\\\"])){\\r\\n\\t\\t\\t$gameTemp.isHitAndAway = true;\\r\\n\\t\\t\\t$gamePlayer.locate($gameTemp.activeEvent().posX(), $gameTemp.activeEvent().posY());\\r\\n\\t\\t\\t$gameSystem.setSrpgActorCommandWindowNeedRefresh($gameSystem.EventToUnit($gameTemp.activeEvent().eventId()));\\r\\n\\t\\t\\t$gameSystem.setSubBattlePhase('actor_command_window');\\t\\t\\t\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n       \\r\\n        battler.srpgCheckFloorEffect($gameTemp.activeEvent().posX(), $gameTemp.activeEvent().posY());\\r\\n\\t\\t\\r\\n\\t\\tif($gameTemp.isPostMove){\\r\\n\\t\\t\\t$statCalc.clearSpirit(battler, \\\"accel\\\");\\r\\n\\t\\t\\t$statCalc.clearSpirit(battler, \\\"charge\\\");\\r\\n\\t\\t}\\r\\n        \\r\\n\\t\\tvar hasDefeatedOpponent;\\r\\n\\t\\tvar battleEffect;\\r\\n\\t\\tif($gameTemp.battleEffectCache){\\r\\n\\t\\t\\tbattleEffect = $gameTemp.battleEffectCache[battler._cacheReference];\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tif(battleEffect && battleEffect.attacked){\\r\\n\\t\\t\\thasDefeatedOpponent\\t= battleEffect.attacked.isDestroyed;\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\tvar hasContinuousAction = $statCalc.applyStatModsToValue(battler, 0, [\\\"continuous_action\\\"]) && !$statCalc.hasUsedContinuousAction(battler);\\r\\n\\t\\t\\r\\n\\t\\tif(hasDefeatedOpponent && hasContinuousAction){\\r\\n\\t\\t\\t$statCalc.setHasUsedContinuousAction(battler);\\r\\n\\t\\t} else if($statCalc.getActiveSpirits(battler).zeal){\\r\\n\\t\\t\\t$statCalc.clearSpirit(battler, \\\"zeal\\\");\\r\\n\\t\\t} else if($statCalc.consumeAdditionalAction(battler)){\\r\\n\\t\\t\\t//do not end turn if an action could be consumed\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif (battler.SRPGActionTimes() <= 1) {\\r\\n\\t\\t\\t\\tbattler.setSrpgTurnEnd(true);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tbattler.useSRPGActionTimes(1);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\t\\r\\n        \\r\\n        $gameSystem.clearSrpgActorCommandWindowNeedRefresh();\\r\\n        $gameSystem.clearSrpgActorCommandStatusWindowNeedRefresh();        \\r\\n        $gameTemp.clearTargetEvent();\\r\\n        $gameParty.clearSrpgBattleActors();\\r\\n        $gameTroop.clearSrpgBattleEnemys();\\r\\n        this.eventAfterAction();\\r\\n        if ($gameSystem.isBattlePhase() === 'actor_phase') {\\r\\n            this.eventUnitEvent();\\r\\n        }\\r\\n        $gameTemp.clearActiveEvent();\\r\\n        if ($gameSystem.isBattlePhase() === 'actor_phase') {\\r\\n            if (this.isSrpgActorTurnEnd()) {\\r\\n                $gameSystem.srpgStartEnemyTurn(0); //自動行動のアクターが行動する\\r\\n            } else {\\r\\n                $gameSystem.setSubBattlePhase('normal');\\r\\n            }\\r\\n        } else if ($gameSystem.isBattlePhase() === 'auto_actor_phase') {\\r\\n            $gameSystem.setSubBattlePhase('auto_actor_command');\\r\\n        } else if ($gameSystem.isBattlePhase() === 'AI_phase') {\\r\\n            $gameSystem.setSubBattlePhase('enemy_command');\\r\\n        }\\r\\n    };\\r\\n\\r\\n    //ユニットイベントの実行\\r\\n    Scene_Map.prototype.eventUnitEvent = function() {\\r\\n        $gameMap.eventsXy($gameTemp.activeEvent().posX(), $gameTemp.activeEvent().posY()).forEach(function(event) {\\r\\n            if (event.isType() === 'unitEvent') {\\r\\n                if (event.pageIndex() >= 0) event.start();\\r\\n                $gameTemp.pushSrpgEventList(event);\\r\\n                $gameSystem.pushSearchedItemList([$gameTemp.activeEvent().posX(), $gameTemp.activeEvent().posY()]);\\r\\n            }\\r\\n        });\\r\\n    };\\r\\n\\r\\n    //行動前イベントの実行\\r\\n    Scene_Map.prototype.eventBeforeBattle = function() {\\r\\n        $gameMap.events().forEach(function(event) {\\r\\n            if (event.isType() === 'beforeBattle') {\\r\\n                if (event.pageIndex() >= 0) event.start();\\r\\n                $gameTemp.pushSrpgEventList(event);\\r\\n            }\\r\\n        });\\r\\n\\t\\tif ($gameTemp.isSrpgEventList()) {\\r\\n            var event = $gameTemp.shiftSrpgEventList();\\r\\n            if (event.isStarting()) {\\r\\n                event.clearStartingFlag();\\r\\n                $gameMap._interpreter.setup(event.list(), event.eventId());\\r\\n            }\\r\\n        }\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.eventBeforeDestruction = function() {\\r\\n        $gameMap.events().forEach(function(event) {\\r\\n            if (event.isType() === 'beforeDestruction') {\\r\\n                if (event.pageIndex() >= 0) event.start();\\r\\n                $gameTemp.pushSrpgEventList(event);\\r\\n            }\\r\\n        });\\r\\n\\t\\tif ($gameTemp.isSrpgEventList()) {\\r\\n            var event = $gameTemp.shiftSrpgEventList();\\r\\n            if (event.isStarting()) {\\r\\n                event.clearStartingFlag();\\r\\n                $gameMap._interpreter.setup(event.list(), event.eventId());\\r\\n            }\\r\\n        }\\r\\n    };\\r\\n\\r\\n    //行動後イベントの実行\\r\\n    Scene_Map.prototype.eventAfterAction = function() {\\r\\n        $gameMap.events().forEach(function(event) {\\r\\n            if (event.isType() === 'afterAction') {\\r\\n                if (event.pageIndex() >= 0) event.start();\\r\\n                $gameTemp.pushSrpgEventList(event);\\r\\n            }\\r\\n        });\\r\\n    };\\r\\n\\r\\n    //アクターターン終了の判定\\r\\n    Scene_Map.prototype.isSrpgActorTurnEnd = function() {\\r\\n        /*return $gameMap.events().some(function(event) {\\r\\n            var battlerArray = $gameSystem.EventToUnit(event._eventId);\\r\\n            if (battlerArray && battlerArray[0] === 'actor') {\\r\\n                return battlerArray[1].canInput();\\r\\n            }\\r\\n        });*/\\r\\n\\t\\treturn $gameTemp.isTurnEndFlag();\\r\\n    };\\r\\n\\r\\n    //アクターコマンド・攻撃\\r\\n    Scene_Map.prototype.commandAttack = function() {\\r\\n\\t\\tvar _this = this\\r\\n        var actor = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n       /* this._attackWindow.setActor(actor);\\r\\n        this._attackWindow.setStypeId(this._mapSrpgActorCommandWindow.currentExt());\\r\\n        this._attackWindow.refresh();\\r\\n        this._attackWindow.show();\\r\\n        this._attackWindow.activate();*/\\r\\n\\t\\t\\r\\n\\t\\t$gameTemp.summaryUnit = null;\\r\\n\\t\\t\\r\\n\\t\\t$gameTemp.showAllyAttackIndicator = true;\\r\\n\\t\\t$gameTemp.showAllyDefendIndicator = false;\\r\\n\\t\\t$gameTemp.showEnemyAttackIndicator = false;\\r\\n\\t\\t$gameTemp.showEnemyDefendIndicator = true;\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tvar actionBattlerArray = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId());\\r\\n\\t\\t$gameTemp.currentMenuUnit = {\\r\\n\\t\\t\\tactor: actionBattlerArray[1],\\r\\n\\t\\t\\tmech: actionBattlerArray[1].SRWStats.mech\\r\\n\\t\\t};\\r\\n\\t\\t$gameTemp.attackWindowCallback = function(attack){\\r\\n\\t\\t\\t$gameTemp.popMenu = true;\\t\\r\\n\\t\\t\\t$gameTemp.actorAction.type = \\\"attack\\\";  \\r\\n\\t\\t\\t$gameTemp.actorAction.attack = attack;\\r\\n\\t\\t\\t_this.startActorTargeting();\\r\\n\\t\\t};\\t\\t\\r\\n\\t\\t$gameTemp.attackWindowCancelCallback = function(){\\r\\n\\t\\t\\tif($gameTemp.isEnemyAttack){\\r\\n\\t\\t\\t\\t_this._mapSrpgBattleWindow.activate();\\r\\n\\t\\t\\t} else {\\t\\t\\t\\r\\n\\t\\t\\t\\t_this._mapSrpgActorCommandWindow.activate();\\r\\n\\t\\t\\t} \\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\t$gameTemp.pushMenu = \\\"attack_list\\\";\\r\\n    };\\r\\n\\r\\n    //アクターコマンド・スキル\\r\\n    Scene_Map.prototype.commandSkill = function() {\\r\\n        var actor = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n        this._skillWindow.setActor(actor);\\r\\n        this._skillWindow.setStypeId(this._mapSrpgActorCommandWindow.currentExt());\\r\\n        this._skillWindow.refresh();\\r\\n        this._skillWindow.show();\\r\\n        this._skillWindow.activate();\\r\\n    };\\r\\n\\r\\n    //アクターコマンド・アイテム\\r\\n    Scene_Map.prototype.commandItem = function() {\\r\\n        this._itemWindow.refresh();\\r\\n        this._itemWindow.show();\\r\\n        this._itemWindow.activate();\\r\\n    };\\r\\n\\t\\r\\n\\t Scene_Map.prototype.commandAbility = function() {\\r\\n        this._abilityWindow.refresh();\\r\\n        this._abilityWindow.show();\\r\\n        this._abilityWindow.activate();\\r\\n    };\\r\\n\\t\\r\\n\\t\\r\\n\\r\\n    //アクターコマンド・装備\\r\\n    Scene_Map.prototype.commandEquip = function() {\\r\\n        SceneManager.push(Scene_Equip);\\r\\n    };\\r\\n\\r\\n    //アクターコマンド・待機\\r\\n    Scene_Map.prototype.commandWait = function() {\\r\\n\\t\\t$gameTemp.isPostMove = true;\\r\\n\\t\\tvar actor = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n\\t\\t$statCalc.clearTwinPositionInfo(actor);\\r\\n\\t\\tactor.onAllActionsEnd();\\r\\n\\t\\tthis.srpgAfterAction();\\t\\t       \\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.commandLand = function() {\\r\\n        var actor = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n\\t\\t$statCalc.setFlying(actor, false);\\r\\n        this._mapSrpgActorCommandWindow.refresh();\\r\\n\\t\\tthis._mapSrpgActorCommandWindow.activate();\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.commandFly = function() {\\r\\n        var actor = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n\\t\\t$statCalc.setFlying(actor, true);\\r\\n        this._mapSrpgActorCommandWindow.refresh();\\r\\n\\t\\tthis._mapSrpgActorCommandWindow.activate();\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.commandSpirit = function() {\\r\\n\\t\\tvar actionBattlerArray = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId());\\r\\n\\t\\t$gameTemp.currentMenuUnit = {\\r\\n\\t\\t\\tactor: actionBattlerArray[1],\\r\\n\\t\\t\\tmech: actionBattlerArray[1].SRWStats.mech\\r\\n\\t\\t};\\r\\n\\t\\t$gameTemp.pushMenu = \\\"spirit_selection\\\";\\r\\n\\t\\tthis._mapSrpgActorCommandWindow.hide()\\r\\n    };\\t\\r\\n\\t\\r\\n\\tScene_Map.prototype.commandDeploy = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tvar actionBattlerArray = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId());\\r\\n\\t\\tthis._deploySelectionWindow.setAvailableUnits($statCalc.getBoardedUnits(actionBattlerArray[1]));\\r\\n\\t\\tthis._deploySelectionWindow.setCurrentSelection(0);\\r\\n      \\t$gameTemp.pushMenu = \\\"boarded_deploy_selection\\\";\\r\\n\\t\\t//this._mapSrpgActorCommandWindow.hide();\\r\\n\\t\\t//this._mapSrpgActorCommandWindow.close();\\r\\n\\t\\t$gameSystem.clearSrpgActorCommandWindowNeedRefresh(actionBattlerArray[1]);\\r\\n\\t\\t\\r\\n\\t\\t$gameTemp.deployWindowCallback = function(deployed){\\r\\n\\t\\t\\tvar shipEvent = $gameTemp.activeEvent();\\r\\n\\t\\t\\t$gameTemp.activeShip = {position: {x: shipEvent.posX(), y: shipEvent.posY()}, actor: $gameSystem.EventToUnit(shipEvent.eventId())[1], event: $gameTemp.activeEvent()};\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t$statCalc.removeBoardedUnit(deployed.actor, $gameTemp.activeShip.actor);\\t\\t\\t\\t\\r\\n\\t\\t\\tvar event = deployed.actor.event;\\r\\n\\t\\t\\tevent.locate($gameTemp.activeEvent().posX(), $gameTemp.activeEvent().posY());\\r\\n\\t\\t\\tevent.appear();\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t$gameMap.setEventImages();\\t\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t$gameTemp.setActiveEvent(event);\\t\\t\\t\\r\\n\\t\\t\\tvar actor = $gameSystem.EventToUnit(event.eventId())[1];\\r\\n\\t\\t\\t//$gameSystem.srpgMakeMoveTable(event);\\r\\n\\t\\t\\tvar battlerArray = actor;\\t\\t\\r\\n\\t\\t\\t$gameSystem.setSrpgActorCommandWindowNeedRefresh($gameSystem.EventToUnit($gameTemp.activeEvent().eventId()));\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t//$gameSystem.setSubBattlePhase('actor_move');\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\t$gameTemp.deployCancelWindowCallback = function(){\\r\\n\\t\\t\\t$gameSystem.setSrpgActorCommandWindowNeedRefresh($gameSystem.EventToUnit($gameTemp.activeEvent().eventId()));\\r\\n\\t\\t}\\r\\n    };\\t\\r\\n\\t\\r\\n\\tScene_Map.prototype.commandBoard = function() {\\r\\n\\t\\tvar event = $gameTemp.activeEvent();\\r\\n       \\tvar actionBattlerArray = $gameSystem.EventToUnit(event.eventId());\\r\\n\\t\\t/*$gameTemp.currentMenuUnit = {\\r\\n\\t\\t\\tactor: actionBattlerArray[1],\\r\\n\\t\\t\\tmech: actionBattlerArray[1].SRWStats.mech\\r\\n\\t\\t};\\r\\n\\t\\t$gameTemp.pushMenu = \\\"spirit_selection\\\";\\r\\n\\t\\tthis._mapSrpgActorCommandWindow.hide()*/\\r\\n\\t\\tif($gameTemp.targetShip){\\r\\n\\t\\t\\t$statCalc.addBoardedUnit(actionBattlerArray[1], $gameTemp.targetShip.actor);\\r\\n\\t\\t\\t$gameSystem.setSrpgWaitMoving(true);\\r\\n            event.srpgMoveToPoint($gameTemp.targetShip.position);\\r\\n\\t\\t\\t$gameTemp.clearMoveTable();\\r\\n\\t\\t\\t$gameTemp.eraseActorAfterTurn = true;\\r\\n\\t\\t\\t$gameSystem.setSubBattlePhase('end_actor_turn');\\r\\n\\t\\t\\t$gameTemp.targetShip = null;\\r\\n\\t\\t}\\r\\n    };\\t\\r\\n\\t\\r\\n\\tScene_Map.prototype.commandHeal = function() {\\r\\n        //var actor = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n\\t\\tvar event = $gameTemp.activeEvent();\\r\\n\\t\\tvar battler = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n\\t\\t$gameTemp.supportType = \\\"heal\\\";        \\r\\n\\t\\t$gameTemp.clearMoveTable();\\r\\n        $gameTemp.initialRangeTable(event.posX(), event.posY(), 1);\\r\\n        event.makeRangeTable(event.posX(), event.posY(), 1, [0], event.posX(), event.posY(), null);\\r\\n        $gameTemp.minRangeAdapt(event.posX(), event.posY(), 0);\\r\\n        $gameTemp.pushRangeListToMoveList();\\r\\n        $gameTemp.setResetMoveList(true);\\r\\n\\t\\t$gameSystem.clearSrpgActorCommandWindowNeedRefresh();\\r\\n\\t\\t$gameSystem.setSubBattlePhase('actor_support');\\r\\n    };\\t\\r\\n\\t\\r\\n\\tScene_Map.prototype.commandResupply = function() {\\r\\n        //var actor = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n\\t\\tvar event = $gameTemp.activeEvent();\\r\\n\\t\\tvar battler = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n\\t\\t$gameTemp.supportType = \\\"resupply\\\";        \\r\\n\\t\\t$gameTemp.clearMoveTable();\\r\\n\\t\\tif(!$statCalc.applyStatModsToValue(battler, 0, [\\\"all_range_resupply\\\"])){\\t\\t\\t\\r\\n\\t\\t\\t$gameTemp.initialRangeTable(event.posX(), event.posY(), 1);\\r\\n\\t\\t\\tevent.makeRangeTable(event.posX(), event.posY(), 1, [0], event.posX(), event.posY(), null);\\r\\n\\t\\t\\t $gameTemp.minRangeAdapt(event.posX(), event.posY(), 0);\\r\\n\\t\\t\\t$gameTemp.pushRangeListToMoveList();\\r\\n\\t\\t\\t$gameTemp.setResetMoveList(true);\\r\\n\\t\\t}           \\r\\n       \\r\\n\\t\\t$gameSystem.clearSrpgActorCommandWindowNeedRefresh();\\r\\n\\t\\t$gameSystem.setSubBattlePhase('actor_support');\\r\\n    };\\t\\r\\n\\t\\r\\n\\t//command version of actor movement\\r\\n\\tScene_Map.prototype.commandMove = function() {\\r\\n\\t\\tvar event = $gameTemp.activeEvent();\\r\\n        var actor = $gameSystem.EventToUnit(event.eventId())[1];\\r\\n        $gameSystem.srpgMakeMoveTable(event);\\r\\n\\t\\tvar battlerArray = actor;\\t\\t\\r\\n\\t\\t$gameSystem.clearSrpgActorCommandWindowNeedRefresh();\\r\\n\\t\\t$gameSystem.setSubBattlePhase('actor_move');\\r\\n    };\\r\\n\\r\\n\\tScene_Map.prototype.transformActorMenuCommand = function() {   \\r\\n\\t\\tvar actor = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n\\t\\tvar list = $statCalc.getTransformationList(actor);\\r\\n\\t\\tif(list.length == 1){\\r\\n\\t\\t\\t$statCalc.transform(actor);\\r\\n\\t\\t\\t$gameSystem.clearSrpgActorCommandWindowNeedRefresh();\\r\\n\\t\\t\\t$gameSystem.setSubBattlePhase('normal');\\r\\n\\t\\t\\tvar se = {};\\r\\n\\t\\t\\tse.name = 'SRWTransform';\\r\\n\\t\\t\\tse.pan = 0;\\r\\n\\t\\t\\tse.pitch = 100;\\r\\n\\t\\t\\tse.volume = 80;\\r\\n\\t\\t\\tAudioManager.playSe(se);\\t\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis._transformWindow.refresh();\\r\\n\\t\\t\\tthis._transformWindow.show();\\r\\n\\t\\t\\tthis._transformWindow.activate();\\r\\n\\t\\t}\\t\\t\\r\\n    };\\t\\r\\n\\t\\r\\n\\tScene_Map.prototype.swapActorMenuCommand = function() {   \\r\\n\\t\\t$statCalc.swap($gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1]);\\r\\n\\t\\t$gameSystem.clearSrpgActorCommandWindowNeedRefresh();\\r\\n\\t\\t$gameSystem.setSubBattlePhase('normal');\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.separateActorMenuCommand = function() {   \\r\\n\\t\\t$statCalc.separate($gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1]);\\r\\n\\t\\t$gameSystem.clearSrpgActorCommandWindowNeedRefresh();\\r\\n\\t\\t$gameSystem.setSubBattlePhase('normal');\\r\\n    };\\t\\r\\n\\t\\r\\n\\tScene_Map.prototype.joinActorMenuCommand = function() {   \\r\\n\\t\\t//$statCalc.separate($gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1]);\\r\\n\\t\\t\\r\\n\\t\\t$gameSystem.highlightedActionTiles = [];\\r\\n\\t\\t$gameSystem.highlightsRefreshed = true;\\r\\n\\t\\tvar x = $gameTemp.activeEvent().posX();\\r\\n\\t\\tvar y = $gameTemp.activeEvent().posY();\\r\\n\\t\\t\\r\\n\\t\\t$gameSystem.highlightedActionTiles.push({x: x-1, y: y+1, color: \\\"#009bff\\\"});\\r\\n\\t\\t$gameSystem.highlightedActionTiles.push({x: x, y: y+1, color: \\\"#009bff\\\"});\\r\\n\\t\\t$gameSystem.highlightedActionTiles.push({x: x+1, y: y+1, color: \\\"#009bff\\\"});\\r\\n\\t\\t$gameSystem.highlightedActionTiles.push({x: x-1, y: y, color: \\\"#009bff\\\"});\\r\\n\\t\\t$gameSystem.highlightedActionTiles.push({x: x+1, y: y, color: \\\"#009bff\\\"});\\r\\n\\t\\t$gameSystem.highlightedActionTiles.push({x: x-1, y: y-1, color: \\\"#009bff\\\"});\\r\\n\\t\\t$gameSystem.highlightedActionTiles.push({x: x, y: y-1, color: \\\"#009bff\\\"});\\r\\n\\t\\t$gameSystem.highlightedActionTiles.push({x: x+1, y: y-1, color: \\\"#009bff\\\"});\\r\\n\\t\\t\\r\\n\\t\\t$gameSystem.clearSrpgActorCommandWindowNeedRefresh();\\r\\n\\t\\t$gameSystem.setSubBattlePhase('twin_selection');\\r\\n    };\\t\\r\\n\\t\\r\\n\\tScene_Map.prototype.splitActorMenuCommand = function() {   \\r\\n\\t\\t$statCalc.split($gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1]);\\r\\n\\t\\t$gameSystem.clearSrpgActorCommandWindowNeedRefresh();\\r\\n\\t\\t$gameSystem.setSubBattlePhase('normal');\\r\\n\\t\\tvar se = {};\\r\\n\\t\\tse.name = 'SRWTransform';\\r\\n\\t\\tse.pan = 0;\\r\\n\\t\\tse.pitch = 100;\\r\\n\\t\\tse.volume = 80;\\r\\n\\t\\tAudioManager.playSe(se);\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.combineActorMenuCommand = function() {   \\r\\n\\t\\t$statCalc.combine($gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1]);\\r\\n\\t\\t$gameSystem.clearSrpgActorCommandWindowNeedRefresh();\\r\\n\\t\\t$gameSystem.setSubBattlePhase('normal');\\r\\n\\t\\tvar se = {};\\r\\n\\t\\tse.name = 'SRWTransform';\\r\\n\\t\\tse.pan = 0;\\r\\n\\t\\tse.pitch = 100;\\r\\n\\t\\tse.volume = 80;\\r\\n\\t\\tAudioManager.playSe(se);\\r\\n    };\\r\\n\\t\\t\\r\\n\\tScene_Map.prototype.persuadeActorMenuCommand = function() {\\r\\n\\t\\t$gameTemp.isPostMove = true;\\r\\n\\t\\tvar actor = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n\\t\\tvar persuadeOption = $gameSystem.getPersuadeOption(actor);\\r\\n\\t\\t$gameVariables.setValue(persuadeOption.controlVar, 1);\\r\\n\\t\\tactor.onAllActionsEnd();\\r\\n\\t\\tthis.srpgAfterAction();\\t       \\r\\n    };\\r\\n\\r\\n    //アクターコマンド・キャンセル\\r\\n    Scene_Map.prototype.cancelActorMenuCommand = function() {\\r\\n        $gameSystem.clearSrpgActorCommandWindowNeedRefresh();\\r\\n\\t\\tif($gameTemp.activeShip && !$gameTemp.isPostMove){\\r\\n\\t\\t\\tvar event = $gameTemp.activeEvent();\\r\\n\\t\\t\\tvar actor = $gameSystem.EventToUnit(event.eventId())[1];\\r\\n\\t\\t\\t$statCalc.addBoardedUnit(actor, $gameTemp.activeShip.actor);\\t\\t\\t\\r\\n\\t\\t\\t//event.locate($gameTemp.activeEvent().posX(), $gameTemp.activeEvent().posY());\\r\\n\\t\\t\\tevent.erase();\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t//$gameMap.setEventImages();\\t\\r\\n\\t\\t\\t$gameTemp.setActiveEvent($gameTemp.activeShip.actor.event);\\r\\n\\t\\t\\t$gameTemp.forceActorMenuRefresh = true;\\r\\n\\t\\t\\t$gameSystem.setSrpgActorCommandWindowNeedRefresh($gameSystem.EventToUnit($gameTemp.activeEvent().eventId()));\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t$gameTemp.activeShip = null;\\r\\n\\t\\t} else if($gameSystem.isSubBattlePhase() == \\\"confirm_boarding\\\"){\\r\\n\\t\\t\\t$gameSystem.setSubBattlePhase('actor_move');\\r\\n\\t\\t} else if($gameTemp.isPostMove){\\r\\n\\t\\t\\t$gameSystem.setSubBattlePhase('actor_move');\\r\\n\\t\\t\\tif($gameTemp.hasTwinned){\\r\\n\\t\\t\\t\\t$gameTemp.hasTwinned = false;\\r\\n\\t\\t\\t\\t$statCalc.separate($gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t//var event = $gameTemp.activeEvent();\\r\\n\\t\\t\\t//event.locate($gameTemp.originalPos()[0], $gameTemp.originalPos()[1]);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t$gameTemp.clearActiveEvent();\\r\\n\\t\\t\\t$gameSystem.setSubBattlePhase('normal');\\r\\n\\t\\t}        \\r\\n    };\\r\\n\\r\\n    //スキルコマンド・決定\\r\\n    Scene_Map.prototype.onSkillOk = function() {\\r\\n        var skill = this._skillWindow.item();\\r\\n        var actor = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n        actor.action(0).setSkill(skill.id);\\r\\n        this._skillWindow.hide();\\r\\n        this.startActorTargeting();\\r\\n    };\\r\\n\\r\\n    //スキルコマンド・キャンセル\\r\\n    Scene_Map.prototype.onSkillCancel = function() {\\r\\n        this._skillWindow.hide();\\r\\n        this._mapSrpgActorCommandWindow.activate();\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.onAttackOk = function() {\\r\\n        var weapon = this._attackWindow.item();\\r\\n\\t\\t$gameTemp.actorAction.type = \\\"attack\\\";  \\r\\n\\t\\t$gameTemp.actorAction.attack = weapon;       \\r\\n        this._attackWindow.hide();\\t\\t\\r\\n\\t\\tif($gameTemp.isEnemyAttack){\\r\\n\\t\\t\\tthis._mapSrpgPredictionWindow.refresh();\\r\\n\\t\\t\\tthis._mapSrpgBattleWindow.refresh();\\r\\n\\t\\t\\tthis._mapSrpgBattleWindow.activate();\\r\\n\\t\\t} else {\\t\\t\\t\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tthis.startActorTargeting();\\r\\n\\t\\t}           \\r\\n    };\\t\\r\\n\\t\\r\\n\\tScene_Map.prototype.onAttackCancel = function() {\\r\\n\\t\\tthis._attackWindow.hide();\\r\\n\\t\\tif($gameTemp.isEnemyAttack){\\r\\n\\t\\t\\tthis._mapSrpgBattleWindow.activate();\\r\\n\\t\\t} else {\\t\\t\\t\\r\\n\\t\\t\\tthis._mapSrpgActorCommandWindow.activate();\\r\\n\\t\\t}        \\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.onCounterSelected = function() {\\r\\n        this._counterWindow.hide();\\r\\n        $gameTemp.actorAction.type = \\\"attack\\\";\\r\\n\\t\\t/*\\r\\n\\t\\tthis._attackWindow.setActor($gameTemp.currentBattleActor);\\r\\n        this._attackWindow.setStypeId(this._mapSrpgActorCommandWindow.currentExt());\\r\\n        this._attackWindow.refresh();\\r\\n        this._attackWindow.show();\\r\\n        this._attackWindow.activate();*/\\r\\n\\t\\r\\n\\t\\t$gameTemp.currentMenuUnit = {\\r\\n\\t\\t\\tactor: $gameTemp.currentBattleActor,\\r\\n\\t\\t\\tmech: $gameTemp.currentBattleActor.SRWStats.mech\\r\\n\\t\\t};\\r\\n\\t\\t$gameTemp.pushMenu = \\\"attack_list\\\";\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.onDefendSelected = function() {\\r\\n        this._counterWindow.hide();\\r\\n        $gameTemp.actorAction.type = \\\"defend\\\";\\r\\n\\t\\tthis._mapSrpgPredictionWindow.refresh();\\r\\n\\t\\tthis._mapSrpgBattleWindow.refresh();\\r\\n\\t\\tthis._mapSrpgBattleWindow.activate();\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.onEvadeSelected = function() {\\r\\n        this._counterWindow.hide();\\r\\n        $gameTemp.actorAction.type = \\\"evade\\\";\\r\\n\\t\\tthis._mapSrpgPredictionWindow.refresh();\\r\\n\\t\\tthis._mapSrpgBattleWindow.refresh();\\r\\n\\t\\tthis._mapSrpgBattleWindow.activate();\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.onCounterCancel = function() {\\r\\n        this._counterWindow.hide();\\r\\n\\t\\tthis._mapSrpgPredictionWindow.refresh();\\r\\n\\t\\tthis._mapSrpgBattleWindow.refresh();\\r\\n\\t\\tthis._mapSrpgBattleWindow.activate();\\r\\n    };\\r\\n    //アイテムコマンド・決定\\r\\n    Scene_Map.prototype.onItemOk = function() {\\r\\n        var item = this._itemWindow.item();\\r\\n        var actor = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n        actor.action(0).setItem(item.id);\\r\\n        this._itemWindow.hide();\\r\\n        this.startActorTargeting();\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.onConsumableOk = function() {\\r\\n        var item = this._itemWindow.item();\\t\\t\\r\\n        var actor = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n\\t\\t$statCalc.setConsumableUsed(actor, item.listIdx);\\r\\n        $itemEffectManager.applyConsumable(actor, item.itemIdx);\\r\\n        this._itemWindow.hide();\\r\\n\\t\\tthis._mapSrpgActorCommandWindow.setup(actor);\\r\\n    };\\r\\n\\t\\r\\n\\r\\n    //アイテムコマンド・キャンセル\\r\\n    Scene_Map.prototype.onItemCancel = function() {\\r\\n        this._itemWindow.hide();\\r\\n        this._mapSrpgActorCommandWindow.activate();\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.onAbilityOk = function() {\\r\\n        var item = this._abilityWindow.item();\\t\\t\\r\\n\\t\\tvar itemDef = $abilityCommandManger.getAbilityDef(item);\\r\\n\\t\\tvar actor = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n\\t\\tif(itemDef && itemDef.isActiveHandler(actor)){\\t\\t\\t\\r\\n\\t\\t\\t$statCalc.setAbilityUsed(actor, item);\\r\\n\\t\\t\\titemDef.statmodHandler(actor);\\r\\n       \\r\\n\\t\\t\\tthis._abilityWindow.hide();\\r\\n\\t\\t\\t$gameSystem.clearSrpgActorCommandWindowNeedRefresh();\\t\\t\\t\\t\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif(itemDef.animId != null && itemDef.animId != -1){\\r\\n\\t\\t\\t\\t$gameSystem.setSubBattlePhase('await_character_anim');\\t\\r\\n\\t\\t\\t\\t$gameTemp.animCharacter = actor.event;\\r\\n\\t\\t\\t\\tactor.event.requestAnimation(itemDef.animId);\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis._abilityWindow.activate();\\r\\n\\t\\t}\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.onTransformOk = function() {\\r\\n\\t\\tvar actor = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n        var item = this._transformWindow.item();\\t\\t\\r\\n\\t\\t$statCalc.transform(actor, 0, true, item);\\r\\n\\t\\t$gameSystem.clearSrpgActorCommandWindowNeedRefresh();\\r\\n\\t\\t$gameSystem.setSubBattlePhase('normal');\\r\\n\\t\\tvar se = {};\\r\\n\\t\\tse.name = 'SRWTransform';\\r\\n\\t\\tse.pan = 0;\\r\\n\\t\\tse.pitch = 100;\\r\\n\\t\\tse.volume = 80;\\r\\n\\t\\tAudioManager.playSe(se);\\r\\n\\t\\tthis._transformWindow.hide();\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.onAbilityCancel = function() {\\r\\n        this._abilityWindow.hide();\\r\\n        this._mapSrpgActorCommandWindow.activate();\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.onTransformCancel = function() {\\r\\n        this._transformWindow.hide();\\r\\n        this._mapSrpgActorCommandWindow.activate();\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.getMapAttackTargets = function(originEvent, attack, type, direction) {\\r\\n\\t\\tvar _this = this;\\t\\r\\n\\t\\tvar result = [];\\r\\n\\t\\tvar deltaX = originEvent.posX();\\r\\n\\t\\tvar deltaY = originEvent.posY();\\r\\n\\t\\t\\r\\n\\t\\tvar mapAttackDef = $mapAttackManager.getDefinition(attack.mapId);\\r\\n\\t\\t\\r\\n\\t\\tvar tileCoordinates = JSON.parse(JSON.stringify(mapAttackDef.shape));\\t\\t\\r\\n\\t\\ttileCoordinates = _this.getAdjustedMapAttackCoordinates(tileCoordinates, direction);\\r\\n\\t\\tfor(var i = 0; i < tileCoordinates.length; i++){\\r\\n\\t\\t\\ttileCoordinates[i].push(true); //is attack range\\r\\n\\t\\t\\ttileCoordinates[i][0]+=deltaX;\\r\\n\\t\\t\\ttileCoordinates[i][1]+=deltaY;\\r\\n\\t\\t\\t//$gameTemp.pushMoveList(tileCoordinates[i]);\\t\\t\\t\\t\\t\\r\\n\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tif(mapAttackDef.retargetInfo){\\r\\n\\t\\t\\tfor(var i = 0; i < tileCoordinates.length; i++){\\r\\n\\t\\t\\t\\tvar deltaX = tileCoordinates[i][0] - mapAttackDef.retargetInfo.center.x;\\r\\n\\t\\t\\t\\tvar deltaY = tileCoordinates[i][1] - mapAttackDef.retargetInfo.center.y;\\r\\n\\t\\t\\t\\tvar retargetCoordinates = JSON.parse(JSON.stringify(mapAttackDef.retargetInfo.shape));\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tfor(var j = 0; j < retargetCoordinates.length; j++){\\r\\n\\t\\t\\t\\t\\tretargetCoordinates[j][0]+=deltaX;\\r\\n\\t\\t\\t\\t\\tretargetCoordinates[j][1]+=deltaY;\\t\\t\\t\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tvar targets = $statCalc.activeUnitsInTileRange(retargetCoordinates || [], type);\\r\\n\\t\\t\\t\\tvar tmp = [];\\r\\n\\t\\t\\t\\tfor(var j = 0; j < targets.length; j++){\\r\\n\\t\\t\\t\\t\\tvar terrain = $statCalc.getCurrentTerrain(targets[j]);\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tvar terrainRank = attack.terrain[terrain];\\r\\n\\t\\t\\t\\t\\tif(terrainRank != \\\"-\\\"){\\r\\n\\t\\t\\t\\t\\t\\ttmp.push(targets[j]);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tresult.push({position: {x: tileCoordinates[i][0], y: tileCoordinates[i][1]}, direction: direction, targets: tmp});\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tvar targets = $statCalc.activeUnitsInTileRange(tileCoordinates || [], type);\\r\\n\\t\\t\\tvar tmp = [];\\r\\n\\t\\t\\tfor(var i = 0; i < targets.length; i++){\\r\\n\\t\\t\\t\\tvar terrain = $statCalc.getCurrentTerrain(targets[i]);\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tvar terrainRank = attack.terrain[terrain];\\r\\n\\t\\t\\t\\tif(terrainRank != \\\"-\\\"){\\r\\n\\t\\t\\t\\t\\ttmp.push(targets[i]);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tresult.push({targets: tmp, direction: direction});\\r\\n\\t\\t}\\r\\n\\t\\treturn result;\\r\\n\\t}\\r\\n\\t\\r\\n\\tScene_Map.prototype.getBestMapAttackTargets = function(originEvent, attack, type) {\\r\\n\\t\\tvar _this = this;\\t\\t\\t\\t\\r\\n\\t\\t\\t\\r\\n\\t\\tvar directions = [\\\"up\\\", \\\"down\\\", \\\"left\\\", \\\"right\\\"];\\r\\n\\t\\tvar maxTargets = -1;\\r\\n\\t\\tvar bestDirection = \\\"up\\\";\\r\\n\\t\\tvar bestPosition;\\r\\n\\t\\tvar bestTargets = [];\\r\\n\\t\\t\\r\\n\\t\\tdirections.forEach(function(direction){\\t\\t\\r\\n\\t\\t\\tvar targetResults = _this.getMapAttackTargets(originEvent, attack, type, direction);\\r\\n\\t\\t\\ttargetResults.forEach(function(targetResult){\\r\\n\\t\\t\\t\\tif(targetResult.targets.length > maxTargets){\\r\\n\\t\\t\\t\\t\\tmaxTargets = targetResult.targets.length;\\r\\n\\t\\t\\t\\t\\tbestDirection = targetResult.direction;\\r\\n\\t\\t\\t\\t\\tbestPosition = targetResult.position;\\r\\n\\t\\t\\t\\t\\tbestTargets = targetResult.targets;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t});\\r\\n\\t\\t\\t\\r\\n\\t\\t});\\r\\n\\t\\treturn {targets: bestTargets, direction: bestDirection, bestPosition: bestPosition};\\r\\n\\t}\\r\\n    //ターゲットの選択開始\\r\\n    Scene_Map.prototype.startActorTargeting = function() {\\r\\n\\t\\tvar _this = this;\\r\\n        var event = $gameTemp.activeEvent();\\r\\n        var battler = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n        var weapon = $gameTemp.actorAction.attack;\\r\\n\\t\\tif(weapon.isMap){\\r\\n\\t\\t\\t$gameTemp.currentBattleActor = battler;\\t\\t\\t\\r\\n\\t\\t\\tvar type;\\r\\n\\t\\t\\tif(battler.isActor()){\\r\\n\\t\\t\\t\\ttype = \\\"enemy\\\";\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\ttype = \\\"actor\\\";\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t$gameTemp.mapTargetDirection = this.getBestMapAttackTargets(event, weapon, type).direction;\\t\\t\\t\\r\\n\\t\\t\\t$statCalc.setCurrentAttack(battler, weapon);\\r\\n\\t\\t\\t$gameSystem.clearSrpgActorCommandWindowNeedRefresh();\\r\\n\\t\\t\\t$gameTemp.OKHeld = true;\\r\\n\\t\\t\\tInput.clear();\\r\\n\\t\\t\\t$gameSystem.setSubBattlePhase('actor_map_target');\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tvar range = $statCalc.getRealWeaponRange(battler, weapon);\\r\\n\\t\\t\\tvar minRange = $statCalc.getRealWeaponMinRange(battler, weapon);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tthis.setUpAttackRange(event.posX(), event.posY(), range, minRange);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t$gameSystem.clearSrpgActorCommandWindowNeedRefresh();\\r\\n\\t\\t\\t$gameSystem.targetLRId = -1;\\r\\n\\t\\t\\t$gameSystem.setSubBattlePhase('actor_target');\\r\\n\\t\\t}\\t\\t\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.setUpAttackRange = function(x, y, range, minRange) {\\r\\n\\t\\t$gameTemp.validTiles = {};\\r\\n\\t\\t$gameSystem.highlightedTiles = [];\\r\\n\\t\\t$gameSystem.highlightsRefreshed = true;\\r\\n\\t\\t$gameTemp.disableHighlightGlow = true;\\r\\n\\t\\tfor(var i = range * -1; i <= range; i++){\\r\\n\\t\\t\\tfor(var j = range * -1; j <= range; j++){\\r\\n\\t\\t\\t\\tvar distance = Math.abs(i) + Math.abs(j);\\r\\n\\t\\t\\t\\tif(distance <= range && distance >= minRange){\\r\\n\\t\\t\\t\\t\\tvar realX = x - i;\\r\\n\\t\\t\\t\\t\\tvar realY = y - j;\\r\\n\\t\\t\\t\\t\\tif(realX >= 0 && realX < $gameMap.width() && realY >=0 && realY <= $gameMap.height()){\\r\\n\\t\\t\\t\\t\\t\\tif(!$gameTemp.validTiles[realX]){\\r\\n\\t\\t\\t\\t\\t\\t\\t$gameTemp.validTiles[realX] = {};\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t$gameTemp.validTiles[realX][realY] = true;\\r\\n\\t\\t\\t\\t\\t\\t$gameSystem.highlightedTiles.push({x: realX, y: realY, color: \\\"#ff3a3a\\\"});\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\t\\r\\n\\t}\\r\\n\\r\\n    //戦闘開始コマンド・戦闘開始\\r\\n    Scene_Map.prototype.commandBattleStart = function() {\\r\\n        var actionArray = $gameSystem.srpgBattleWindowNeedRefresh()[1];\\r\\n\\t\\tvar targetArray = $gameSystem.srpgBattleWindowNeedRefresh()[2];\\r\\n\\t\\tthis._mapSrpgBattleWindow.hide();\\r\\n\\t\\tthis._mapSrpgPredictionWindow.hide();\\r\\n\\t\\tthis._mapSrpgTargetWindow.hide();      \\r\\n\\t\\tthis._mapSrpgActorCommandStatusWindow.hide();\\t\\r\\n\\t\\tthis._mapSrpgStatusWindow.hide();\\t\\t\\r\\n        $gameSystem.clearSrpgStatusWindowNeedRefresh();\\r\\n        $gameSystem.clearSrpgBattleWindowNeedRefresh();\\r\\n        $gameSystem.setSubBattlePhase('invoke_action');\\r\\n        this.srpgBattleStart(actionArray, targetArray);\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.selectCounterAction = function() {\\t\\t\\r\\n\\t\\tthis._counterWindow.show();\\r\\n\\t\\tthis._counterWindow.activate();\\r\\n\\t}\\t\\r\\n\\r\\n    //戦闘開始コマンド・キャンセル\\r\\n    Scene_Map.prototype.selectPreviousSrpgBattleStart = function() {\\r\\n\\t\\tif(!$gameTemp.isEnemyAttack){\\t\\t\\r\\n\\t\\t\\tvar battlerArray = $gameSystem.srpgBattleWindowNeedRefresh()[1];\\r\\n\\t\\t\\t$gameSystem.clearSrpgActorCommandStatusWindowNeedRefresh(battlerArray);\\r\\n\\t\\t\\t$gameSystem.clearSrpgStatusWindowNeedRefresh();\\r\\n\\t\\t\\t$gameSystem.clearSrpgBattleWindowNeedRefresh();\\r\\n\\t\\t\\t$gameTemp.setSrpgDistance(0);\\r\\n\\t\\t\\t$gameTemp.setSrpgSpecialRange(true);\\r\\n\\t\\t\\t$gameTemp.clearTargetEvent();\\r\\n\\t\\t\\t$gameSystem.setSubBattlePhase('actor_target');\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis._mapSrpgBattleWindow.activate();\\r\\n\\t\\t}\\r\\n    };\\r\\n\\r\\n    //メニューからのターン終了処理\\r\\n    Scene_Map.prototype.menuActorTurnEnd = function() {\\r\\n        for (var i = 1; i <= $gameMap.isMaxEventId(); i++) {\\r\\n            var event = $gameMap.event(i);\\r\\n            if (event && !event.isErased() && (event.isType() === 'actor' || event.isType() === 'ship'  || event.isType() === 'ship_event')) {\\r\\n                var battlerArray =  $gameSystem.EventToUnit(event.eventId());\\r\\n\\t\\t\\t\\tif(battlerArray){\\r\\n\\t\\t\\t\\t\\tvar actor = battlerArray[1];\\r\\n\\t\\t\\t\\t\\tif (actor && actor.canInput() == true && !actor.srpgTurnEnd()) {\\r\\n\\t\\t\\t\\t\\t\\tif ($gameTemp.isAutoBattleFlag() == true) {\\r\\n\\t\\t\\t\\t\\t\\t\\tactor.addState(_srpgAutoBattleStateId);\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\t\\t$gameTemp.setActiveEvent(event);\\r\\n\\t\\t\\t\\t\\t\\t\\tactor.onAllActionsEnd();\\r\\n\\t\\t\\t\\t\\t\\t\\tactor.useSRPGActionTimes(99);\\r\\n\\t\\t\\t\\t\\t\\t\\tthis.srpgAfterAction();\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n            }\\r\\n        }\\r\\n        $gameTemp.setAutoBattleFlag(false);\\r\\n        if ($gameSystem.isBattlePhase() === 'actor_phase') {\\r\\n            if (this.isSrpgActorTurnEnd()) {\\r\\n                $gameSystem.srpgStartEnemyTurn(0); //自動行動のアクターが行動する\\r\\n            } else {\\r\\n                $gameSystem.setSubBattlePhase('normal');\\r\\n            }\\r\\n        } else if ($gameSystem.isBattlePhase() === 'AI_phase') {\\r\\n            $gameSystem.setSubBattlePhase('enemy_command');\\r\\n        }\\r\\n        $gameTemp.setTurnEndFlag(false); // 処理終了\\r\\n        return;\\r\\n    };\\r\\n\\r\\n    //アクターコマンドからの装備変更の後処理\\r\\n    Scene_Map.prototype.srpgAfterActorEquip = function() {\\r\\n        var event = $gameTemp.activeEvent();\\r\\n        var battlerArray = $gameSystem.EventToUnit(event.eventId());\\r\\n        $gameTemp.clearMoveTable();\\r\\n        $gameTemp.initialMoveTable($gameTemp.originalPos()[0], $gameTemp.originalPos()[1], battlerArray[1].srpgMove());\\r\\n        event.makeMoveTable($gameTemp.originalPos()[0], $gameTemp.originalPos()[1], $statCalc.getCurrentMoveRange(battlerArray[1]), [0], battlerArray[1]);\\r\\n        var list = $gameTemp.moveList();\\r\\n        for (var i = 0; i < list.length; i++) {\\r\\n            var pos = list[i];\\r\\n            event.makeRangeTable(pos[0], pos[1], battlerArray[1].srpgWeaponRange(), [0], pos[0], pos[1], $dataSkills[battlerArray[1].attackSkillId()]);\\r\\n        }\\r\\n        $gameTemp.pushRangeListToMoveList();\\r\\n        $gameTemp.setResetMoveList(true);\\r\\n        $gameTemp.setSrpgActorEquipFlag(false); // 処理終了\\r\\n        return;\\r\\n    };\\r\\n\\r\\n    //自動行動アクターの行動決定\\r\\n    Scene_Map.prototype.srpgInvokeAutoActorCommand = function() {\\r\\n\\t\\t\\r\\n        for (var i = 1; i <= $gameMap.isMaxEventId() + 1; i++) {\\r\\n            var event = $gameMap.event(i);\\r\\n            if (event && !event.isErased() && (event.isType() === 'actor' || event.isType() === 'ship'  || event.isType() === 'ship_event')) {\\r\\n                var battlerArray =  $gameSystem.EventToUnit(event.eventId());\\r\\n\\t\\t\\t\\tif(battlerArray){\\r\\n\\t\\t\\t\\t\\tvar actor = battlerArray[1];\\r\\n\\t\\t\\t\\t\\tif (actor && actor.canMove() == true && !actor.srpgTurnEnd()) {\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n            }\\r\\n            if (i > $gameMap.isMaxEventId()) {\\r\\n                $gameSystem.srpgStartEnemyTurn(0); // エネミーターンの開始\\r\\n                return;\\r\\n            }\\r\\n        }\\r\\n        actor.makeActions();\\r\\n        if (actor.isConfused()) {\\r\\n            actor.makeConfusionActions();\\r\\n        }\\r\\n        if (_srpgStandUnitSkip === 'true' && actor.battleMode() === 'stand') {\\r\\n            var targetType = this.makeTargetType(actor, 'actor');\\r\\n            $gameTemp.setActiveEvent(event);\\r\\n            $gameSystem.srpgMakeMoveTable(event);\\r\\n            var canAttackTargets = this.srpgMakeCanAttackTargets(enemy, targetType); //行動対象としうるユニットのリストを作成\\r\\n            $gameTemp.clearMoveTable();\\r\\n            if (canAttackTargets.length === 0) {\\r\\n                $gameTemp.setActiveEvent(event);\\r\\n                actor.onAllActionsEnd();\\r\\n                this.srpgAfterAction();\\r\\n                return;\\r\\n            }\\r\\n        }\\r\\n        if (actor.action(0).item()) {\\r\\n            $gameTemp.setAutoMoveDestinationValid(true);\\r\\n            $gameTemp.setAutoMoveDestination(event.posX(), event.posY());\\r\\n            $gameTemp.setActiveEvent(event);\\r\\n            $gameSystem.setSubBattlePhase('auto_actor_move');\\r\\n        } else {\\r\\n            $gameTemp.setActiveEvent(event);\\r\\n            actor.onAllActionsEnd();\\r\\n            this.srpgAfterAction();\\r\\n        }\\r\\n    };\\r\\n\\r\\n    //自動行動アクターの移動先決定と移動実行\\r\\n    Scene_Map.prototype.srpgInvokeAutoActorMove = function() {\\r\\n        var event = $gameTemp.activeEvent();\\r\\n        var type = $gameSystem.EventToUnit(event.eventId())[0];\\r\\n        var actor = $gameSystem.EventToUnit(event.eventId())[1];\\r\\n        var targetType = this.makeTargetType(actor, type);\\r\\n        $gameSystem.srpgMakeMoveTable(event);\\r\\n        this.srpgPriorityTarget(actor); //優先ターゲットの設定\\r\\n        var canAttackTargets = this.srpgMakeCanAttackTargets(actor, targetType); //行動対象としうるユニットのリストを作成\\r\\n        var targetEvent = this.srpgDecideTarget(canAttackTargets, event, targetType); //ターゲットの設定\\r\\n        $gameTemp.setTargetEvent(targetEvent);\\r\\n        if ($gameTemp.isSrpgBestSearchFlag() == true) {\\r\\n            $gameTemp.setSrpgBestSearchFlag(false);\\r\\n            $gameSystem.srpgMakeMoveTable(event);\\r\\n        }\\r\\n        var optimalPos = this.srpgSearchOptimalPos(targetEvent, actor, type);\\r\\n        var route = $gameTemp.MoveTable(optimalPos[0], optimalPos[1])[1];\\r\\n        $gameSystem.setSrpgWaitMoving(true);\\r\\n        event.srpgMoveRouteForce(route);\\r\\n        $gameSystem.setSubBattlePhase('auto_actor_action');\\r\\n    };\\r\\n\\r\\n    //エネミーの行動決定\\r\\n    Scene_Map.prototype.srpgInvokeAICommand = function() {\\r\\n\\t\\tif($gameTemp.currentFaction == -1){\\r\\n\\t\\t\\tvar enemy;\\r\\n\\t\\t\\tvar ctr = 0;\\r\\n\\t\\t\\twhile(!enemy && ctr < $gameTemp.AIActors.length){\\r\\n\\t\\t\\t\\tvar event = $gameTemp.AIActors[ctr];\\t\\r\\n\\t\\t\\t\\tvar candidate = $gameSystem.EventToUnit(event.eventId())[1];\\r\\n\\t\\t\\t\\tif (!$statCalc.hasEndedTurn(candidate)) {\\r\\n\\t\\t\\t\\t\\tenemy = candidate;\\r\\n\\t\\t\\t\\t}\\t\\r\\n\\t\\t\\t\\tctr++;\\t\\r\\n\\t\\t\\t}\\t\\r\\n\\r\\n\\t\\t\\tif (!enemy) {\\r\\n\\t\\t\\t\\t$gameSystem.setBattlePhase('actor_phase');\\r\\n\\t\\t\\t\\t$gameSystem.setSubBattlePhase('initialize');\\t\\t\\t\\t\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\t\\r\\n\\t\\t} else {\\t\\t\\r\\n\\t\\t\\tfor (var i = 1; i <= $gameMap.isMaxEventId() + 1; i++) {\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tvar event = $gameMap.event(i);\\r\\n\\t\\t\\t\\tif (event && event.isType() === 'enemy') {\\r\\n\\t\\t\\t\\t\\tvar enemy = $gameSystem.EventToUnit(event.eventId())[1];\\r\\n\\t\\t\\t\\t\\tif (enemy.canMove() == true && !enemy.srpgTurnEnd() && !event.isErased() && enemy.factionId == $gameTemp.currentFaction) {\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif (i > $gameMap.isMaxEventId()) {\\r\\n\\t\\t\\t\\t\\t$gameTemp.currentFaction++;\\r\\n\\t\\t\\t\\t\\t$gameSystem.srpgStartEnemyTurn($gameTemp.currentFaction); // ターンを終了する\\r\\n\\t\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}            \\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\t$gameTemp.isPostMove = false;\\r\\n\\t\\tif(enemy.battleMode() === 'disabled'){\\r\\n\\t\\t\\t$gameTemp.setActiveEvent(event);\\r\\n\\t\\t\\tenemy.onAllActionsEnd();\\r\\n\\t\\t\\t$gameTemp.AIWaitTimer = 15;\\r\\n\\t\\t\\t$gamePlayer.locate(event.posX(), event.posY());\\t\\t\\r\\n\\t\\t\\tthis.srpgAfterAction();\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n    \\r\\n        if (_srpgStandUnitSkip === 'true' && enemy.battleMode() === 'stand' || enemy.battleMode() === 'fixed') {\\r\\n            $gameTemp.setActiveEvent(event);\\r\\n            $gameSystem.srpgMakeMoveTable(event);\\r\\n            var canAttackTargets = this.srpgMakeCanAttackTargets(enemy); //行動対象としうるユニットのリストを作成\\r\\n            $gameTemp.clearMoveTable();\\r\\n            if (canAttackTargets.length === 0) {\\r\\n                $gameTemp.setActiveEvent(event);\\r\\n                enemy.onAllActionsEnd();\\r\\n\\t\\t\\t\\t$gameTemp.AIWaitTimer = 15;\\r\\n\\t\\t\\t\\t$gamePlayer.locate(event.posX(), event.posY());\\t\\t\\r\\n                this.srpgAfterAction();\\r\\n                return;\\r\\n            }\\r\\n        }\\r\\n\\t\\t\\r\\n\\t\\tif($gameSystem.isEnemy(enemy)){\\r\\n\\t\\t\\t$gameTemp.showAllyAttackIndicator = false;\\r\\n\\t\\t\\t$gameTemp.showAllyDefendIndicator = true;\\r\\n\\t\\t\\t$gameTemp.showEnemyAttackIndicator = true;\\r\\n\\t\\t\\t$gameTemp.showEnemyDefendIndicator = false;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t$gameTemp.showAllyAttackIndicator = true;\\r\\n\\t\\t\\t$gameTemp.showAllyDefendIndicator = false;\\r\\n\\t\\t\\t$gameTemp.showEnemyAttackIndicator = false;\\r\\n\\t\\t\\t$gameTemp.showEnemyDefendIndicator = true;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n        \\t\\t\\r\\n\\t\\t$gameTemp.setActiveEvent(event);\\r\\n\\t\\t$gameSystem.setSubBattlePhase('enemy_move');\\r\\n\\t\\t$gameTemp.AIWaitTimer = 25;\\r\\n\\t\\t$gamePlayer.locate(event.posX(), event.posY());\\t\\t\\t\\r\\n      \\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.doEnemyMapAttack = function(event, isPostMove) {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\tvar enemy = $gameSystem.EventToUnit(event.eventId())[1];\\t\\t\\r\\n\\t\\tvar mapWeapons = $statCalc.getActiveMapWeapons(enemy, isPostMove);\\r\\n\\t\\tvar bestMapAttack;\\r\\n\\t\\tif(mapWeapons.length){\\r\\n\\t\\t\\tmapWeapons.forEach(function(mapWeapon){\\r\\n\\t\\t\\t\\tvar targetInfo = _this.getBestMapAttackTargets(event, mapWeapon, $gameSystem.isEnemy(enemy) ? \\\"actor\\\" : \\\"enemy\\\");\\r\\n\\t\\t\\t\\tif(targetInfo.targets.length && (!bestMapAttack || targetInfo.targets.length > bestMapAttack.targets.length)){\\r\\n\\t\\t\\t\\t\\tbestMapAttack = targetInfo;\\r\\n\\t\\t\\t\\t\\tbestMapAttack.attack = mapWeapon;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t});\\r\\n\\t\\t}\\r\\n\\t\\tif(bestMapAttack){\\r\\n\\t\\t\\t$gameTemp.enemyMapAttackDef = bestMapAttack;\\r\\n\\t\\t\\tvar type = \\\"\\\";\\r\\n\\t\\t\\tif(bestMapAttack.attack.ignoresFriendlies){\\r\\n\\t\\t\\t\\ttype = $gameSystem.isEnemy(enemy) ? \\\"actor\\\" : \\\"enemy\\\";\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tvar targetInfo = _this.getMapAttackTargets(event, bestMapAttack.attack, type, bestMapAttack.direction);\\r\\n\\t\\t\\tif(bestMapAttack.bestPosition){\\t\\t\\t\\t\\r\\n\\t\\t\\t\\ttargetInfo.forEach(function(candidate){\\r\\n\\t\\t\\t\\t\\tif(candidate.position && candidate.position.x == bestMapAttack.bestPosition.x && candidate.position.y == bestMapAttack.bestPosition.y){\\r\\n\\t\\t\\t\\t\\t\\t$gameTemp.currentMapTargets = candidate.targets;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t});\\t\\t\\t\\t\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$gameTemp.mapTargetDirection = bestMapAttack.direction;\\r\\n\\t\\t\\t$gameTemp.currentBattleEnemy = enemy;\\r\\n\\t\\t\\t$gameTemp.enemyAction = {\\r\\n\\t\\t\\t\\ttype: \\\"attack\\\",\\r\\n\\t\\t\\t\\tattack: bestMapAttack.attack,\\r\\n\\t\\t\\t\\ttarget: 0\\r\\n\\t\\t\\t};\\r\\n\\t\\t\\t$gameTemp.clearMoveTable();\\t\\r\\n\\t\\t\\t$gameTemp.setResetMoveList(true);\\r\\n\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\tvar deltaX = event.posX();\\r\\n\\t\\t\\tvar deltaY = event.posY();\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tvar tileCoordinates = JSON.parse(JSON.stringify($mapAttackManager.getDefinition(bestMapAttack.attack.mapId).shape));\\t\\t\\r\\n\\t\\t\\ttileCoordinates = _this.getAdjustedMapAttackCoordinates(tileCoordinates,  bestMapAttack.direction);\\r\\n\\t\\t\\tfor(var i = 0; i < tileCoordinates.length; i++){\\r\\n\\t\\t\\t\\ttileCoordinates[i].push(true); //is attack range\\r\\n\\t\\t\\t\\ttileCoordinates[i][0]+=deltaX;\\r\\n\\t\\t\\t\\ttileCoordinates[i][1]+=deltaY;\\r\\n\\t\\t\\t\\t$gameTemp.pushMoveList(tileCoordinates[i]);\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t$statCalc.setCurrentAttack(enemy, bestMapAttack.attack);\\r\\n\\t\\t\\t_this.enemyMapAttackStart();\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n    //エネミーの移動先決定と移動実行\\r\\n    Scene_Map.prototype.srpgInvokeAIMove = function() {\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\t$gameVariables.setValue(_currentActorId, -1); //ensure no active actor id lingers\\r\\n\\t\\t$gameTemp.enemyWeaponSelection = null;\\r\\n        var event = $gameTemp.activeEvent();\\r\\n        var type = $gameSystem.EventToUnit(event.eventId())[0];\\r\\n        var enemy = $gameSystem.EventToUnit(event.eventId())[1];\\r\\n\\t\\t\\r\\n\\t\\tif(!this.doEnemyMapAttack(event, false)){      \\r\\n\\t\\t\\tthis.srpgPriorityTarget(enemy); //優先ターゲットの設定\\r\\n\\t\\t\\tvar canAttackTargets = this.srpgMakeCanAttackTargets(enemy); //行動対象としうるユニットのリストを作成\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif(canAttackTargets.length){\\t\\t\\r\\n\\t\\t\\t\\tvar targetInfo = this.srpgDecideTarget(canAttackTargets, event); //ターゲットの設定\\r\\n\\t\\t\\t\\t$gameTemp.enemyWeaponSelection = targetInfo.weapon;\\r\\n\\t\\t\\t\\t$gameTemp.setTargetEvent(targetInfo.target);\\r\\n\\t\\t\\t\\tenemy._currentTarget = targetInfo.target;\\r\\n\\t\\t\\t\\tvar alreadyInRange = $battleCalc.isTargetInRange({x: event.posX(), y: event.posY()}, {x: targetInfo.target.posX(), y: targetInfo.target.posY()}, $statCalc.getRealWeaponRange(enemy, targetInfo.weapon), $statCalc.getRealWeaponMinRange(enemy, targetInfo.weapon));\\r\\n\\t\\t\\t\\tif(!alreadyInRange){\\r\\n\\t\\t\\t\\t\\t$gameSystem.srpgMakeMoveTable(event);\\r\\n\\t\\t\\t\\t\\tif ($gameTemp.isSrpgBestSearchFlag() == true) {\\r\\n\\t\\t\\t\\t\\t\\t$gameTemp.setSrpgBestSearchFlag(false);\\r\\n\\t\\t\\t\\t\\t\\t$gameSystem.srpgMakeMoveTable(event);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tvar optimalPos = this.srpgSearchOptimalPos({x: targetInfo.target.posX(), y: targetInfo.target.posY()}, enemy, type, $statCalc.getRealWeaponRange(enemy, targetInfo.weapon), $statCalc.getRealWeaponMinRange(enemy, targetInfo.weapon));\\r\\n\\t\\t\\t\\t\\tif(optimalPos[0] != event.posX() || optimalPos[1] != event.posY()){\\r\\n\\t\\t\\t\\t\\t\\t$gameTemp.isPostMove = true;\\r\\n\\t\\t\\t\\t\\t\\tvar route = $gameTemp.MoveTable(optimalPos[0], optimalPos[1])[1];\\r\\n\\t\\t\\t\\t\\t\\t$gameSystem.setSrpgWaitMoving(true);\\r\\n\\t\\t\\t\\t\\t\\tevent.srpgMoveToPoint({x: optimalPos[0], y: optimalPos[1]});\\r\\n\\t\\t\\t\\t\\t\\t$gamePlayer.setTransparent(true);\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tvar fullRange = $statCalc.getFullWeaponRange(enemy, true);\\r\\n\\t\\t\\t\\t$gameSystem.srpgMakeMoveTable(event);\\r\\n\\t\\t\\t\\tvar targetInfo;\\r\\n\\t\\t\\t\\tvar optimalPos;\\r\\n\\t\\t\\t\\t/*if(enemy._currentTarget && !enemy._currentTarget.isErased()){\\r\\n\\t\\t\\t\\t\\ttargetInfo = {target: enemy._currentTarget};\\r\\n\\t\\t\\t\\t\\toptimalPos = this.srpgSearchOptimalPos({x: targetInfo.target.posX(), y: targetInfo.target.posY()}, enemy, type, fullRange.range, fullRange.minRange);\\r\\n\\t\\t\\t\\t} else */\\r\\n\\t\\t\\t\\tif(enemy.targetRegion != -1 && enemy.targetRegion != null){\\r\\n\\t\\t\\t\\t\\tvar candidatePositions = $gameMap.getRegionTiles(enemy.targetRegion);\\r\\n\\t\\t\\t\\t\\tvar currentBestDist = -1;\\r\\n\\t\\t\\t\\t\\tvar xRef = event.posX();\\r\\n\\t\\t\\t\\t\\tvar yRef = event.posY();\\r\\n\\t\\t\\t\\t\\tfor(var i = 0; i < candidatePositions.length; i++){\\r\\n\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\tvar dist = Math.hypot(xRef-candidatePositions[i].x, yRef-candidatePositions[i].y);\\r\\n\\t\\t\\t\\t\\t\\tif((currentBestDist == -1 || dist < currentBestDist) && ($statCalc.isFreeSpace(candidatePositions[i]) || (xRef == candidatePositions[i].x && yRef == candidatePositions[i].y))){\\r\\n\\t\\t\\t\\t\\t\\t\\toptimalPos = candidatePositions[i];\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tif(!optimalPos){\\r\\n\\t\\t\\t\\t\\t\\tcurrentBestDist = -1;\\r\\n\\t\\t\\t\\t\\t\\tfor(var i = 0; i < candidatePositions.length; i++){\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\t\\tvar dist = Math.hypot(xRef-candidatePositions[i].x, yRef-candidatePositions[i].y);\\r\\n\\t\\t\\t\\t\\t\\t\\tif((currentBestDist == -1 || dist < currentBestDist)){\\r\\n\\t\\t\\t\\t\\t\\t\\t\\toptimalPos = candidatePositions[i];\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tif(optimalPos){\\r\\n\\t\\t\\t\\t\\t\\toptimalPos = this.srpgSearchOptimalPos(optimalPos, enemy, type, -1, 0);\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t} \\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t//check for targets in movement range\\r\\n\\t\\t\\t\\tif(!optimalPos){\\r\\n\\t\\t\\t\\t\\tvar canAttackTargets = this.srpgMakeCanAttackTargetsWithMove(enemy);\\r\\n\\t\\t\\t\\t\\tif(canAttackTargets && canAttackTargets.length){\\r\\n\\t\\t\\t\\t\\t\\ttargetInfo = this.srpgDecideTarget(canAttackTargets, event); //ターゲットの設定\\r\\n\\t\\t\\t\\t\\t\\tif(targetInfo.target){\\r\\n\\t\\t\\t\\t\\t\\t\\tenemy._currentTarget = targetInfo.target;\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\t\\toptimalPos = this.srpgSearchOptimalPos({x: targetInfo.target.posX(), y: targetInfo.target.posY()}, enemy, type, fullRange.range, fullRange.minRange);\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t//check for targets on map\\r\\n\\t\\t\\t\\tif(!optimalPos){\\r\\n\\t\\t\\t\\t\\ttargetInfo = this.srpgDecideTarget($statCalc.getAllActorEvents(\\\"actor\\\"), event); //ターゲットの設定\\r\\n\\t\\t\\t\\t\\tif(targetInfo.target){\\r\\n\\t\\t\\t\\t\\t\\tenemy._currentTarget = targetInfo.target;\\r\\n\\t\\t\\t\\t\\t\\tvar minRange = fullRange.minRange;\\r\\n\\t\\t\\t\\t\\t\\tif(minRange == -1){\\r\\n\\t\\t\\t\\t\\t\\t\\tminRange = 0;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\toptimalPos = this.srpgSearchOptimalPos({x: targetInfo.target.posX(), y: targetInfo.target.posY()}, enemy, type, fullRange.range || -1, minRange, true);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tif(optimalPos){\\r\\n\\t\\t\\t\\t\\t$gameTemp.isPostMove = true;\\r\\n\\t\\t\\t\\t\\tvar route = $gameTemp.MoveTable(optimalPos[0], optimalPos[1])[1];\\r\\n\\t\\t\\t\\t\\t$gameSystem.setSrpgWaitMoving(true);\\r\\n\\t\\t\\t\\t\\tevent.srpgMoveToPoint({x: optimalPos[0], y: optimalPos[1]});\\r\\n\\t\\t\\t\\t\\t$gamePlayer.setTransparent(true);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$gameSystem.setSubBattlePhase('enemy_action');\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n    };\\r\\n\\r\\n    // 行動対象とするユニットのタイプを返す\\r\\n    Scene_Map.prototype.makeTargetType = function(battler, type) {\\r\\n        var targetType = null;\\r\\n        if (battler.isConfused() == true) {\\r\\n            switch (battler.confusionLevel()) {\\r\\n            case 1:\\r\\n                if (type === 'enemy') {\\r\\n                    return 'actor';\\r\\n                } else if (type === 'actor') {\\r\\n                    return 'enemy';\\r\\n                }\\r\\n            case 2:\\r\\n                if (Math.randomInt(2) === 0) {\\r\\n                    if (type === 'enemy') {\\r\\n                        return 'actor';\\r\\n                    } else if (type === 'actor') {\\r\\n                        return 'enemy';\\r\\n                    }\\r\\n                }\\r\\n                if (type === 'enemy') {\\r\\n                    return 'enemy';\\r\\n                } else if (type === 'actor') {\\r\\n                    return 'actor';\\r\\n                }\\r\\n            default:\\r\\n                if (type === 'enemy') {\\r\\n                    return 'enemy';\\r\\n                } else if (type === 'actor') {\\r\\n                    return 'actor';\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if (type === 'enemy' && battler.currentAction().isForOpponent()) {\\r\\n            targetType = 'actor';\\r\\n        } else if (type === 'enemy' && battler.currentAction().isForFriend()) {\\r\\n            targetType = 'enemy';\\r\\n        } else if (type === 'actor' && battler.currentAction().isForOpponent()) {\\r\\n            targetType = 'enemy';\\r\\n        } else if (type === 'actor' && battler.currentAction().isForFriend()) {\\r\\n            targetType = 'actor';\\r\\n        }\\r\\n        return targetType;\\r\\n    };\\r\\n\\r\\n    // 移動力と射程を足した範囲内にいる対象をリストアップする\\r\\n    Scene_Map.prototype.srpgMakeCanAttackTargets = function(battler, targetType) {        \\t\\r\\n\\t\\t//var type = battler.isActor() ? \\\"enemy\\\" : \\\"actor\\\";\\r\\n\\t\\tif(battler.attackBehavior == \\\"none\\\"){\\r\\n\\t\\t\\treturn [];\\r\\n\\t\\t}\\r\\n\\t\\tvar pos = {\\r\\n\\t\\t\\tx: $gameTemp.activeEvent().posX(),\\r\\n\\t\\t\\ty: $gameTemp.activeEvent().posY()\\r\\n\\t\\t};\\r\\n\\t\\tvar fullRange = $statCalc.getFullWeaponRange(battler, $gameTemp.isPostMove);\\r\\n        var targets = $statCalc.getAllInRange($gameSystem.getUnitFactionInfo(battler), pos, fullRange.range, fullRange.minRange);\\r\\n\\t\\tvar tmp = [];\\r\\n\\t\\tfor(var i = 0; i < targets.length; i++){\\r\\n\\t\\t\\tvar actor = $gameSystem.EventToUnit(targets[i].eventId())[1];\\r\\n\\t\\t\\tif($battleCalc.getBestWeapon({actor: battler}, {actor: actor}, false, true, false)){\\r\\n\\t\\t\\t\\ttmp.push(targets[i]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\ttargets = tmp;\\r\\n\\t\\tif(!battler.isActor() && battler.targetUnitId != \\\"\\\" && battler.targetUnitId != -1){\\r\\n\\t\\t\\tvar target;\\r\\n\\t\\t\\tfor(var i = 0; i < targets.length; i++){\\r\\n\\t\\t\\t\\tvar actor = $gameSystem.EventToUnit(targets[i].eventId())[1];\\r\\n\\t\\t\\t\\tif(actor.isActor() && actor.actorId() == battler.targetUnitId){\\r\\n\\t\\t\\t\\t\\ttarget = targets[i];\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(target){\\r\\n\\t\\t\\t\\ttargets = [target];\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\ttargets = [];\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn targets;\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.srpgMakeCanAttackTargetsWithMove = function(battler, targetType) {        \\t\\r\\n\\t\\t//var type = battler.isActor() ? \\\"enemy\\\" : \\\"actor\\\";\\r\\n\\t\\tif(battler.attackBehavior == \\\"none\\\"){\\r\\n\\t\\t\\treturn [];\\r\\n\\t\\t}\\r\\n\\t\\tvar pos = {\\r\\n\\t\\t\\tx: $gameTemp.activeEvent().posX(),\\r\\n\\t\\t\\ty: $gameTemp.activeEvent().posY()\\r\\n\\t\\t};\\r\\n\\t\\tvar fullRange = $statCalc.getFullWeaponRange(battler, true);\\r\\n\\t\\tvar moveRange = $statCalc.getCurrentMoveRange(battler);\\r\\n\\t\\tfullRange.range+=moveRange;\\r\\n        var targets =  $statCalc.getAllInRange($gameSystem.getUnitFactionInfo(battler), pos, fullRange.range, fullRange.minRange);\\r\\n\\t\\tvar tmp = [];\\r\\n\\t\\tfor(var i = 0; i < targets.length; i++){\\r\\n\\t\\t\\tvar actor = $gameSystem.EventToUnit(targets[i].eventId())[1];\\r\\n\\t\\t\\tif($battleCalc.getBestWeapon({actor: battler}, {actor: actor}, false, true, false)){\\r\\n\\t\\t\\t\\ttmp.push(targets[i]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\ttargets = tmp;\\r\\n\\t\\tif(!battler.isActor() && battler.targetUnitId != \\\"\\\" && battler.targetUnitId != -1){\\r\\n\\t\\t\\tvar target;\\r\\n\\t\\t\\tfor(var i = 0; i < targets.length; i++){\\r\\n\\t\\t\\t\\tvar actor = $gameSystem.EventToUnit(targets[i].eventId())[1];\\r\\n\\t\\t\\t\\tif(actor.isActor() && actor.actorId() == battler.targetUnitId){\\r\\n\\t\\t\\t\\t\\ttarget = targets[i];\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(target){\\r\\n\\t\\t\\t\\ttargets = [target];\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\ttargets = [];\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn targets;\\r\\n    };\\r\\n\\r\\n     //優先ターゲットの決定\\r\\n    Scene_Map.prototype.srpgPriorityTarget = function(battler) {\\r\\n        var event = null;\\r\\n        if (battler.battleMode() === 'aimingEvent') {\\r\\n            event = $gameMap.event(battler.targetId());\\r\\n        } else if (battler.battleMode() === 'aimingActor') {\\r\\n            var eventId1 = $gameSystem.ActorToEvent(battler.targetId());\\r\\n            event = $gameMap.event(eventId1);\\r\\n        }\\r\\n        // ターゲットにしたeventが有効でない場合、優先ターゲットは設定しない\\r\\n        if (event) { \\r\\n            var targetBattlerArray = $gameSystem.EventToUnit(event.eventId());\\r\\n            // 優先ターゲットが失われている場合、優先ターゲットは設定しない\\r\\n            if (!(targetBattlerArray && targetBattlerArray[1].isAlive())) event = null;\\r\\n        }\\r\\n        $gameTemp.setSrpgPriorityTarget(event);\\r\\n    }\\r\\n\\r\\n     //ターゲットの決定\\r\\n    Scene_Map.prototype.srpgDecideTarget = function(canAttackTargets, activeEvent, targetType) {\\r\\n        var targetEvent = null;\\r\\n       \\t\\r\\n\\t\\tvar bestTarget;\\r\\n\\t\\tvar bestWeapon;\\r\\n\\t\\tvar bestScore = -1;\\r\\n\\t\\tvar attacker = $gameSystem.EventToUnit(activeEvent.eventId())[1];\\r\\n\\t\\tvar targetsByHit = [];\\r\\n\\t\\tvar priorityTargetId = attacker.targetUnitId;\\r\\n\\t\\tvar priorityTargetEvent = -1;\\r\\n\\t\\t\\r\\n\\t\\tcanAttackTargets.forEach(function(event) {\\r\\n\\t\\t\\tif(!event.isErased()){\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tvar defender = $gameSystem.EventToUnit(event.eventId())[1];\\r\\n\\t\\t\\t\\tif(defender.isActor() && defender.actorId() == priorityTargetId){\\r\\n\\t\\t\\t\\t\\tpriorityTargetEvent = event;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tvar hitRate = $battleCalc.performHitCalculation(\\r\\n\\t\\t\\t\\t\\t{actor: attacker, action: {type: \\\"attack\\\", attack: {hitMod: 0}}},\\r\\n\\t\\t\\t\\t\\t{actor: defender, action: {type: \\\"none\\\"}},\\r\\n\\t\\t\\t\\t\\ttrue\\r\\n\\t\\t\\t\\t);\\r\\n\\t\\t\\t\\ttargetsByHit.push({\\r\\n\\t\\t\\t\\t\\thit: hitRate,\\r\\n\\t\\t\\t\\t\\ttarget: defender,\\r\\n\\t\\t\\t\\t\\tevent: event\\r\\n\\t\\t\\t\\t});\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\tif(priorityTargetEvent != -1){\\r\\n\\t\\t\\tvar defender = $gameSystem.EventToUnit(priorityTargetEvent.eventId())[1];\\r\\n\\t\\t\\ttargetsByHit = [{\\r\\n\\t\\t\\t\\thit: 0,\\r\\n\\t\\t\\t\\ttarget: defender,\\r\\n\\t\\t\\t\\tevent: priorityTargetEvent\\r\\n\\t\\t\\t}];\\r\\n\\t\\t}\\r\\n\\t\\t/*targetsByHit.sort(function(a, b){\\r\\n\\t\\t\\treturn b.hit - a.hit;\\r\\n\\t\\t});*/\\r\\n\\t\\tvar maxHitRate = targetsByHit[0].hit;\\r\\n\\t\\tvar ctr = 0;\\r\\n\\t\\tvar currentHitRate = targetsByHit[0].hit;\\r\\n\\t\\twhile(ctr < targetsByHit.length){\\r\\n\\t\\t\\tvar currentHitRate = targetsByHit[ctr].hit;\\r\\n\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\tvar defender = targetsByHit[ctr].target;\\r\\n\\t\\t\\tvar weaponResult = {};\\r\\n\\t\\t\\tvar weaponResultCurrentPos = $battleCalc.getBestWeaponAndDamage(\\r\\n\\t\\t\\t\\t{actor: attacker, pos: {x: activeEvent.posX(), y:  activeEvent.posY()}},\\r\\n\\t\\t\\t\\t{actor: defender, pos: {x: targetsByHit[ctr].event.posX(), y: targetsByHit[ctr].event.posY()}},\\r\\n\\t\\t\\t\\tfalse,\\r\\n\\t\\t\\t\\tfalse, \\r\\n\\t\\t\\t\\tfalse\\r\\n\\t\\t\\t);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\tvar weaponResultAnyPosPostMove = $battleCalc.getBestWeaponAndDamage(\\r\\n\\t\\t\\t\\t{actor: attacker, pos: {x: activeEvent.posX(), y:  activeEvent.posY()}},\\r\\n\\t\\t\\t\\t{actor: defender, pos: {x: targetsByHit[ctr].event.posX(), y: targetsByHit[ctr].event.posY()}},\\r\\n\\t\\t\\t\\tfalse,\\r\\n\\t\\t\\t\\ttrue, \\r\\n\\t\\t\\t\\ttrue\\r\\n\\t\\t\\t);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif(weaponResultCurrentPos.weapon && weaponResultAnyPosPostMove.weapon){\\r\\n\\t\\t\\t\\tif(weaponResultCurrentPos.damage > weaponResultAnyPosPostMove.damage){\\r\\n\\t\\t\\t\\t\\tweaponResult = weaponResultCurrentPos;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tweaponResult = weaponResultAnyPosPostMove;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t} else if(weaponResultCurrentPos.weapon){\\r\\n\\t\\t\\t\\tweaponResult = weaponResultCurrentPos;\\r\\n\\t\\t\\t} else if(weaponResultAnyPosPostMove.weapon){\\r\\n\\t\\t\\t\\tweaponResult = weaponResultAnyPosPostMove;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tweaponResult = $battleCalc.getBestWeaponAndDamage(\\r\\n\\t\\t\\t\\t\\t{actor: attacker, pos: {x: activeEvent.posX(), y:  activeEvent.posY()}},\\r\\n\\t\\t\\t\\t\\t{actor: defender, pos: {x: targetsByHit[ctr].event.posX(), y: targetsByHit[ctr].event.posY()}},\\r\\n\\t\\t\\t\\t\\tfalse,\\r\\n\\t\\t\\t\\t\\ttrue, \\r\\n\\t\\t\\t\\t\\tfalse\\r\\n\\t\\t\\t\\t);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tvar damage = weaponResult.damage;\\r\\n\\t\\t\\tvar hitrate = currentHitRate;\\r\\n\\t\\t\\tvar canDestroy = weaponResult.damage >= $statCalc.getCalculatedMechStats(defender).currentHP ? 1 : 0;\\r\\n\\t\\t\\tvar formula = ENGINE_SETTINGS.ENEMY_TARGETING_FORMULA || \\\"Math.min(hitrate + 0.01, 1) * (damage + (canDestroy * 5000))\\\";\\r\\n\\t\\t\\tvar score = eval(formula);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif(score > bestScore){\\r\\n\\t\\t\\t\\tbestScore = score;\\r\\n\\t\\t\\t\\tbestTarget = targetsByHit[ctr].event;\\r\\n\\t\\t\\t\\tbestWeapon = weaponResult.weapon\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tctr++;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n        return {target: bestTarget, weapon: bestWeapon};\\r\\n    };\\r\\n\\t\\r\\n\\tfunction coordUtils(startX, startY, chunkRadius){\\r\\n\\t\\tthis.startX = startX;\\r\\n\\t\\tthis.startY = startY;\\r\\n\\t\\tthis.radius = chunkRadius;\\r\\n\\t}\\r\\n\\t\\r\\n\\tcoordUtils.prototype.convertToNormalCoordinate = function(coord){\\r\\n\\t\\t\\treturn Math.floor(coord / 3);\\r\\n\\t}\\r\\n\\t\\r\\n\\tcoordUtils.prototype.convertToExplodedCoordinate = function(coord){\\r\\n\\t\\treturn coord * 3 + 1;\\r\\n\\t}\\r\\n\\t\\r\\n\\tcoordUtils.prototype.convertToGridCoordinate = function(coords){\\r\\n\\t\\treturn {\\r\\n\\t\\t\\tx: coords.x - this.startX + this.radius,\\r\\n\\t\\t\\ty: coords.y - this.startY + this.radius\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\tcoordUtils.prototype.convertToMapCoordinate = function(coords){\\r\\n\\t\\treturn {\\r\\n\\t\\t\\tx: coords.x + this.startX - this.radius,\\r\\n\\t\\t\\ty: coords.y + this.startY - this.radius\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n    // 最適移動位置の探索\\r\\n    Scene_Map.prototype.srpgSearchOptimalPos = function(targetCoords, battler, type, range, minRange, noTargets) {\\r\\n\\t\\tfunction isValidSpace(pos){\\r\\n\\t\\t\\treturn $statCalc.isFreeSpace(pos) || (pos.x == $gameTemp.activeEvent().posX() && pos.y == $gameTemp.activeEvent().posY());\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif(targetCoords.x == battler.event.posX() && targetCoords.y == battler.event.posY()){\\r\\n\\t\\t\\treturn [targetCoords.x, targetCoords.y];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n        if ($gameTemp.isSrpgBestSearchRoute()[0] && \\r\\n            !(battler.battleMode() === 'absRegionUp' || battler.battleMode() === 'absRegionDown')) {\\r\\n            var route = $gameTemp.isSrpgBestSearchRoute()[1].slice(1, battler.srpgMove() + 1);\\r\\n            for (var i = 0; i < battler.srpgMove() + 1; i++) {\\r\\n                var pos = [$gameTemp.activeEvent().posX(), $gameTemp.activeEvent().posY()];\\r\\n                for (var j = 0; j < route.length; j++) {\\r\\n                    var d = route[j];\\r\\n                    if (d == 2) {\\r\\n                        pos[1] += 1;\\r\\n                    } else if (d == 4) {\\r\\n                        pos[0] -= 1;\\r\\n                    } else if (d == 6) {\\r\\n                        pos[0] += 1;\\r\\n                    } else if (d == 8) {\\r\\n                        pos[1] -= 1;\\r\\n                    }\\r\\n                }\\r\\n                if (pos[0] < 0) {\\r\\n                  pos[0] += $gameMap.width();\\r\\n                } else if (pos[0] >= $gameMap.width()) {\\r\\n                  pos[0] -= $gameMap.width();\\r\\n                }\\r\\n                if (pos[1] < 0) {\\r\\n                  pos[1] += $gameMap.height();\\r\\n                } else if (pos[1] >= $gameMap.height()) {\\r\\n                  pos[1] -= $gameMap.height();\\r\\n                }\\r\\n                if (isValidSpace({x: pos[0], y: pos[1]})) {\\r\\n                    break;\\r\\n                } else {\\r\\n                    route.pop();\\r\\n                }\\r\\n            }\\r\\n            $gameTemp.setSrpgBestSearchRoute([null, []]);\\r\\n            return pos;\\r\\n        }\\r\\n        var list = $gameTemp.moveList();\\r\\n\\t\\tlist.push([$gameTemp.activeEvent().posX(), $gameTemp.activeEvent().posY(), false]);\\r\\n\\t\\t\\r\\n\\t\\tvar occupiedPositions = $statCalc.getOccupiedPositionsLookup(battler.isActor() ? \\\"enemy\\\" :  \\\"actor\\\");\\r\\n\\t\\tvar allOccupiedPosition = $statCalc.getOccupiedPositionsLookup();\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tvar detailedAIRadius = 30;\\r\\n\\t\\tvar startX = battler.event.posX();\\r\\n\\t\\tvar startY = battler.event.posY();\\r\\n\\t\\tvar bestDist = -1;\\r\\n\\t\\tvar referencePos = {x: startX, y: startY};\\r\\n\\t\\t\\r\\n\\t\\tvar pathfindingGrid = [];\\r\\n\\t\\tvar directionGrid = [];\\r\\n\\t\\tfor(var i = 0; i < $gameMap.width(); i++){\\t\\t\\t\\r\\n\\t\\t\\tpathfindingGrid[i] = [];\\r\\n\\t\\t\\tdirectionGrid[i] = [];\\t\\t\\t\\r\\n\\t\\t\\tfor(var j = 0; j < $gameMap.height(); j++){\\r\\n\\t\\t\\t\\tvar isCenterPassable = !(occupiedPositions[i] && occupiedPositions[i][j]) && $statCalc.canStandOnTile(battler, {x: i, y: j});\\r\\n\\t\\t\\t\\tvar isTopPassable;\\r\\n\\t\\t\\t\\tvar isBottomPassable;\\r\\n\\t\\t\\t\\tvar isLeftPassable;\\r\\n\\t\\t\\t\\tvar isRightPassable;\\r\\n\\t\\t\\t\\tif(!isCenterPassable || $statCalc.isFlying(battler) || !ENGINE_SETTINGS.USE_TILE_PASSAGE){\\r\\n\\t\\t\\t\\t \\tisTopPassable = isCenterPassable;\\r\\n\\t\\t\\t\\t\\tisBottomPassable = isCenterPassable;\\r\\n\\t\\t\\t\\t\\tisLeftPassable = isCenterPassable;\\r\\n\\t\\t\\t\\t\\tisRightPassable = isCenterPassable;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tisTopPassable = $gameMap.isPassable(i, j, 8);\\r\\n\\t\\t\\t\\t\\tisBottomPassable = $gameMap.isPassable(i, j, 2);\\r\\n\\t\\t\\t\\t\\tisLeftPassable = $gameMap.isPassable(i, j, 4);\\r\\n\\t\\t\\t\\t\\tisRightPassable = $gameMap.isPassable(i, j, 6);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tvar weight = 1 ;\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tif(!$statCalc.isFlying(battler)){\\r\\n\\t\\t\\t\\t\\tweight+=$gameMap.SRPGTerrainTag(i, j);\\r\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tpathfindingGrid[i][j] = isCenterPassable ? weight : 0; \\t\\r\\n\\t\\t\\t\\tdirectionGrid[i][j] = {\\r\\n\\t\\t\\t\\t\\ttop: isTopPassable,\\r\\n\\t\\t\\t\\t\\tbottom: isBottomPassable,\\r\\n\\t\\t\\t\\t\\tleft: isLeftPassable,\\r\\n\\t\\t\\t\\t\\tright: isRightPassable\\r\\n\\t\\t\\t\\t};\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tvar targetDist = minRange || 1;\\r\\n\\t\\tvar currentBestDist = -1;\\r\\n\\t\\tvar improves = true;\\r\\n\\t\\tvar path = [];\\r\\n\\t\\r\\n\\t\\tvar candidatePaths = [];\\r\\n\\t\\tvar targetTileCounter = 0;\\t\\r\\n\\t\\t\\t\\t\\r\\n\\t\\tvar graph = new Graph(pathfindingGrid, directionGrid);\\r\\n\\t\\t\\r\\n\\t\\twhile(currentBestDist != targetDist && targetTileCounter < list.length){\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tvar startCoords = {x: battler.event.posX(), y: battler.event.posY()};\\r\\n\\t\\t\\tvar startNode = graph.grid[startCoords.x][startCoords.y];\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tvar targetNode = list[targetTileCounter];\\r\\n\\t\\t\\tvar endCoords ={x: targetNode[0], y: targetNode[1]};\\r\\n\\t\\t\\tvar endNode = graph.grid[endCoords.x][endCoords.y];\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif(isValidSpace({x: endNode.x, y: endNode.y})){\\t\\t\\t\\r\\n\\t\\t\\t\\tpath = astar.search(graph, startNode, endNode, {closest: true});\\r\\n\\t\\t\\t\\tif(path.length){\\t\\t\\r\\n\\t\\t\\t\\t\\tvar closestValidNode = null;\\r\\n\\t\\t\\t\\t\\tvar ctr = path.length-1;\\r\\n\\t\\t\\t\\t\\twhile(ctr >= 0 && !closestValidNode){\\r\\n\\t\\t\\t\\t\\t\\tvar node = path[ctr];\\r\\n\\t\\t\\t\\t\\t\\tvar x = node.x;\\r\\n\\t\\t\\t\\t\\t\\tvar y = node.y;\\r\\n\\t\\t\\t\\t\\t\\tvar deltaX = Math.abs(targetCoords.x - x);\\r\\n\\t\\t\\t\\t\\t\\tvar deltaY = Math.abs(targetCoords.y - y);\\r\\n\\t\\t\\t\\t\\t\\tvar dist = Math.hypot(deltaX, deltaY);\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\tif(dist >= targetDist && isValidSpace({x: x, y: y})){\\r\\n\\t\\t\\t\\t\\t\\t\\tclosestValidNode = node;\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\t\\t//pathfindingGrid[node.x][node.y] = 0;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\tctr--;\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tcandidatePaths.push(path);\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\timproves = false;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\ttargetTileCounter++;\\r\\n\\t\\t}\\t\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tvar canReach = false;\\r\\n\\t\\tvar pathScores = [];\\r\\n\\t\\tvar bestPath = [];\\r\\n\\t\\tcandidatePaths.forEach(function(path){\\r\\n\\t\\t\\tvar node = path[path.length-1];\\r\\n\\t\\t\\tvar deltaX = Math.abs(targetCoords.x - node.x);\\r\\n\\t\\t\\tvar deltaY = Math.abs(targetCoords.y - node.y);\\r\\n\\t\\t\\tvar dist = deltaX + deltaY;\\r\\n\\t\\t\\tvar environmentScore = 0;\\r\\n\\t\\t\\tvar terrainDetails = $gameMap.getTilePropertiesAsObject({x: node.x, y: node.y});\\t\\r\\n\\t\\t\\tvar terrainScore = 0;\\r\\n\\t\\t\\tif(terrainDetails){\\r\\n\\t\\t\\t\\tterrainScore+=terrainDetails.defense / 100;\\r\\n\\t\\t\\t\\tterrainScore+=terrainDetails.evasion / 100;\\r\\n\\t\\t\\t\\tterrainScore+=terrainDetails.hp_regen / 100;\\r\\n\\t\\t\\t\\tterrainScore+=terrainDetails.en_regen / 100;\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\tenvironmentScore+=terrainScore;\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tvar supporterDefenders = $statCalc.getSupportDefendCandidates(\\r\\n\\t\\t\\t\\t$gameSystem.getFactionId(battler), \\r\\n\\t\\t\\t\\t{x: node.x, y: node.y},\\r\\n\\t\\t\\t\\t$statCalc.getCurrentTerrain(battler),\\r\\n\\t\\t\\t\\tbattler.event.eventId()\\r\\n\\t\\t\\t);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif(supporterDefenders.length){\\r\\n\\t\\t\\t\\tenvironmentScore+=1;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tvar supportersAttackers = $statCalc.getSupportAttackCandidates(\\r\\n\\t\\t\\t\\t$gameSystem.getFactionId(battler), \\r\\n\\t\\t\\t\\t{x: node.x, y: node.y},\\r\\n\\t\\t\\t\\t$statCalc.getCurrentTerrain(battler),\\r\\n\\t\\t\\t\\tbattler.event.eventId()\\r\\n\\t\\t\\t);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif(supportersAttackers.length){\\r\\n\\t\\t\\t\\tenvironmentScore+=0.5;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tvar distanceOK = dist <= range && dist >= minRange;\\r\\n\\t\\t\\tif(distanceOK){\\r\\n\\t\\t\\t\\tcanReach = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tpathScores.push({\\r\\n\\t\\t\\t\\tpath: path,\\r\\n\\t\\t\\t\\tdistanceOK: distanceOK,\\r\\n\\t\\t\\t\\tdist: dist,\\r\\n\\t\\t\\t\\tenvironment: environmentScore\\r\\n\\t\\t\\t});\\r\\n\\t\\t});\\r\\n\\t\\tif(canReach){\\r\\n\\t\\t\\tpathScores.sort(function(a, b){\\r\\n\\t\\t\\t\\tif(a.distanceOK && b.distanceOK){\\r\\n\\t\\t\\t\\t\\tif(b.environment - a.environment == 0){\\r\\n\\t\\t\\t\\t\\t\\treturn a.dist - b.dist;\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\treturn b.environment - a.environment;\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t} else if(a.distanceOK){\\r\\n\\t\\t\\t\\t\\treturn -1;\\r\\n\\t\\t\\t\\t} else if(b.distanceOK) {\\r\\n\\t\\t\\t\\t\\treturn 1;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\treturn 0;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t});\\r\\n\\r\\n\\t\\t\\tif(pathScores[0]){\\r\\n\\t\\t\\t\\tpath = pathScores[0].path;\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t//var graph = new Graph(pathfindingGrid);\\r\\n\\t\\t\\tvar startCoords = {x: battler.event.posX(), y: battler.event.posY()};\\r\\n\\t\\t\\tvar startNode = graph.grid[startCoords.x][startCoords.y];\\r\\n\\t\\t\\tvar endCoords = {x: targetCoords.x, y: targetCoords.y};\\r\\n\\t\\t\\tvar endNode = graph.grid[endCoords.x][endCoords.y];\\r\\n\\t\\t\\tpath = astar.search(graph, startNode, endNode, {closest: true});\\r\\n\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tvar pathNodeLookup = {};\\r\\n\\t\\tvar ctr = 0;\\r\\n\\t\\t\\r\\n\\t\\tvar tmp = [];\\r\\n\\t\\tpath.forEach(function(node){\\r\\n\\t\\t\\tvar deltaX = Math.abs(targetCoords.x - node.x);\\r\\n\\t\\t\\tvar deltaY = Math.abs(targetCoords.y - node.y);\\r\\n\\t\\t\\tvar dist = Math.hypot(deltaX, deltaY);\\r\\n\\t\\t\\tif(deltaX + deltaY >= minRange){\\r\\n\\t\\t\\t\\ttmp.push(node);\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\tpath = tmp;\\r\\n\\r\\n\\t\\tpath.forEach(function(node){\\r\\n\\t\\t\\tif(!pathNodeLookup[node.x]){\\r\\n\\t\\t\\t\\tpathNodeLookup[node.x] = {};\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tpathNodeLookup[node.x][node.y] = ctr++;\\r\\n\\t\\t});\\r\\n\\t\\t\\r\\n\\t\\tvar bestIdx = -1;\\r\\n\\t\\tfor(var i = 0; i < list.length; i++){\\r\\n\\t\\t\\tvar pathIdx = -1;\\r\\n\\t\\t\\tif(pathNodeLookup[list[i][0]] && pathNodeLookup[list[i][0]][list[i][1]] != null){\\r\\n\\t\\t\\t\\tpathIdx = pathNodeLookup[list[i][0]][list[i][1]];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(isValidSpace({x: list[i][0], y: list[i][1]}) && pathIdx > bestIdx){\\r\\n\\t\\t\\t\\tbestIdx = pathIdx;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tvar candidatePos = [];\\r\\n\\t\\tif(bestIdx != -1){\\r\\n\\t\\t\\tcandidatePos.push([path[bestIdx].x, path[bestIdx].y]);\\r\\n\\t\\t} else {\\t\\t\\r\\n\\t\\t\\tvar distanceSortedPositions = [];\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tfor(var i = 0; i < list.length; i++){\\r\\n\\t\\t\\t\\tvar deltaX = Math.abs(targetCoords.x - list[i][0]);\\r\\n\\t\\t\\t\\tvar deltaY = Math.abs(targetCoords.y - list[i][1]);\\r\\n\\t\\t\\t\\tvar distance = Math.hypot(deltaX, deltaY);\\r\\n\\t\\t\\t\\tif((range == -1 || (deltaX + deltaY <= range && deltaX + deltaY >= minRange)) && isValidSpace({x: list[i][0], y: list[i][1]})){\\r\\n\\t\\t\\t\\t\\tdistanceSortedPositions.push({\\r\\n\\t\\t\\t\\t\\t\\tx: list[i][0],\\r\\n\\t\\t\\t\\t\\t\\ty: list[i][1],\\r\\n\\t\\t\\t\\t\\t\\tdistance: distance\\r\\n\\t\\t\\t\\t\\t});\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\t\\t\\r\\n\\t\\t\\tdistanceSortedPositions = distanceSortedPositions.sort(function(a, b){\\r\\n\\t\\t\\t\\treturn a.distance - b.distance;\\r\\n\\t\\t\\t});\\r\\n\\t\\t\\tif(distanceSortedPositions.length){\\r\\n\\t\\t\\t\\tvar optimalDistance = distanceSortedPositions[0].distance;\\r\\n\\t\\t\\t\\tvar ctr = 0;\\r\\n\\t\\t\\t\\tvar currentDistance = distanceSortedPositions[0].distance;\\r\\n\\t\\t\\t\\twhile(currentDistance == optimalDistance && ctr < distanceSortedPositions.length){\\r\\n\\t\\t\\t\\t\\tcurrentDistance = distanceSortedPositions[ctr].distance;\\r\\n\\t\\t\\t\\t\\tif(currentDistance == optimalDistance){\\r\\n\\t\\t\\t\\t\\t\\tcandidatePos.push([distanceSortedPositions[ctr].x, distanceSortedPositions[ctr].y]);\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tctr++;\\r\\n\\t\\t\\t\\t} \\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tfor(var i = 0; i < candidatePos.length; i++){\\r\\n\\t\\t\\tif(candidatePos[i][0] == targetCoords.x && candidatePos[i][1] == targetCoords.y){\\r\\n\\t\\t\\t\\treturn candidatePos[i];\\r\\n\\t\\t\\t}\\r\\n\\t\\t} \\r\\n\\t\\tvar resultPos = candidatePos[0];\\r\\n\\t\\tvar ctr = 1;\\r\\n\\t\\twhile(ctr < candidatePos.length && !isValidSpace({x: resultPos[0], y: resultPos[1]})){\\r\\n\\t\\t\\tresultPos = candidatePos[ctr++];\\r\\n\\t\\t}\\r\\n\\t\\tif(!resultPos){\\r\\n\\t\\t\\treturn [startX, startY];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif(!isValidSpace({x: resultPos[0], y: resultPos[1]})){\\r\\n\\t\\t\\treturn [startX, startY];\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn resultPos;\\r\\n\\t\\t}        \\r\\n    };\\r\\n\\r\\n    //自動行動アクター&エネミーの戦闘の実行\\r\\n    Scene_Map.prototype.srpgInvokeAutoUnitAction = function() {\\r\\n        if (!$gameTemp.targetEvent()) {\\r\\n            var actionArray = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId());\\r\\n            actionArray[1].onAllActionsEnd();\\r\\n            this.srpgAfterAction();\\r\\n            return;\\r\\n        }\\r\\n        var actionArray = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId());\\r\\n        var targetArray = $gameSystem.EventToUnit($gameTemp.targetEvent().eventId());\\r\\n        var skill = actionArray[1].currentAction().item();\\r\\n        var range = actionArray[1].srpgSkillRange(skill);\\r\\n        $gameTemp.setSrpgDistance($gameSystem.unitDistance($gameTemp.activeEvent(), $gameTemp.targetEvent()));\\r\\n        $gameTemp.setSrpgSpecialRange($gameTemp.activeEvent().srpgRangeExtention($gameTemp.targetEvent().posX(), $gameTemp.targetEvent().posY(), $gameTemp.activeEvent().posX(), $gameTemp.activeEvent().posY(), skill, range));\\r\\n        if (actionArray[1].canUse(skill)) {\\r\\n            $gameTemp.setAutoMoveDestinationValid(true);\\r\\n            $gameTemp.setAutoMoveDestination($gameTemp.targetEvent().posX(), $gameTemp.targetEvent().posY());\\r\\n            $gameSystem.setSubBattlePhase('invoke_action');\\r\\n            this.srpgBattleStart(actionArray, targetArray);\\r\\n        } else {\\r\\n            actionArray[1].onAllActionsEnd();\\r\\n            this.srpgAfterAction();\\r\\n        }\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.srpgInvokeAIAction = function() {\\t\\t\\r\\n\\t\\tif(this.doEnemyMapAttack($gameTemp.activeEvent(), true)){\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n        if (!$gameTemp.targetEvent()) {\\r\\n\\t\\t\\tvar actionArray = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId());\\r\\n\\t\\t\\tvar canAttackTargets = this.srpgMakeCanAttackTargets(actionArray[1]); //行動対象としうるユニットのリストを作成\\t\\t\\t\\r\\n\\t\\t\\tif(canAttackTargets.length){\\t\\t\\r\\n\\t\\t\\t\\tvar targetInfo = this.srpgDecideTarget(canAttackTargets, $gameTemp.activeEvent()); //ターゲットの設定\\r\\n\\t\\t\\t\\t$gameTemp.enemyWeaponSelection = targetInfo.weapon;\\r\\n\\t\\t\\t\\t$gameTemp.setTargetEvent(targetInfo.target);\\r\\n\\t\\t\\t\\t$gameTemp.activeEvent()._currentTarget = targetInfo.target;\\r\\n\\t\\t\\t} else {\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tactionArray[1].onAllActionsEnd();\\r\\n\\t\\t\\t\\tthis.srpgAfterAction();\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}           \\r\\n        }\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n        var actionArray = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId());\\r\\n        var targetArray = $gameSystem.EventToUnit($gameTemp.targetEvent().eventId());\\r\\n\\t\\t\\r\\n\\t\\t$gameTemp.reticuleInfo = {\\r\\n\\t\\t\\tactor: actionArray[1],\\r\\n\\t\\t\\ttargetActor: targetArray[1]\\r\\n\\t\\t};\\r\\n\\t\\r\\n\\t\\t$gameSystem.setSubBattlePhase('invoke_action');\\r\\n\\t\\t\\r\\n\\t\\t//actor default action determination\\r\\n\\t\\t$gameTemp.isEnemyAttack = true;\\r\\n\\t\\t$gameTemp.currentBattleActor = targetArray[1];\\t\\t\\t\\r\\n\\t\\t$gameTemp.currentBattleEnemy = actionArray[1];\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tvar enemyInfo = {actor: $gameTemp.currentBattleEnemy, pos: {x: $gameTemp.currentBattleEnemy.event.posX(), y: $gameTemp.currentBattleEnemy.event.posY()}};\\r\\n\\t\\tvar actorInfo = {actor: $gameTemp.currentBattleActor, pos: {x: $gameTemp.currentBattleActor.event.posX(), y: $gameTemp.currentBattleActor.event.posY()}};\\r\\n\\t\\tvar weapon = $gameTemp.enemyWeaponSelection;\\r\\n\\t\\tif(weapon){\\r\\n\\t\\t\\t$gameTemp.enemyAction = {\\r\\n\\t\\t\\t\\ttype: \\\"attack\\\",\\r\\n\\t\\t\\t\\tattack: weapon,\\r\\n\\t\\t\\t\\ttarget: 0\\r\\n\\t\\t\\t};\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t$gameTemp.enemyAction = {\\r\\n\\t\\t\\t\\ttype: \\\"none\\\",\\r\\n\\t\\t\\t\\tattack: 0,\\r\\n\\t\\t\\t\\ttarget: 0\\r\\n\\t\\t\\t};\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\tvar weapon = $battleCalc.getBestWeapon(actorInfo, enemyInfo, true);\\r\\n\\t\\tif(weapon){\\r\\n\\t\\t\\t$gameTemp.actorAction = {\\r\\n\\t\\t\\t\\ttype: \\\"attack\\\",\\r\\n\\t\\t\\t\\tattack: weapon,\\r\\n\\t\\t\\t\\ttarget: 0\\r\\n\\t\\t\\t};\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t$gameTemp.actorAction = {\\r\\n\\t\\t\\t\\ttype: \\\"none\\\",\\r\\n\\t\\t\\t\\tattack: 0,\\r\\n\\t\\t\\t\\ttarget: 0\\r\\n\\t\\t\\t};\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif((!$gameTemp.enemyAction || !$gameTemp.enemyAction.attack || !$gameTemp.enemyAction.attack.isAll)){\\t\\r\\n\\t\\t\\tvar supporters = $statCalc.getSupportDefendCandidates(\\r\\n\\t\\t\\t\\t$gameSystem.getFactionId(actorInfo.actor), \\r\\n\\t\\t\\t\\tactorInfo.pos,\\r\\n\\t\\t\\t\\t$statCalc.getCurrentTerrain(actorInfo.actor)\\r\\n\\t\\t\\t);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tif($statCalc.applyStatModsToValue($gameTemp.currentBattleActor, 0, [\\\"disable_support\\\"]) || \\r\\n\\t\\t\\t\\t$statCalc.applyStatModsToValue($gameTemp.currentBattleEnemy, 0, [\\\"disable_target_support\\\"])){\\r\\n\\t\\t\\t\\tsupporters = [];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tvar supporterSelected = -1;\\r\\n\\t\\t\\tvar minDamage = -1;\\r\\n\\t\\t\\tfor(var i = 0; i < supporters.length; i++){\\r\\n\\t\\t\\t\\tsupporters[i].action = {type: \\\"defend\\\", attack: null};\\t\\t\\t\\r\\n\\t\\t\\t\\tvar damageResult = $battleCalc.performDamageCalculation(\\r\\n\\t\\t\\t\\t\\t{actor: enemyInfo.actor, action: $gameTemp.enemyAction},\\r\\n\\t\\t\\t\\t\\tsupporters[i],\\r\\n\\t\\t\\t\\t\\ttrue,\\r\\n\\t\\t\\t\\t\\tfalse,\\r\\n\\t\\t\\t\\t\\ttrue\\t\\r\\n\\t\\t\\t\\t);\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tif(minDamage == -1 || damageResult.damage < minDamage){\\r\\n\\t\\t\\t\\t\\tif(damageResult.damage < $statCalc.getCalculatedMechStats(supporters[i].actor).currentHP){\\r\\n\\t\\t\\t\\t\\t\\tminDamage = damageResult.damage;\\r\\n\\t\\t\\t\\t\\t\\tsupporterSelected = i;\\r\\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$gameTemp.supportDefendCandidates = supporters;\\r\\n\\t\\t\\tif($gameSystem.optionDefaultSupport){\\r\\n\\t\\t\\t\\t$gameTemp.supportDefendSelected = supporterSelected;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t$gameTemp.supportDefendSelected = -1;\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t$gameTemp.supportDefendCandidates = [];\\r\\n\\t\\t\\t$gameTemp.supportDefendSelected = -1;\\r\\n\\t\\t}\\r\\n\\t\\tvar supporters = $statCalc.getSupportAttackCandidates(\\r\\n\\t\\t\\t$gameSystem.getFactionId(enemyInfo.actor), \\r\\n\\t\\t\\t{x: $gameTemp.activeEvent().posX(), y: $gameTemp.activeEvent().posY()},\\r\\n\\t\\t\\t$statCalc.getCurrentTerrain($gameTemp.currentBattleEnemy)\\r\\n\\t\\t);\\r\\n\\t\\t\\r\\n\\t\\tvar aSkill = $statCalc.getPilotStat(enemyInfo.actor, \\\"skill\\\");\\r\\n\\t\\tvar dSkill = $statCalc.getPilotStat(actorInfo.actor, \\\"skill\\\");\\r\\n\\t\\t\\r\\n\\t\\tif((aSkill - dSkill >= 20) && $statCalc.applyStatModsToValue(enemyInfo.actor, 0, [\\\"attack_again\\\"])){\\r\\n\\t\\t\\tsupporters.push({actor:enemyInfo.actor, pos: {x: enemyInfo.actor.event.posX(), y: enemyInfo.actor.event.posY()}});\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif($statCalc.applyStatModsToValue($gameTemp.currentBattleEnemy, 0, [\\\"disable_support\\\"]) || \\r\\n\\t\\t\\t$statCalc.applyStatModsToValue($gameTemp.currentBattleActor, 0, [\\\"disable_target_support\\\"])){\\r\\n\\t\\t\\tsupporters = [];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tvar allRequired = false;\\r\\n\\t\\tif($gameTemp.enemyAction && $gameTemp.enemyAction.attack){\\r\\n\\t\\t\\tallRequired = $gameTemp.enemyAction.attack.isAll ? 1 : -1;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tvar supporterInfo = [];\\r\\n\\t\\tvar supporterSelected = -1;\\r\\n\\t\\tvar bestDamage = 0;\\r\\n\\t\\tfor(var i = 0; i < supporters.length; i++){\\r\\n\\t\\t\\tvar weaponResult = $battleCalc.getBestWeaponAndDamage(supporters[i], actorInfo, false, false, false, allRequired);\\r\\n\\t\\t\\tif(weaponResult.weapon){\\r\\n\\t\\t\\t\\tsupporters[i].action = {type: \\\"attack\\\", attack: weaponResult.weapon};\\r\\n\\t\\t\\t\\tsupporterInfo.push(supporters[i]);\\r\\n\\t\\t\\t\\tif(bestDamage < weaponResult.damage){\\r\\n\\t\\t\\t\\t\\tbestDamage = weaponResult.damage;\\r\\n\\t\\t\\t\\t\\tsupporterSelected = i;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t$gameTemp.supportAttackCandidates = supporterInfo;\\r\\n\\t\\t$gameTemp.supportAttackSelected = supporterSelected;\\r\\n\\t\\t\\r\\n\\t\\t$battleCalc.updateTwinSupportAttack();\\r\\n\\t\\t\\r\\n\\t\\t//hack to make sure that the actor attacks from the correct side of the screen when dealing with AI actors\\r\\n\\t\\tif($gameTemp.currentBattleEnemy.isActor() && !$gameSystem.isEnemy($gameTemp.currentBattleEnemy)){\\r\\n\\t\\t\\t$gameTemp.isEnemyAttack = false;\\r\\n\\t\\t\\tvar tmp = $gameTemp.currentBattleActor;\\r\\n\\t\\t\\t$gameTemp.currentBattleActor = $gameTemp.currentBattleEnemy;\\r\\n\\t\\t\\t$gameTemp.currentBattleEnemy = tmp;\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tvar tmp = $gameTemp.actorAction;\\r\\n\\t\\t\\t$gameTemp.actorAction = $gameTemp.enemyAction;\\r\\n\\t\\t\\t$gameTemp.enemyAction = tmp;\\r\\n\\t\\t}\\r\\n\\t\\t$gameTemp.currentTargetingSettings = null;\\t\\r\\n\\t\\t$battleCalc.updateTwinActions();\\r\\n\\t\\t\\r\\n\\t\\tvar weapon = $gameTemp.enemyWeaponSelection;\\r\\n\\t\\tvar range = $statCalc.getRealWeaponRange(actionArray[1], weapon);\\r\\n\\t\\tvar minRange = $statCalc.getRealWeaponMinRange(actionArray[1], weapon);\\r\\n\\t\\tvar event = actionArray[1].event;\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tthis.setUpAttackRange(event.posX(), event.posY(), range, minRange);\\r\\n\\t\\t\\r\\n\\t\\t$gameSystem.setSubBattlePhase(\\\"enemy_targeting_display\\\");\\r\\n\\t\\t$gameTemp.targetingDisplayCounter = 60;\\r\\n       \\r\\n    };\\r\\n\\r\\n    //戦闘処理の実行\\r\\n    Scene_Map.prototype.srpgBattleStart = function(actionArray, targetArray) {\\t\\t\\r\\n\\t\\t$statCalc.setCurrentAttack($gameTemp.currentBattleActor, $gameTemp.actorAction.attack);\\t\\r\\n\\t\\t$statCalc.setCurrentAttack($gameTemp.currentBattleEnemy, $gameTemp.enemyAction.attack);\\t\\r\\n\\t\\t\\r\\n\\t\\t$battleCalc.generateBattleResult();\\r\\n\\t\\t\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\r\\n     \\r\\n\\t\\tObject.keys($gameTemp.battleEffectCache).forEach(function(cacheRef){\\r\\n\\t\\t\\tvar battleEffect = $gameTemp.battleEffectCache[cacheRef];\\t\\t\\t\\t\\r\\n\\t\\t\\tif(\\t\\r\\n\\t\\t\\t\\tbattleEffect.madeContact && \\r\\n\\t\\t\\t\\tbattleEffect.attacked && \\r\\n\\t\\t\\t\\t$statCalc.applyStatModsToValue(battleEffect.ref, 0, [\\\"noise_destroy\\\"]) && \\r\\n\\t\\t\\t\\t$statCalc.getSpecies(battleEffect.attacked.ref) == \\\"human\\\" && \\r\\n\\t\\t\\t\\t!$statCalc.applyStatModsToValue(battleEffect.attacked.ref, 0, [\\\"noise_destroy_immune\\\"]) && \\r\\n\\t\\t\\t\\t!$statCalc.isStatModActiveOnAnyActor(\\\"noise_destroy_immune_all\\\")\\r\\n\\t\\t\\t){\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tbattleEffect.isDestroyed = true;\\r\\n\\t\\t\\t\\tbattleEffect.attacked.isDestroyed = true;\\r\\n\\t\\t\\t}\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\r\\n\\t\\t});\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\t$gameTemp.clearMoveTable();\\r\\n\\t\\t$gameTemp.isEnemyAttack = false;\\r\\n\\t\\t$gameTemp.battleOccurred = true;\\r\\n\\t\\r\\n\\t\\tthis.eventBeforeBattle();\\r\\n\\t\\t\\r\\n\\t\\tif($gameMap.isEventRunning()){\\t\\t\\r\\n\\t\\t\\t$gameTemp.popMenu = true;\\r\\n\\t\\t\\t$gameSystem.setSubBattlePhase('event_before_battle');\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis.playBattleScene();\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.enemyMapAttackStart = function(actionArray, targetArray) {\\t\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\t$gameTemp.isEnemyAttack = true;\\r\\n\\t\\t$battleCalc.generateMapBattleResult();\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t$gameTemp.mapAttackOccurred = true;\\r\\n\\t\\t$gameTemp.mapAttackAnimationStarted = false;\\r\\n\\t\\t$gameTemp.mapAttackAnimationDelay = 30; \\r\\n\\t\\t$gameTemp.mapAttackRetargetDelay = 30; \\r\\n\\t\\t$gameTemp.showBeforeEnemyMapAnimation = true;\\r\\n\\t\\t$gameSystem.setSubBattlePhase('before_enemy_map_animation');\\t\\t\\t\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.mapAttackStart = function(actionArray, targetArray) {\\t\\r\\n\\t\\tvar _this = this;\\r\\n\\t\\t$gameTemp.isEnemyAttack = false;\\r\\n\\t\\t$battleCalc.generateMapBattleResult();\\t\\t\\t\\t\\r\\n\\t\\t$gameTemp.clearMoveTable();\\t\\t\\r\\n\\t\\t$gameTemp.mapAttackOccurred = true;\\r\\n\\t\\t$gameTemp.mapAttackAnimationStarted = false;\\r\\n\\t\\t$gameSystem.setSubBattlePhase('map_attack_animation');\\t\\t\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Map.prototype.playBattleScene = function() {\\r\\n\\t\\tif($gameSystem.demoSetting){\\r\\n\\t\\t\\tthis.startEncounterEffect();\\t\\t\\t\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t$gameTemp.popMenu = true;//remove before battle menu\\r\\n\\t\\t\\t$gameSystem.setSubBattlePhase('battle_basic');\\r\\n\\t\\t\\t$gameTemp.pushMenu = \\\"battle_basic\\\";\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n    // 戦闘開始時に向きを修正する\\r\\n    Scene_Map.prototype.preBattleSetDirection = function() {\\r\\n        var differenceX = $gameTemp.activeEvent().posX() - $gameTemp.targetEvent().posX();\\r\\n        var differenceY = $gameTemp.activeEvent().posY() - $gameTemp.targetEvent().posY();\\r\\n        if ($gameMap.isLoopHorizontal() == true) {\\r\\n            var event1X = $gameTemp.activeEvent().posX() > $gameTemp.targetEvent().posX() ? $gameTemp.activeEvent().posX() - $gameMap.width() : $gameTemp.activeEvent().posX() + $gameMap.width();\\r\\n            var disX = event1X - $gameTemp.targetEvent().posX();\\r\\n            differenceX = Math.abs(differenceX) < Math.abs(disX) ? differenceX : disX;\\r\\n        }\\r\\n        if ($gameMap.isLoopVertical() == true) {\\r\\n            var event1Y = $gameTemp.activeEvent().posY() > $gameTemp.targetEvent().posY() ? $gameTemp.activeEvent().posY() - $gameMap.height() : $gameTemp.activeEvent().posY() + $gameMap.height();\\r\\n            var disY = event1Y - $gameTemp.targetEvent().posY();\\r\\n            differenceY = Math.abs(differenceY) < Math.abs(disY) ? differenceY : disY;\\r\\n        }\\r\\n        if (Math.abs(differenceX) > Math.abs(differenceY)) {\\r\\n            if (differenceX > 0) {\\r\\n                $gameTemp.activeEvent().setDirection(4);\\r\\n                if (_srpgDamageDirectionChange == 'true') $gameTemp.targetEvent().setDirection(6);\\r\\n            } else {\\r\\n                $gameTemp.activeEvent().setDirection(6);\\r\\n                if (_srpgDamageDirectionChange == 'true') $gameTemp.targetEvent().setDirection(4);\\r\\n            }\\r\\n        } else {\\r\\n            if (differenceY >= 0) {\\r\\n                $gameTemp.activeEvent().setDirection(8);\\r\\n                if (_srpgDamageDirectionChange == 'true') $gameTemp.targetEvent().setDirection(2);\\r\\n            } else {\\r\\n                $gameTemp.activeEvent().setDirection(2);\\r\\n                if (_srpgDamageDirectionChange == 'true') $gameTemp.targetEvent().setDirection(8);\\r\\n            }\\r\\n        }\\r\\n    };\\r\\n\\r\\n      // SRPG戦闘中は戦闘開始エフェクトを高速化する\\r\\n    var _SRPG_SceneMap_updateEncounterEffect = Scene_Map.prototype.updateEncounterEffect;\\r\\n    Scene_Map.prototype.updateEncounterEffect = function() {\\r\\n        /*if ($gameSystem.isSRPGMode() == true && $gameSwitches.value(2) == true) {\\r\\n            if (this._encounterEffectDuration > 0) {\\r\\n                this._encounterEffectDuration--;\\r\\n                this.snapForBattleBackground();\\r\\n                BattleManager.playBattleBgm();\\r\\n            }\\r\\n        } else if ($gameSystem.isSRPGMode() == true && _srpgBattleQuickLaunch == 'true') {\\r\\n            if (this._encounterEffectDuration > 0) {\\r\\n                this._encounterEffectDuration--;\\r\\n                var speed = this.encounterEffectSpeed();\\r\\n                var n = speed - this._encounterEffectDuration;\\r\\n                //if (n === Math.floor(speed / 3)) {\\r\\n                //     this.startFlashForEncounter(speed);\\r\\n                //}\\r\\n                if (n === Math.floor(speed)) {\\r\\n                    BattleManager.playBattleBgm();\\r\\n                    this.startFadeOut(this.fadeSpeed() / 2);\\r\\n                }\\r\\n            }\\r\\n        } else {\\r\\n            _SRPG_SceneMap_updateEncounterEffect.call(this);\\r\\n        }*/\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\t//this._twistFilter.radius+=20;\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tthis._transitionSprite.scale.x = this._transitionSpriteScale;\\r\\n\\t\\tthis._transitionSprite.scale.y = this._transitionSpriteScale;\\r\\n\\t\\tif (this._transitionFilter.strength >= 0.4) {\\t\\r\\n\\t\\t\\tthis._transitionSprite.opacity-=10;\\r\\n\\t\\t\\t/*this._transitionSpriteScale+=0.005;\\r\\n\\t\\t\\tthis._transitionSprite.x-=2.5;\\r\\n\\t\\t\\tthis._transitionSprite.y-=0.5;*/\\r\\n\\t\\t\\tthis._transitionFilter.strength+=0.01;\\r\\n\\t\\t\\tif(this._transitionFilter.strength >= 0.65){\\r\\n\\t\\t\\t\\t//this._transitionFilter.blurX = 0;\\t\\r\\n\\t\\t\\t\\t//this.clearTREffects();\\r\\n\\t\\t\\t\\tthis._transitioningToBattle = false;\\r\\n\\t\\t\\t\\tthis._loadingIntoBattle = true;\\r\\n\\t\\t\\t\\tthis.removeChild(this._transitionSprite);\\t\\t\\t\\t\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis._transitionFilter.strength+=0.02;\\r\\n\\t\\t}\\r\\n\\t\\tthis._transitionTimer++;\\r\\n    };\\r\\n\\r\\n    // SRPG戦闘中は戦闘開始エフェクトを高速化する\\r\\n    var _SRPG_SceneMap_encounterEffectSpeed = Scene_Map.prototype.encounterEffectSpeed;\\r\\n    Scene_Map.prototype.encounterEffectSpeed = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true && _srpgBattleQuickLaunch == 'true') {\\r\\n            return 10;\\r\\n        } else {\\r\\n            return _SRPG_SceneMap_encounterEffectSpeed.call(this);\\r\\n        }\\r\\n    };\\r\\n\\t\\r\\n\\tvar _SRPG_SceneMap_startEncounterEffect = Scene_Map.prototype.startEncounterEffect;\\r\\n    Scene_Map.prototype.startEncounterEffect = function() {\\r\\n        /*if ($gameSystem.isSRPGMode() == true && _srpgBattleQuickLaunch == 'true') {\\r\\n            this._encounterEffectDuration = this.encounterEffectSpeed();\\r\\n        } else {\\r\\n            _SRPG_SceneMap_startEncounterEffect.call(this);\\r\\n        }*/\\r\\n\\t\\t\\r\\n\\t\\ttry {\\r\\n\\t\\t\\tthis.removeChild(this._transitionBackSprite);\\r\\n\\t\\t} catch(e){\\r\\n\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tthis._transitionBase = SceneManager.snap();\\r\\n\\t\\t\\r\\n\\t\\tthis._transitioningToBattle = true;\\r\\n\\t\\tthis._transitionTimer = 0;\\r\\n\\t\\r\\n\\t\\tthis._transitionBackSprite = new Sprite(new Bitmap(Graphics.boxWidth,Graphics.boxHeight));\\r\\n\\t\\tthis._transitionBackSprite.bitmap.fillAll('black');\\r\\n\\t\\tthis.addChild(this._transitionBackSprite);\\r\\n\\r\\n\\t\\tthis._transitionSprite = new Sprite(this._transitionBase);\\r\\n\\t\\tthis._transitionSpriteScale = 1;\\r\\n\\t\\t\\r\\n\\t\\tvar filter = new PIXI.filters.ZoomBlurFilter();\\r\\n\\t\\tfilter.strength = 0.01;\\r\\n\\t\\tvar x = 0;\\r\\n\\t\\tvar y = 0;\\r\\n\\t\\tvar activeEvent = $gameTemp.targetEvent();\\r\\n\\t\\tif(activeEvent){\\r\\n\\t\\t\\tx = activeEvent.screenX();\\r\\n\\t\\t\\ty = activeEvent.screenY() - 24;\\r\\n\\t\\t}\\r\\n\\t\\tfilter.center = [x, y];\\r\\n\\t\\tfilter.innerRadius = 0;\\r\\n\\t\\t\\r\\n\\t\\tthis._transitionFilter = filter;\\t\\r\\n\\t\\t\\r\\n\\t\\t/*var twistFilter = new PIXI.filters.TwistFilter();\\r\\n\\t\\ttwistFilter.angle = -0.5;\\r\\n\\t\\ttwistFilter.offset = [Graphics._getCurrentWidth() / 2, Graphics._getCurrentHeight() / 2];\\r\\n\\t\\ttwistFilter.radius = 0;\\r\\n\\t\\t\\r\\n\\t\\tthis._twistFilter = twistFilter;\\t*/\\r\\n\\t\\t\\r\\n\\t\\tthis._transitionSprite.filters = [filter];\\r\\n\\t\\tthis.addChild(this._transitionSprite);\\r\\n\\t\\t\\r\\n\\t\\tif($gameSystem.optionBattleBGM){\\r\\n\\t\\t\\t$songManager.playBattleSong($gameTemp.currentBattleActor, $gameTemp.currentBattleEnemy);\\r\\n\\t\\t}\\t\\t\\r\\n    };\\r\\n\\t\\r\\nScene_Gameover.prototype.gotoTitle = function() {\\r\\n\\t$gameTemp.intermissionPending = true;\\r\\n\\t\\r\\n\\t$SRWSaveManager.lockMapSRPoint($gameMap.mapId());\\t\\r\\n\\t$gameMap._interpreter.clear();//make sure no events run after the game over before loading into the intermission\\r\\n\\t$gamePlayer.reserveTransfer(2, 0, 0);//send player to intermission after losing\\r\\n    SceneManager.goto(Scene_Map);\\r\\n};\\r\\n\\r\\n//====================================================================\\r\\n// ●Scene_Menu\\r\\n//====================================================================\\r\\n    var _SRPG_SceneMenu_createCommandWindow = Scene_Menu.prototype.createCommandWindow;\\r\\n    Scene_Menu.prototype.createCommandWindow = function() {\\r\\n        _SRPG_SceneMenu_createCommandWindow.call(this);\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            this._commandWindow.setHandler('turnEnd',this.commandTurnEnd.bind(this));\\r\\n            this._commandWindow.setHandler('autoBattle',this.commandAutoBattle.bind(this));\\t\\t\\t\\r\\n        }\\r\\n\\t\\tthis._commandWindow.y = 100;\\r\\n\\t\\tthis._commandWindow.x = 800;\\r\\n    };    \\r\\n\\r\\n    Scene_Menu.prototype.commandAutoBattle = function() {\\r\\n        $gameTemp.setTurnEndFlag(true);\\r\\n        $gameTemp.setAutoBattleFlag(true);\\r\\n        SceneManager.pop();\\r\\n    };\\r\\n\\t\\r\\n\\tScene_Menu.prototype.createStatusWindow = function() {\\r\\n        \\r\\n    };\\r\\n\\t\\r\\n\\tScene_Menu.prototype.start = function() {\\r\\n\\t\\tScene_MenuBase.prototype.start.call(this);\\r\\n\\t\\t\\r\\n\\t};\\r\\n\\t\\r\\n\\t\\r\\n\\r\\n\\tScene_Menu.prototype.createGoldWindow = function() {\\r\\n\\t\\tthis._goldWindow = new Window_StageInfo(0, 0);\\r\\n\\t\\tthis._goldWindow.y = this._commandWindow.y + this._commandWindow.windowHeight();\\r\\n\\t\\tthis._goldWindow.x = 800;\\r\\n\\t\\tthis.addWindow(this._goldWindow);\\r\\n\\t};\\r\\n\\t\\r\\n\\tSceneManager.snapForBackground = function() {\\r\\n\\t\\tthis._backgroundBitmap = this.snap();\\r\\n\\t\\tthis._backgroundBitmap.blur();\\r\\n\\t};\\r\\n\\t\\r\\n\\tSceneManager.snap = function() {\\r\\n\\t\\treturn Bitmap.snap(this._scene);\\r\\n\\t};\\r\\n\\t\\r\\n\\r\\n//====================================================================\\r\\n// ●Scene_Equip\\r\\n//====================================================================\\r\\n    Scene_Equip.prototype.popScene = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true && $gameTemp.activeEvent()) {\\r\\n            $gameTemp.setSrpgActorEquipFlag(true);\\r\\n        }\\r\\n        SceneManager.pop();\\r\\n    };\\r\\n\\r\\n//====================================================================\\r\\n// ●Scene_Load\\r\\n//====================================================================\\r\\n    var _SRPG_Scene_Load_onLoadSuccess = Scene_Load.prototype.onLoadSuccess;\\r\\n    Scene_Load.prototype.onLoadSuccess = function() {\\r\\n        _SRPG_Scene_Load_onLoadSuccess.call(this);\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            $gameTemp.setSrpgLoadFlag(true);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    var _SRPG_Scene_Load_reloadMapIfUpdated = Scene_Load.prototype.reloadMapIfUpdated;\\r\\n    Scene_Load.prototype.reloadMapIfUpdated = function() {\\r\\n        if ($gameSystem.isSRPGMode() == false) {\\r\\n            _SRPG_Scene_Load_reloadMapIfUpdated.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n\\r\\n//====================================================================\\r\\n// ●Scene_Battle\\r\\n//====================================================================\\r\\n    // フェード速度を返す\\r\\n    Scene_Battle.prototype.fadeSpeed = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true && _srpgBattleQuickLaunch == 'true') {\\r\\n           return 12;\\r\\n        } else {\\r\\n           return Scene_Base.prototype.fadeSpeed.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    // ウィンドウの作成\\r\\n    var _SRPG_Scene_Battle_createAllWindows = Scene_Battle.prototype.createAllWindows;\\r\\n    Scene_Battle.prototype.createAllWindows = function() {\\r\\n        _SRPG_Scene_Battle_createAllWindows.call(this);\\r\\n        this.createSprgBattleStatusWindow();\\r\\n        if ($gameParty.battleMembers()[0] && $gameParty.battleMembers()[0].isAlive()) {\\r\\n            this.createSrpgBattleResultWindow();\\r\\n        }\\r\\n    };\\r\\n\\r\\n    // SRPG戦闘用のウィンドウを作る\\r\\n    Scene_Battle.prototype.createSprgBattleStatusWindow = function() {\\r\\n        this._srpgBattleStatusWindowLeft = new Window_SrpgBattleStatus(0);\\r\\n        this._srpgBattleStatusWindowRight = new Window_SrpgBattleStatus(1);\\r\\n        this._srpgBattleStatusWindowLeft.openness = 0;\\r\\n        this._srpgBattleStatusWindowRight.openness = 0;\\r\\n        if ($gameParty.battleMembers()[0]) {\\r\\n            this._srpgBattleStatusWindowRight.setBattler($gameParty.battleMembers()[0]);\\r\\n            if ($gameParty.battleMembers()[1]) {\\r\\n                this._srpgBattleStatusWindowLeft.setBattler($gameParty.battleMembers()[1]);\\r\\n            }\\r\\n        }\\r\\n        if ($gameTroop.members()[0]) {\\r\\n            this._srpgBattleStatusWindowLeft.setBattler($gameTroop.members()[0]);\\r\\n            if ($gameTroop.members()[1]) {\\r\\n                this._srpgBattleStatusWindowRight.setBattler($gameTroop.members()[1]);\\r\\n            }\\r\\n        }\\r\\n        this.addWindow(this._srpgBattleStatusWindowLeft);\\r\\n        this.addWindow(this._srpgBattleStatusWindowRight);\\r\\n        BattleManager.setSrpgBattleStatusWindow(this._srpgBattleStatusWindowLeft, this._srpgBattleStatusWindowRight);\\r\\n    };\\r\\n\\r\\n    // SRPG戦闘用のウィンドウを作る\\r\\n    Scene_Battle.prototype.createSrpgBattleResultWindow = function() {\\r\\n        this._srpgBattleResultWindow = new Window_SrpgBattleResult($gameParty.battleMembers()[0]);\\r\\n        this._srpgBattleResultWindow.openness = 0;\\r\\n        this.addWindow(this._srpgBattleResultWindow);\\r\\n        BattleManager.setSrpgBattleResultWindow(this._srpgBattleResultWindow);\\r\\n    };\\r\\n\\r\\n    //ステータスウィンドウのアップデート\\r\\n    var _SRPG_Scene_Battle_updateStatusWindow = Scene_Battle.prototype.updateStatusWindow;\\r\\n    Scene_Battle.prototype.updateStatusWindow = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            this._statusWindow.close();\\r\\n            if ($gameMessage.isBusy()) {\\r\\n                this._srpgBattleStatusWindowLeft.close();\\r\\n                this._srpgBattleStatusWindowRight.close();\\r\\n                this._partyCommandWindow.close();\\r\\n                this._actorCommandWindow.close();\\r\\n            } else if (this.isActive() && !this._messageWindow.isClosing()) {\\r\\n                this._srpgBattleStatusWindowLeft.open();\\r\\n                this._srpgBattleStatusWindowRight.open();\\r\\n            }\\r\\n        } else {\\r\\n            _SRPG_Scene_Battle_updateStatusWindow.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n    //ステータスウィンドウのリフレッシュ\\r\\n    var _SRPG_Scene_Battle_refreshStatus = Scene_Battle.prototype.refreshStatus;\\r\\n    Scene_Battle.prototype.refreshStatus = function() {\\r\\n        if ($gameSystem.isSRPGMode() == true) {\\r\\n            this._srpgBattleStatusWindowLeft.refresh();\\r\\n            this._srpgBattleStatusWindowRight.refresh();\\r\\n        } else {\\r\\n            _SRPG_Scene_Battle_refreshStatus.call(this);\\r\\n        }\\r\\n    };\\r\\n\\r\\n\\r\\n\\r\\n\\t//A window that lists the attacks a unit can use based on its class\\r\\n\\t/*function Window_AttackList(){\\r\\n\\t\\tthis.initialize.apply(this, arguments);\\r\\n\\t\\tthis.select(0);\\r\\n\\t}\\r\\n\\r\\n\\tWindow_AttackList.prototype = Object.create(Window_SkillList.prototype);\\r\\n\\tWindow_AttackList.prototype.constructor = Window_AttackList;\\r\\n\\r\\n\\tWindow_AttackList.prototype.makeItemList = function() {\\r\\n\\t\\tvar items = [];\\r\\n\\t\\tif (this._actor) {\\r\\n\\t\\t\\titems = this._actor.SRWStats.mech.weapons;\\r\\n\\t\\t}\\r\\n\\t\\tthis._data = items;\\r\\n\\t};\\r\\n\\r\\n\\tWindow_AttackList.prototype.drawItem = function(index) {\\r\\n\\t\\tvar weapon = this._data[index];\\r\\n\\t\\tif (weapon) {\\r\\n\\t\\t\\tvar costWidth = this.costWidth();\\r\\n\\t\\t\\tvar rect = this.itemRect(index);\\r\\n\\t\\t\\trect.width -= this.textPadding();\\r\\n\\t\\t\\tthis.changePaintOpacity(this.isEnabled(weapon));\\r\\n\\t\\t\\tthis.drawText(weapon.name, rect.x, rect.y, rect.width - costWidth);\\r\\n\\t\\t\\t//this.drawSkillCost(skill, rect.x, rect.y, rect.width);\\r\\n\\t\\t\\tthis.changePaintOpacity(1);\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tWindow_AttackList.prototype.maxCols = function() {\\r\\n\\t\\treturn 1;\\r\\n\\t};\\r\\n\\r\\n\\tWindow_AttackList.prototype.isEnabled = function(item) {\\r\\n\\t\\tif(!$gameTemp.isPostMove || item.postMoveEnabled || $statCalc.getActiveSpirits(this._actor).charge){\\r\\n\\t\\t\\tif($statCalc.canUseWeapon(this._actor, item)){\\r\\n\\t\\t\\t\\treturn true;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\treturn false;\\r\\n\\t\\t\\t}\\t\\t\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}   \\r\\n\\t};*/\\r\\n\\r\\n\\t//A window that lists the counter/evade/defend options for the player when counter attacking\\r\\n\\tfunction Window_CounterCommand(){\\r\\n\\t\\tthis.initialize.apply(this, arguments);\\r\\n\\t}\\r\\n\\r\\n\\tWindow_CounterCommand.prototype = Object.create(Window_Command.prototype);\\r\\n\\tWindow_CounterCommand.prototype.constructor = Window_CounterCommand;\\r\\n\\r\\n\\tWindow_CounterCommand.prototype.initialize = function() {\\r\\n\\t\\tWindow_Command.prototype.initialize.call(this, 0, 0);\\r\\n\\t\\tthis._actor = null;\\r\\n\\t\\tthis._item = null;\\r\\n\\t\\tthis.openness = 0;\\r\\n\\t\\tthis.setup();\\r\\n\\t\\tthis.hide();\\r\\n\\t\\tthis.deactivate();\\r\\n\\t};\\r\\n\\r\\n\\tWindow_CounterCommand.prototype.makeCommandList = function() {  \\r\\n\\t\\tthis.addCommand(\\\"Counter\\\", 'counter');\\t\\r\\n\\t\\tthis.addCommand(\\\"Defend\\\", 'defend');\\r\\n\\t\\tthis.addCommand(\\\"Evade\\\", 'evade');\\r\\n\\t};\\r\\n\\r\\n\\tWindow_CounterCommand.prototype.setup = function(actorArray) {\\r\\n\\t\\tthis.clearCommandList();\\r\\n\\t\\tthis.makeCommandList();\\r\\n\\t\\tthis.refresh();\\r\\n\\t\\tthis.activate();\\r\\n\\t\\tthis.open();\\r\\n\\t};\\r\\n\\r\\n\\tWindow_CounterCommand.prototype.maxCols = function() {\\r\\n\\t\\treturn 1;\\r\\n\\t};\\r\\n\\r\\n\\tWindow_CounterCommand.prototype.windowHeight = function() {\\r\\n\\t\\treturn this.fittingHeight(3);\\r\\n\\t};\\r\\n\\t\\r\\n\\t\\r\\n\\tWindow_Base.prototype.drawSectionRect = function(x, y, w, h, margin, color) {\\r\\n\\t\\tvar lineWidth = 1;\\r\\n\\t\\tx+=margin;\\r\\n\\t\\ty+=margin;\\r\\n\\t\\tw-=2*margin;\\r\\n\\t\\th-=2*margin;\\r\\n\\t\\t//top\\r\\n\\t\\tthis.contents.fillRect(x ,y, w, lineWidth, color);\\r\\n\\t\\t//bottom\\r\\n\\t\\tthis.contents.fillRect(x, y + h, w + lineWidth, lineWidth, color);\\r\\n\\t\\t//left\\r\\n\\t\\tthis.contents.fillRect(x ,y, lineWidth, h, color);\\r\\n\\t\\t//right\\r\\n\\t\\tthis.contents.fillRect(x + w, y, lineWidth, h, color);\\r\\n\\t}\\r\\n\\t\\r\\n\\tWindow_Base.prototype.drawRect = function(x, y, w, h, margin, color) {\\r\\n\\t\\tx+=margin;\\r\\n\\t\\ty+=margin;\\r\\n\\t\\tw-=2*margin;\\r\\n\\t\\th-=2*margin;\\r\\n\\t\\tthis.contents.fillRect(x ,y, w, h, color);\\r\\n\\t}\\r\\n\\t\\r\\n\\tWindow_Base.prototype.windowInnerWidth = function() {\\r\\n        return this.windowWidth() - 38;\\r\\n    };\\r\\n\\t\\r\\n\\tWindow_Base.prototype.setFontSize = function(size) {\\r\\n        this.contents.fontSize = size;\\r\\n    };\\r\\n\\t\\r\\n\\tWindow_Base.prototype.setItalic = function(state) {\\r\\n        this.contents.fontItalic = state;\\r\\n    };\\r\\n\\t\\r\\n\\tWindow_Base.prototype.centerTextOffset = function(text, containerWidth) {\\r\\n        return containerWidth / 2 - this.textWidth(text) / 2;\\r\\n    };\\r\\n\\t\\r\\n\\t\\r\\n\\t\\r\\n\\tfunction Window_SRWItemBattle() {\\r\\n\\t\\tthis._parent = Window_BattleItem.prototype;\\r\\n\\t\\tthis.initialize.apply(this, arguments);\\t\\r\\n    }\\r\\n\\r\\n    Window_SRWItemBattle.prototype = Object.create(Window_BattleItem.prototype);\\r\\n    Window_SRWItemBattle.prototype.constructor = Window_SRWItemBattle;\\r\\n\\t\\r\\n\\tWindow_SRWItemBattle.prototype.maxCols = function(){\\r\\n\\t\\treturn 1;\\r\\n\\t}\\r\\n\\t\\r\\n\\tWindow_SRWItemBattle.prototype.windowWidth = function() {\\r\\n        return 240;\\r\\n    };\\r\\n\\r\\n    Window_SRWItemBattle.prototype.windowHeight = function() {\\r\\n        return this.fittingHeight(4);\\r\\n    };\\r\\n\\t\\r\\n\\tWindow_SRWItemBattle.prototype.refresh = function(){\\r\\n\\t\\tthis._parent.refresh.call(this);\\r\\n\\t}\\r\\n\\t\\r\\n\\tWindow_SRWItemBattle.prototype.drawItem = function(index) {\\r\\n\\t\\tvar item = this._data[index];\\r\\n\\t\\tif (item) {\\r\\n\\t\\t\\titem = $itemEffectManager.getAbilityDisplayInfo(item.itemIdx);\\r\\n\\t\\t\\tvar numberWidth = 0;//this.numberWidth();\\r\\n\\t\\t\\tvar rect = this.itemRect(index);\\r\\n\\t\\t\\t//rect.width -= this.textPadding();\\r\\n\\t\\t\\tthis.drawItemName(item, rect.x, rect.y, rect.width - numberWidth);\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\t\\r\\n\\tWindow_SRWItemBattle.prototype.drawItemName = function(item, x, y, width) {\\r\\n\\t\\twidth = width || 312;\\r\\n\\t\\tif (item) {\\r\\n\\t\\t\\tthis.resetTextColor();\\r\\n\\t\\t\\tthis.drawText(item.name, x + 10, y, width - 20);\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\t\\r\\n\\tWindow_SRWItemBattle.prototype.makeItemList = function() {\\r\\n\\t\\tvar actor = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n\\t\\tthis._data = $statCalc.getConsumables(actor);\\r\\n\\t};\\r\\n\\t\\r\\n\\tWindow_SRWItemBattle.prototype.isEnabled = function(item) {\\r\\n\\t\\treturn true;\\r\\n\\t};\\t\\r\\n\\t\\r\\n\\tfunction Window_SRWAbilityCommand() {\\r\\n\\t\\tthis._parent = Window_BattleItem.prototype;\\r\\n\\t\\tthis.initialize.apply(this, arguments);\\t\\r\\n    }\\r\\n\\r\\n    Window_SRWAbilityCommand.prototype = Object.create(Window_BattleItem.prototype);\\r\\n    Window_SRWAbilityCommand.prototype.constructor = Window_SRWAbilityCommand;\\r\\n\\t\\r\\n\\tWindow_SRWAbilityCommand.prototype.maxCols = function(){\\r\\n\\t\\treturn 1;\\r\\n\\t}\\r\\n\\t\\r\\n\\tWindow_SRWAbilityCommand.prototype.windowWidth = function() {\\r\\n        return 240;\\r\\n    };\\r\\n\\r\\n    Window_SRWAbilityCommand.prototype.windowHeight = function() {\\r\\n        return this.fittingHeight(4);\\r\\n    };\\r\\n\\t\\r\\n\\tWindow_SRWAbilityCommand.prototype.refresh = function(){\\r\\n\\t\\tthis._parent.refresh.call(this);\\r\\n\\t}\\r\\n\\t\\r\\n\\tWindow_SRWAbilityCommand.prototype.drawItem = function(index) {\\r\\n\\t\\tvar item = this._data[index];\\r\\n\\t\\tif (item != null) {\\r\\n\\t\\t\\titem = $abilityCommandManger.getAbilityDisplayInfo(item);\\r\\n\\t\\t\\tvar numberWidth = 0;//this.numberWidth();\\r\\n\\t\\t\\tvar rect = this.itemRect(index);\\r\\n\\t\\t\\t//rect.width -= this.textPadding();\\r\\n\\t\\t\\tthis.drawItemName(item, rect.x, rect.y, rect.width - numberWidth);\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\t\\r\\n\\tWindow_SRWAbilityCommand.prototype.drawItemName = function(item, x, y, width) {\\r\\n\\t\\twidth = width || 312;\\r\\n\\t\\tif (item) {\\r\\n\\t\\t\\tthis.resetTextColor();\\r\\n\\t\\t\\tthis.drawText(item.name, x + 10, y, width - 20);\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\t\\r\\n\\tWindow_SRWAbilityCommand.prototype.makeItemList = function() {\\r\\n\\t\\tvar actor = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n\\t\\tthis._data = $statCalc.getAbilityCommands(actor);\\r\\n\\t};\\r\\n\\t\\r\\n\\tWindow_SRWAbilityCommand.prototype.isEnabled = function(item) {\\r\\n\\t\\treturn true;\\r\\n\\t};\\t\\r\\n\\t\\r\\n\\tfunction Window_SRWTransformSelection() {\\r\\n\\t\\tthis._parent = Window_BattleItem.prototype;\\r\\n\\t\\tthis.initialize.apply(this, arguments);\\t\\r\\n    }\\r\\n\\r\\n    Window_SRWTransformSelection.prototype = Object.create(Window_BattleItem.prototype);\\r\\n    Window_SRWTransformSelection.prototype.constructor = Window_SRWTransformSelection;\\r\\n\\t\\r\\n\\tWindow_SRWTransformSelection.prototype.maxCols = function(){\\r\\n\\t\\treturn 1;\\r\\n\\t}\\r\\n\\t\\r\\n\\tWindow_SRWTransformSelection.prototype.windowWidth = function() {\\r\\n        return 240;\\r\\n    };\\r\\n\\r\\n    Window_SRWTransformSelection.prototype.windowHeight = function() {\\r\\n        return this.fittingHeight(4);\\r\\n    };\\r\\n\\t\\r\\n\\tWindow_SRWTransformSelection.prototype.refresh = function(){\\r\\n\\t\\tthis._parent.refresh.call(this);\\r\\n\\t}\\r\\n\\t\\r\\n\\tWindow_SRWTransformSelection.prototype.drawItem = function(index) {\\r\\n\\t\\tvar item = this._data[index];\\r\\n\\t\\tif (item != null) {\\r\\n\\t\\t\\titem = $dataClasses[item];\\r\\n\\t\\t\\tvar numberWidth = 0;//this.numberWidth();\\r\\n\\t\\t\\tvar rect = this.itemRect(index);\\r\\n\\t\\t\\t//rect.width -= this.textPadding();\\r\\n\\t\\t\\tthis.drawItemName(item, rect.x, rect.y, rect.width - numberWidth);\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\t\\r\\n\\tWindow_SRWTransformSelection.prototype.drawItemName = function(item, x, y, width) {\\r\\n\\t\\twidth = width || 312;\\r\\n\\t\\tif (item) {\\r\\n\\t\\t\\tthis.resetTextColor();\\r\\n\\t\\t\\tthis.drawText(item.name, x + 10, y, width - 20);\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\t\\r\\n\\tWindow_SRWTransformSelection.prototype.makeItemList = function() {\\r\\n\\t\\tvar actor = $gameSystem.EventToUnit($gameTemp.activeEvent().eventId())[1];\\r\\n\\t\\tthis._data = $statCalc.getTransformationList(actor);\\r\\n\\t};\\r\\n\\t\\r\\n\\tWindow_SRWTransformSelection.prototype.isEnabled = function(item) {\\r\\n\\t\\treturn true;\\r\\n\\t};\\t\\r\\n\\t\\r\\n\\t\\r\\n\\t\\r\\n\\tfunction Window_StageInfo() {\\r\\n\\t\\tthis.initialize.apply(this, arguments);\\r\\n\\t}\\r\\n\\r\\n\\tWindow_StageInfo.prototype = Object.create(Window_Base.prototype);\\r\\n\\tWindow_StageInfo.prototype.constructor = Window_StageInfo;\\r\\n\\r\\n\\tWindow_StageInfo.prototype.initialize = function(x, y) {\\r\\n\\t\\tvar width = this.windowWidth();\\r\\n\\t\\tvar height = this.windowHeight();\\r\\n\\t\\tWindow_Base.prototype.initialize.call(this, x, y, width, height);\\r\\n\\t\\tthis.refresh();\\r\\n\\t};\\r\\n\\r\\n\\tWindow_StageInfo.prototype.windowWidth = function() {\\r\\n\\t\\treturn 240;\\r\\n\\t};\\r\\n\\r\\n\\tWindow_StageInfo.prototype.windowHeight = function() {\\r\\n\\t\\tif($gameSystem.isSRPGMode()){\\r\\n\\t\\t\\treturn this.fittingHeight(4);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn this.fittingHeight(1);\\r\\n\\t\\t}\\t\\t\\r\\n\\t};\\r\\n\\r\\n\\tWindow_StageInfo.prototype.refresh = function() {\\r\\n\\t\\tvar lineheight = 35;\\r\\n\\t\\tvar columnOffset = 95;\\r\\n\\t\\tvar x = 5;\\r\\n\\t\\tvar y = 0;\\r\\n\\t\\tvar width = this.contents.width - this.textPadding() * 2;\\r\\n\\t\\tthis.contents.clear();\\r\\n\\t\\tthis.changeTextColor(\\\"#FFFFFF\\\");\\r\\n\\t\\t//this.drawCurrencyValue(this.value(), this.currencyUnit(), x, 0, width);\\r\\n\\t\\tthis.drawText(APPSTRINGS.MAPMENU.label_funds, x, 0, width);\\r\\n\\t\\tthis.drawText(this.value(), x + columnOffset , 0, width);\\r\\n\\t\\t\\r\\n\\t\\tthis.drawText(APPSTRINGS.MAPMENU.label_turn, x,  lineheight, width);\\r\\n\\t\\t/*--text-color-highlight: #f9e343;\\t\\r\\n\\t \\t--text-color-highlight2: #43dbf9;\\t*/\\r\\n\\t\\tthis.changeTextColor(\\\"#43dbf9\\\");\\r\\n\\t\\tthis.drawText($gameVariables.value(_turnVarID), x + columnOffset, lineheight, width);\\r\\n\\t\\tthis.changeTextColor(\\\"#FFFFFF\\\");\\r\\n\\t\\tthis.drawText(APPSTRINGS.MAPMENU.label_enemy, x,  lineheight * 2, width);\\r\\n\\t\\tthis.changeTextColor(\\\"#AA2222\\\");\\r\\n\\t\\tthis.drawText($gameVariables.value(_enemiesDestroyed), x + columnOffset,  lineheight * 2, width);\\r\\n\\t\\tthis.changeTextColor(\\\"#FFFFFF\\\");\\r\\n\\t\\tthis.drawText(\\\"/\\\", x + columnOffset + 30,  lineheight * 2, width);\\r\\n\\t\\tthis.changeTextColor(\\\"#43dbf9\\\");\\r\\n\\t\\tthis.drawText($gameVariables.value(_enemiesDestroyed) + $gameVariables.value(_existEnemyVarID), x + columnOffset + 45,  lineheight * 2, width);\\r\\n\\t\\tthis.changeTextColor(\\\"#FFFFFF\\\");\\r\\n\\t\\t\\r\\n\\t\\tthis.drawText(APPSTRINGS.MAPMENU.label_ally, x,  lineheight * 3, width);\\r\\n\\t\\tthis.changeTextColor(\\\"#AA2222\\\");\\r\\n\\t\\tthis.drawText($gameVariables.value(_actorsDestroyed), x + columnOffset,  lineheight * 3, width);\\r\\n\\t\\tthis.changeTextColor(\\\"#FFFFFF\\\");\\r\\n\\t\\tthis.drawText(\\\"/\\\", x + columnOffset + 30,  lineheight * 3, width);\\r\\n\\t\\tthis.changeTextColor(\\\"#43dbf9\\\");\\r\\n\\t\\tthis.drawText($gameVariables.value(_actorsDestroyed) + $gameVariables.value(_existActorVarID), x + columnOffset + 45,  lineheight * 3, width);\\r\\n\\t\\tthis.changeTextColor(\\\"#FFFFFF\\\");\\r\\n\\t\\t\\r\\n\\t};\\r\\n\\r\\n\\tWindow_StageInfo.prototype.value = function() {\\r\\n\\t\\treturn $gameParty.gold();\\r\\n\\t};\\r\\n\\r\\n\\tWindow_StageInfo.prototype.currencyUnit = function() {\\r\\n\\t\\treturn TextManager.currencyUnit;\\r\\n\\t};\\r\\n\\r\\n\\tWindow_StageInfo.prototype.open = function() {\\r\\n\\t\\tthis.refresh();\\r\\n\\t\\tWindow_Base.prototype.open.call(this);\\r\\n\\t};\\r\\n\\t\\r\\n\\t\\r\\n\\tfunction Window_ConditionsInfo() {\\r\\n\\t\\tthis.initialize.apply(this, arguments);\\r\\n\\t}\\r\\n\\r\\n\\tWindow_ConditionsInfo.prototype = Object.create(Window_Base.prototype);\\r\\n\\tWindow_ConditionsInfo.prototype.constructor = Window_ConditionsInfo;\\r\\n\\r\\n\\tWindow_ConditionsInfo.prototype.initialize = function(x, y) {\\r\\n\\t\\tvar width = this.windowWidth();\\r\\n\\t\\tvar height = this.windowHeight();\\r\\n\\t\\tWindow_Base.prototype.initialize.call(this, x, y, width, height);\\r\\n\\t\\tthis.refresh();\\r\\n\\t};\\r\\n\\r\\n\\tWindow_ConditionsInfo.prototype.windowWidth = function() {\\r\\n\\t\\treturn 760;\\r\\n\\t};\\r\\n\\r\\n\\tWindow_ConditionsInfo.prototype.windowHeight = function() {\\r\\n\\t\\treturn this.fittingHeight(6);\\r\\n\\t};\\r\\n\\r\\n\\tWindow_ConditionsInfo.prototype.refresh = function() {\\r\\n\\t\\tvar lineheight = 35;\\r\\n\\t\\tvar columnOffset = 95;\\r\\n\\t\\tvar x = 5;\\r\\n\\t\\tvar y = 0;\\r\\n\\t\\tvar width = this.contents.width - this.textPadding() * 2;\\r\\n\\t\\tthis.contents.clear();\\r\\n\\t\\tthis.changeTextColor(\\\"#FFFFFF\\\");\\r\\n\\t\\t//this.drawCurrencyValue(this.value(), this.currencyUnit(), x, 0, width);\\r\\n\\t\\t/*$gameMessage.add(APPSTRINGS.GENERAL.label_victory_condition + \\\": \\\"+$gameVariables.value(_victoryConditionText));\\r\\n\\t\\t$gameMessage.add(APPSTRINGS.GENERAL.label_defeat_condition + \\\": \\\"+$gameVariables.value(_defeatConditionText));\\r\\n\\t\\t$gameMessage.add(APPSTRINGS.GENERAL.label_mastery_condition + \\\": \\\"+$gameVariables.value(_masteryConditionText));*/\\r\\n\\t\\t/*--text-color-highlight: #f9e343;\\t\\r\\n\\t \\t--text-color-highlight2: #43dbf9;\\t*/\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\tthis.changeTextColor(\\\"#43dbf9\\\");\\r\\n\\t\\tthis.drawText(APPSTRINGS.GENERAL.label_victory_condition, x, 0, width);\\r\\n\\t\\t\\r\\n\\t\\tthis.drawText(APPSTRINGS.GENERAL.label_defeat_condition, x, lineheight * 2, width);\\r\\n\\t\\t\\r\\n\\t\\tthis.drawText(APPSTRINGS.GENERAL.label_mastery_condition, x, lineheight * 4, width);\\r\\n\\t\\t\\r\\n\\t\\tthis.changeTextColor(\\\"#FFFFFF\\\");\\r\\n\\t\\t\\r\\n\\t\\tvar valueOffset = 20;\\r\\n\\t\\tthis.drawText($gameVariables.value(_victoryConditionText) || \\\"\\\", x + valueOffset, lineheight, width - valueOffset);\\r\\n\\t\\t\\r\\n\\t\\tthis.drawText($gameVariables.value(_defeatConditionText) || \\\"\\\", x + valueOffset, lineheight * 3, width - valueOffset);\\r\\n\\t\\t\\r\\n\\t\\tvar masteryText = $gameVariables.value(_masteryConditionText);\\r\\n\\t\\tif($SRWSaveManager.isMapSRPointLocked($gameMap.mapId())){\\r\\n\\t\\t\\tmasteryText = APPSTRINGS.GENERAL.label_mastery_locked;\\r\\n\\t\\t}\\r\\n\\t\\tthis.drawText(masteryText || \\\"\\\", x + valueOffset, lineheight * 5, width - valueOffset);\\r\\n\\t\\t/*\\r\\n\\t\\tthis.drawText(APPSTRINGS.MAPMENU.label_funds, x, 0, width);\\r\\n\\t\\tthis.drawText(this.value(), x + columnOffset , 0, width);\\r\\n\\t\\t\\r\\n\\t\\tthis.drawText(APPSTRINGS.MAPMENU.label_turn, x,  lineheight, width);\\r\\n\\t\\t\\r\\n\\t\\tthis.changeTextColor(\\\"#43dbf9\\\");\\r\\n\\t\\tthis.drawText($gameVariables.value(_turnVarID), x + columnOffset, lineheight, width);\\r\\n\\t\\tthis.changeTextColor(\\\"#FFFFFF\\\");\\r\\n\\t\\tthis.drawText(APPSTRINGS.MAPMENU.label_enemy, x,  lineheight * 2, width);\\r\\n\\t\\tthis.changeTextColor(\\\"#AA2222\\\");\\r\\n\\t\\tthis.drawText($gameVariables.value(_enemiesDestroyed), x + columnOffset,  lineheight * 2, width);\\r\\n\\t\\tthis.changeTextColor(\\\"#FFFFFF\\\");\\r\\n\\t\\tthis.drawText(\\\"/\\\", x + columnOffset + 30,  lineheight * 2, width);\\r\\n\\t\\tthis.changeTextColor(\\\"#43dbf9\\\");\\r\\n\\t\\tthis.drawText($gameVariables.value(_enemiesDestroyed) + $gameVariables.value(_existEnemyVarID), x + columnOffset + 45,  lineheight * 2, width);\\r\\n\\t\\tthis.changeTextColor(\\\"#FFFFFF\\\");\\r\\n\\t\\t\\r\\n\\t\\tthis.drawText(APPSTRINGS.MAPMENU.label_ally, x,  lineheight * 3, width);\\r\\n\\t\\tthis.changeTextColor(\\\"#AA2222\\\");\\r\\n\\t\\tthis.drawText($gameVariables.value(_actorsDestroyed), x + columnOffset,  lineheight * 3, width);\\r\\n\\t\\tthis.changeTextColor(\\\"#FFFFFF\\\");\\r\\n\\t\\tthis.drawText(\\\"/\\\", x + columnOffset + 30,  lineheight * 3, width);\\r\\n\\t\\tthis.changeTextColor(\\\"#43dbf9\\\");\\r\\n\\t\\tthis.drawText($gameVariables.value(_actorsDestroyed) + $gameVariables.value(_existActorVarID), x + columnOffset + 45,  lineheight * 3, width);\\r\\n\\t\\tthis.changeTextColor(\\\"#FFFFFF\\\");*/\\r\\n\\t\\t\\r\\n\\t};\\r\\n\\r\\n\\tWindow_ConditionsInfo.prototype.value = function() {\\r\\n\\t\\treturn $gameParty.gold();\\r\\n\\t};\\r\\n\\r\\n\\tWindow_ConditionsInfo.prototype.currencyUnit = function() {\\r\\n\\t\\treturn TextManager.currencyUnit;\\r\\n\\t};\\r\\n\\r\\n\\tWindow_ConditionsInfo.prototype.open = function() {\\r\\n\\t\\tthis.refresh();\\r\\n\\t\\tWindow_Base.prototype.open.call(this);\\r\\n\\t};\\r\\n\\t\\r\\n//====================================================================\\r\\n// Save Management\\r\\n//====================================================================\\t\\r\\n\\tDataManager.makeSavefileInfo = function() {\\r\\n\\t\\tvar info = {};\\r\\n\\t\\tinfo.globalId   = this._globalId;\\r\\n\\t\\tinfo.title      = $gameSystem.saveDisplayName || $dataSystem.gameTitle;\\r\\n\\t\\tinfo.characters = $gameParty.charactersForSavefile();\\r\\n\\t\\tinfo.faces      = $gameParty.facesForSavefile();\\r\\n\\t\\tinfo.playtime   = $gameSystem.playtimeText();\\r\\n\\t\\tinfo.timestamp  = Date.now();\\r\\n\\t\\tinfo.funds = $gameParty.gold();\\r\\n\\t\\tinfo.SRCount = $SRWSaveManager.getSRCount();\\r\\n\\t\\tinfo.turnCount =  $gameVariables.value(_turnCountVariable)\\r\\n\\t\\treturn info;\\r\\n\\t};\\r\\n\\t\\r\\n\\tDataManager.saveContinueSlot = function() {\\r\\n\\t\\tvar savefileId = \\\"continue\\\";\\r\\n\\t\\t$gameSystem.onBeforeSave();\\r\\n\\t\\tvar json = JsonEx.stringify({date: Date.now(), content: this.makeSaveContents()});\\t\\t\\r\\n\\t\\tStorageManager.save(savefileId, json);\\r\\n\\t\\treturn true;\\r\\n\\t};\\r\\n\\t\\r\\n\\tDataManager.loadContinueSlot = function() {\\r\\n\\t\\ttry{\\r\\n\\t\\t\\tvar savefileId = \\\"continue\\\";\\r\\n\\t\\t\\tvar globalInfo = this.loadGlobalInfo();\\t\\t\\r\\n\\t\\t\\tvar json = StorageManager.load(savefileId);\\r\\n\\t\\t\\tthis.createGameObjects();\\r\\n\\t\\t\\tthis.extractSaveContents(JsonEx.parse(json).content);\\r\\n\\t\\t\\t$statCalc.softRefreshUnits();\\r\\n\\t\\t\\tSceneManager._scene.fadeOutAll()\\r\\n\\t\\t\\tSceneManager.goto(Scene_Map);\\r\\n\\t\\t\\tif($gameSystem._bgmOnSave){\\r\\n\\t\\t\\t\\t$gameTemp.continueLoaded = true;\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t} catch(e){\\r\\n\\t\\t\\tconsole.log(\\\"Attempted to load non existant continue save!\\\");\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\treturn true;\\t\\t\\r\\n\\t};\\r\\n\\t\\r\\n\\tDataManager.latestSavefileDate = function() {\\r\\n\\t\\tvar globalInfo = this.loadGlobalInfo();\\r\\n\\t\\tvar savefileId = 1;\\r\\n\\t\\tvar timestamp = 0;\\r\\n\\t\\tif (globalInfo) {\\r\\n\\t\\t\\tfor (var i = 1; i < globalInfo.length; i++) {\\r\\n\\t\\t\\t\\tif (this.isThisGameFile(i) && globalInfo[i].timestamp > timestamp) {\\r\\n\\t\\t\\t\\t\\ttimestamp = globalInfo[i].timestamp;\\r\\n\\t\\t\\t\\t\\tsavefileId = i;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn timestamp;\\r\\n\\t};\\r\\n\\t\\r\\n\\tWindow_SavefileList.prototype.drawItem = function(index) {\\r\\n\\t\\tvar id = index + 1;\\r\\n\\t\\tvar valid = DataManager.isThisGameFile(id);\\r\\n\\t\\tvar info = DataManager.loadSavefileInfo(id);\\r\\n\\t\\tvar rect = this.itemRectForText(index);\\r\\n\\t\\tthis.resetTextColor();\\r\\n\\t\\tif (this._mode === 'load') {\\r\\n\\t\\t\\tthis.changePaintOpacity(valid);\\r\\n\\t\\t}\\r\\n\\t\\tthis.drawFileId(id, rect.x, rect.y);\\r\\n\\t\\tif (info) {\\r\\n\\t\\t\\tthis.changePaintOpacity(valid);\\r\\n\\t\\t\\tthis.drawContents(info, rect, valid);\\r\\n\\t\\t\\tthis.changePaintOpacity(true);\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\t\\r\\n\\tWindow_SavefileList.prototype.drawContents = function(info, rect, valid) {\\r\\n\\t\\tvar bottom = rect.y + rect.height;\\r\\n\\t\\tif (rect.width >= 420) {\\r\\n\\t\\t\\tthis.drawGameTitle(info, rect.x + 192, rect.y, rect.width - 192);\\r\\n\\t\\t\\tif (valid) {\\r\\n\\t\\t\\t\\tthis.drawPartyCharacters(info, rect.x + 220, bottom - 4);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tvar lineHeight = this.lineHeight();\\r\\n\\t\\tvar y2 = bottom - lineHeight;\\r\\n\\t\\tif (y2 >= lineHeight) {\\r\\n\\t\\t\\tthis.drawPlaytime(info, rect.x, y2, rect.width);\\r\\n\\t\\t}\\r\\n\\t\\tvar offSetX = 20;\\r\\n\\t\\tvar bottomOffset = 54;\\r\\n\\t\\tif(info.funds != null){\\r\\n\\t\\t\\tthis.drawText(APPSTRINGS.SAVEMENU.label_funds+\\\": \\\"+info.funds, offSetX + rect.x, bottom - bottomOffset, 240);\\r\\n\\t\\t}\\r\\n\\t\\tif(info.funds != null){\\r\\n\\t\\t\\tthis.drawText(APPSTRINGS.SAVEMENU.label_SR_count+\\\": \\\"+info.SRCount, offSetX + rect.x + 240, bottom - bottomOffset, 240);\\r\\n\\t\\t}\\r\\n\\t\\tif(info.funds != null){\\r\\n\\t\\t\\tthis.drawText(APPSTRINGS.SAVEMENU.label_turn_count+\\\": \\\"+info.turnCount, offSetX + rect.x + 480, bottom - bottomOffset, 240);\\r\\n\\t\\t}\\t\\t\\r\\n\\t};\\r\\n\\t\\r\\n\\tWindow_Options.prototype.addGeneralOptions = function() {\\r\\n\\t\\tthis.addCommand(APPSTRINGS.GENERAL.label_dash_pref, 'alwaysDash');\\r\\n\\t\\t//this.addCommand(TextManager.commandRemember, 'commandRemember');\\r\\n\\t};\\r\\n\\t\\r\\n\\tWindow_Message.prototype.isInstantText = function() {\\r\\n\\t\\treturn Input.isPressed('ok') && Input.isPressed('pagedown');\\r\\n\\t}\\r\\n\\t\\r\\n\\tWindow_Message.prototype.updateMessage = function() {\\r\\n\\t\\tif (this._textState) {\\r\\n\\t\\t\\twhile (!this.isEndOfText(this._textState)) {\\r\\n\\t\\t\\t\\tif (this.needsNewPage(this._textState)) {\\r\\n\\t\\t\\t\\t\\tthis.newPage(this._textState);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tthis.updateShowFast();\\r\\n\\t\\t\\t\\tthis.processCharacter(this._textState);\\r\\n\\t\\t\\t\\tif(!this.isInstantText()){\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tif (!this._showFast && !this._lineShowFast) {\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tif (this.pause || this._waitCount > 0) {\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t} \\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (this.isEndOfText(this._textState)) {\\r\\n\\t\\t\\t\\tthis.onEndOfText();\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\t\\r\\n\\tWindow_Message.prototype.updateInput = function() {\\t\\t\\r\\n\\t\\tif (this.isAnySubWindowActive()) {\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t}\\r\\n\\t\\tif (this.pause) {\\r\\n\\t\\t\\tif (this.isTriggered() || this.isInstantText()) {\\r\\n\\t\\t\\t\\tInput.update();\\r\\n\\t\\t\\t\\tthis.pause = false;\\r\\n\\t\\t\\t\\tif (!this._textState) {\\r\\n\\t\\t\\t\\t\\tthis.terminateMessage();\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t}\\r\\n\\t\\treturn false;\\r\\n\\t};\\r\\n\\t\\r\\n\\tWindow_Message.prototype.startPause = function() {\\r\\n\\t\\tvar waitCount;\\r\\n\\t\\tif(this.isInstantText()){\\r\\n\\t\\t\\twaitCount = 2;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\twaitCount = 10;\\r\\n\\t\\t}\\r\\n\\t\\tthis.startWait(waitCount);\\r\\n\\t\\tthis.pause = true;\\r\\n\\t};\\r\\n\\t\\r\\n\\t//patch the audio manager to suppress sound effects while events are being skipped\\r\\n\\tAudioManager.playSe = function(se) {\\r\\n\\t\\tif (se.name && !$gameTemp.isSkippingEvents) {\\r\\n\\t\\t\\tthis._seBuffers = this._seBuffers.filter(function(audio) {\\r\\n\\t\\t\\t\\treturn audio.isPlaying();\\r\\n\\t\\t\\t});\\r\\n\\t\\t\\tvar buffer = this.createBuffer('se', se.name);\\r\\n\\t\\t\\tthis.updateSeParameters(buffer, se);\\r\\n\\t\\t\\tbuffer.play(false);\\r\\n\\t\\t\\tthis._seBuffers.push(buffer);\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\t\\t\\r\\n})();\\r\\n\\r\\n\");\n\n//# sourceURL=webpack:///./js/SRW_Core/SRPG_core.js?./node_modules/raw-loader/dist/cjs.js");

/***/ })

}]);